<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
/>
<title>日程清单</title>
<style>
  /* ===== CSS 自定义属性（变量）===== */
  :root{
    /* 布局相关变量 */
    --rule-gap: 36px;         /* 行间距基准 */
    --page-pad-x: 16px;       /* 页面水平内边距 */

    /* 图标相关变量 */
    --icon-bg-size: 16px;     /* 图标背景尺寸 */
    --icon-emoji-size: 14px;  /* emoji图标尺寸 */
    --icon-bg:   #f5f5f7;     /* 图标背景色 */
    --icon-fg:   #111;        /* 图标前景色 */

    /* 主题颜色变量 */
    --blue: #007aff;          /* iOS蓝色 */
    --red:  #ff3b30;          /* iOS红色 */
    --stripe-default: #C7C7CC; /* 默认竖条颜色 */
  }

  /* ===== 全局重置和基础样式 ===== */
  html,body{height:100%}

  /* 禁止文本选择、下拉刷新、缩放（编辑区允许选中） */
  html, body {
    overscroll-behavior: none;        /* 禁止滚动边界效果 */
    -webkit-text-size-adjust: 100%;   /* 禁止iOS文字自动调整 */
    touch-action: pan-y;              /* 仅允许垂直滚动 */
    overflow-x: hidden;               /* 防止水平溢出 */
    max-width: 100vw;                 /* 限制最大宽度 */
  }
  * {
    -webkit-user-select: none;        /* 禁止文本选择 */
    user-select: none;
    -webkit-tap-highlight-color: transparent; /* 移除点击高亮 */
    -webkit-touch-callout: none;      /* 禁止长按菜单 */
  }

  body{
    font-family:-apple-system,BlinkMacSystemFont,sans-serif; /* iOS系统字体 */
    margin:0; padding:0 var(--page-pad-x) 64px;
    font-size:10px; color:#222; background:#fff;
  }

  /* ===== 顶部页眉样式 ===== */
  /* 页眉容器：粘性定位，显示日期和添加按钮 */
  .page-header{position:sticky;top:0;z-index:10;background:#fff}
  .page-header-row{display:flex;align-items:center;justify-content:space-between;height:var(--rule-gap);padding:0 2px}
  .header-left{font-size:22px;font-weight:700;color:var(--red)} /* 左侧日期，红色突出 */
  .header-right{display:flex;align-items:center;gap:8px;position:relative}
  .header-right #headerDate{display:none} /* 小屏隐藏重复日期 */
  /* 添加按钮 - 优化为更大的触控目标 */
  .add-btn{
    font-size:18px;           /* 增大字体 */
    font-weight:600;
    color:var(--blue);
    cursor:pointer;
    min-width:44px;           /* iOS推荐最小触控尺寸 */
    min-height:44px;
    display:flex;
    align-items:center;
    justify-content:center;
    border-radius:50%;
    position:relative;
    transition: all 0.2s ease;
  }
  .add-btn:active{
    opacity:.6;
    transform: scale(0.9);    /* 点击缩放反馈 */
    background: rgba(0,122,255,0.1);
  }
  .add-btn:hover{
    background: rgba(0,122,255,0.08);
    transform: scale(1.05);
  }
  /* 扩展点击区域 */
  .add-btn::before{
    content: '';
    position: absolute;
    top: -8px;
    left: -8px;
    right: -8px;
    bottom: -8px;
    border-radius: 50%;
  }
  /* 待办分区添加按钮样式 */
  .todo-add-btn{
    background: rgba(52, 199, 89, 0.1);
    color: #34c759;
  }
  .todo-add-btn:hover{
    background: rgba(52, 199, 89, 0.15);
  }

    .todo-add-btn:active{
    background: rgba(52, 199, 89, 0.2);
  }
  /* 日程分区添加按钮样式 */
  .schedule-add-btn{
    background: rgba(10, 132, 255, 0.1);
    color: var(--blue);
  }
  .schedule-add-btn:hover{
    background: rgba(10, 132, 255, 0.15);
  }
  .schedule-add-btn:active{
    background: rgba(10, 132, 255, 0.2);
  }

  /* ===== 待办事项区域样式 ===== */
  /* 待办事项标题样式 */
  .section-title{
    font-size:22px; line-height:26px; font-weight:800; color:#0a84ff;
    letter-spacing:.3px; /* 字符间距增加可读性 */
  }

  /* 待办分区样式：隐藏左侧竖线并调整左边距以保持对齐 */
  .partition.todo-partition {
      padding-left: 0; /* 取消额外的左边距，因为外层section已经有padding */
  }
  .partition.todo-partition .partition-stripe {
      display: none;
  }

  /* 待办分区标题样式：与全天日程标题大小一致 */
  .partition.todo-partition .section-title {
      font-size: 16px;
      letter-spacing: 0.5px;
  }

  /* 可编辑的待办分区标题样式 */
  .partition.todo-partition .section-title[contenteditable="true"] {
      border-radius: 4px;
      padding: 2px 4px;
      background: rgba(0, 122, 255, 0.05);
      outline: none;
  }

  .partition.todo-partition .section-title[contenteditable="true"]:focus {
      border: 1px solid #007aff;
      background: rgba(0, 122, 255, 0.1);
  }


  /* 待办头部特殊样式 */
  .todo-header {
    display: grid;
    grid-template-columns: auto 1fr auto;
    align-items: center;
    gap: 6px;
  }
  .todo-header{
    display:flex; align-items:center; justify-content:space-between;
    margin:10px 0 6px;
  }
  /* 分区分割线 */
  .section-divider{ height:1px; background:#e5e5ea; margin:8px calc(-1 * var(--page-pad-x)) 10px; pointer-events:none; }

  /* ===== 分区（含待办也复用此容器类） ===== */
  .partition{ position:relative; padding-left:10px; }
  .partition-stripe{ position:absolute; left:0; top:6px; bottom:6px; width:3px; background:var(--stripe-default); border-radius:2px; }
  .partition-sep{ height:1px; background:#e5e5ea; margin:6px calc(-1 * var(--page-pad-x)) 6px; }

  /* 全天日程分区特殊样式 */
  .allday-partition {
    background: rgba(52, 199, 89, 0.05);
    border-radius: 8px;
    margin-bottom: 8px;
    padding: 8px 10px 8px 10px;
  }
  .allday-partition .partition-header {
    padding: 4px 0;
  }
  .allday-partition .title-text {
    font-size: 16px;
    letter-spacing: 0.5px;
  }

  /* 分区包装容器 */
  .partition-wrapper {
    position: relative;
    overflow: hidden;
    width: 100%;
  }

  /* 分区删除按钮样式 */
  .partition-delete {
    position: absolute;
    right: -70px;
    top: 50%;
    transform: translateY(-50%);
    height: 24px;
    width: 70px;
    background: #ff3b30;
    color: #fff;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 10px;
    font-weight: 600;
    border-radius: 4px;
    transition: right 0.2s ease;
  }

  .partition-delete:hover {
    background: #e6342a;
  }

  /* 分区头部可滑动样式 */
  .partition-header.swipeable {
    position: relative;
    transition: transform 0.3s ease;
    overflow: hidden;
  }

  .partition-header{
    min-height:var(--rule-gap);
    display:grid;
    grid-template-columns:auto 1fr auto; /* 图标 | 标题 | 右侧 */
    align-items:center; gap:6px; position:relative;
  }
  .icon-wrap{
    width:var(--icon-bg-size); height:var(--icon-bg-size);
    border-radius:999px; background:var(--icon-bg);
    display:grid; place-items:center;
    box-shadow:0 1px 2px rgba(0,0,0,.08), inset 0 0 0 1px #ececec;
    cursor:pointer;
    /* 扩大点击区域和改善触控体验 */
    position: relative;
    margin: 6px;
    min-width: 24px;  /* iOS推荐的最小触控目标 */
    min-height: 24px;
    transition: all 0.2s ease;
  }
  /*.icon-wrap::before{*/
  /*  content: '';*/
  /*  position: absolute;*/
  /*  top: -8px;*/
  /*  left: -8px;*/
  /*  right: -8px;*/
  /*  bottom: -8px;*/
  /*  !* 增加24px的点击区域，但不显示 *!*/
  /*  border-radius: 999px;*/
  /*}*/
  .icon-wrap:active{
    transform: scale(0.95);
    background: #e8e8ea;
  }
  .icon-wrap:hover{
    box-shadow: 0 2px 8px rgba(0,0,0,.12), inset 0 0 0 1px #dcdcdc;
  }
  .icon-emoji{ font-size:var(--icon-emoji-size); line-height:1; color:var(--icon-fg); }
  .partition-title{ font-size:15px; font-weight:600; color:#000; display:flex; align-items:center; gap:6px; line-height:var(--rule-gap) }
  .title-text[contenteditable="true"]{
    outline:none;border:none;border-radius:6px;padding:0 4px;
    -webkit-user-select:text; user-select:text;
  }
  .title-text[contenteditable="true"]:focus{background:#f5f5f7}

  .right-box{ display:flex; align-items:center; justify-content:flex-end; gap:8px }

  /* 时间 pill（更紧凑版） */
  .partition-time{ display:inline-flex; align-items:center; gap:2px; font-size:11px; color:#666; font-weight:500; line-height:1 }
  .partition-time .clickable-time{ cursor:pointer; color:inherit }
  .time-pill{
    display:inline-flex; align-items:center; justify-content:center;
    min-width:28px; padding:0 5px; height:14px;
    background:#f5f5f7; border:1px solid #dcdcdc; border-radius:999px;
    font-size:10px; line-height:12px; user-select:none;
    box-shadow:0 1px 0 rgba(0,0,0,.02), inset 0 0 0 0.5px rgba(255,255,255,.5);
    cursor:pointer; transition:all .12s ease; position:relative;
  }
  .time-pill:active{transform:scale(.96)}
  .time-dash{margin:0 1px; opacity:.45; font-size:10px; line-height:1}
  /* overlay time input styles from old.html */
  .overlay-time{
    position:absolute;inset:0;opacity:0;border:none;background:transparent;
    -webkit-appearance:none;appearance:none;width:100%;height:100%;
    pointer-events:auto;
  }

  /* ===== 徽标（通用） + 折叠样式 ===== */
  .badge{
    display:inline-flex;align-items:center;justify-content:center;
    min-width:16px;height:14px;padding:0 6px;border-radius:999px;
    background:var(--stripe-soft, rgba(0,0,0,.08));
    color:var(--stripe-color, #007aff);
    border:2px solid transparent;
    font-size:9px;font-weight:700;line-height:14px;box-shadow:0 1px 2px rgba(0,0,0,0.06);
    cursor:pointer;
    transition:background .15s ease, border-color .15s ease, color .15s ease;
    position:relative;z-index:2;
  }
  .badge.is-collapsed{ background:transparent; color:var(--stripe-color, #007aff); border-color:var(--stripe-color, #007aff); box-shadow:none }
  .collapsed{display:none}

  /* 待办徽标：圆形折叠按钮，使用更现代的设计 */
  .badge-chevron{
    --stripe-color:#0a84ff;
    --stripe-soft:rgba(10,132,255,.12);
    width: 14px;
    height: 14px;
    border-radius: 50%;
    min-width: 14px;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    background: var(--stripe-soft);
    border: 1.5px solid transparent;
    box-shadow: 0 2px 8px rgba(10,132,255,0.15);
    transition: all .25s ease;
    margin-right: 4px;
  }
  .badge-chevron:hover{
    background: var(--stripe-color);
    color: #fff;
    transform: scale(1.05);
    box-shadow: 0 4px 12px rgba(10,132,255,0.25);
  }
  .badge-chevron:active{
    transform: scale(0.95);
  }
  .badge-chevron.is-collapsed{
    background: transparent;
    border-color: var(--stripe-color);
    color: var(--stripe-color);
    box-shadow: none;
  }
  .badge-chevron.is-collapsed:hover{
    background: var(--stripe-soft);
    border-color: var(--stripe-color);
    color: var(--stripe-color);
    transform: scale(1.05);
    box-shadow: 0 2px 8px rgba(10,132,255,0.15);
  }
  .badge-chevron .chev{
    display: inline-block;
    width: 0;
    height: 0;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    border-top: 7px solid currentColor;
    transition: transform .25s cubic-bezier(0.4, 0, 0.2, 1);
    margin-top: 1px;
  }
  .badge-chevron.is-collapsed .chev{
    transform: rotate(-90deg);
    margin-top: 0;
    margin-left: 1px;
  }

  /* ===== 任务行（待办与日程共用） ===== */
  .task-list{margin:0;padding:0}
  .task-wrapper{position:relative;overflow:hidden}
  .task-delete{
    position:absolute;right:-60px;top:0;bottom:0;width:60px;
    background:#ff3b30;color:#fff;display:flex;justify-content:center;align-items:center;
    font-size:10px;z-index:3;transition:right .2s ease
  }

  /* 层级操作按钮样式 */
  .task-actions{
    position:absolute;left:-120px;top:0;bottom:0;width:120px;
    display:flex;z-index:3;transition:left .2s ease;
  }
  .task-indent{
    width:60px;background:#007aff;color:#fff;display:flex;justify-content:center;align-items:center;
    font-size:10px;font-weight:600;
  }
  .task-outdent{
    width:60px;background:#ff9500;color:#fff;display:flex;justify-content:center;align-items:center;
    font-size:10px;font-weight:600;
  }
  .task-delete.with-level{
    right:-180px;width:60px;
  }
  .task-actions.with-delete{
    right:-180px;width:120px;
  }
  .task{
    display:flex;
    align-items:center;
    gap:8px;
    height:var(--rule-gap);
    transition:transform .2s ease;position:relative;background:transparent;z-index:2;
  }
  .task .checkbox{
    flex-shrink:0;
    width:18px;
  }
  .task .task-input{
    flex:1;
    min-width:0;
  }
  .task .task-collapse{
    flex-shrink:0;
  }
  .task .task-handle{
    flex-shrink:0;
  }

  /* 子任务缩进样式 */
  .task.level-1{
    margin-left:24px;
    opacity:0.9;
  }
  .checkbox{width:18px;height:18px;border:2px solid #999;border-radius:50%;cursor:pointer;transition:all .15s ease;box-sizing:border-box;background:transparent;display:flex;align-items:center;justify-content:center}
  .checkbox.done{background-color:var(--blue);border-color:var(--blue);position:relative}
  .checkbox.done::after{content:"";position:absolute;inset:0;background:center/70% no-repeat url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="white" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg>')}
  .checkbox.placeholder{border-style:dashed;border-color:#bbb}

  /* 模板任务样式 */
  .checkbox.template{
    border:none;
    background:transparent;
    cursor:not-allowed;
  }
  .checkbox.template::after{
    content:"★";
    color:#C9A103;
    font-size:18px;
    line-height:1;
  }

  /* 周期任务样式 */
  .checkbox.recurring{
    border: none;
    background: transparent;
    cursor:not-allowed;
    position: relative;
    width: 18px;
    height: 18px;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  /* 有Done+功能的周期任务可以点击 */
  .checkbox.recurring.has-done-plus{
    cursor: pointer;
  }
  .checkbox.recurring::after{
    content:"";
    width: 16px;
    height: 16px;
    background: center/contain no-repeat url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="%23007aff" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M4 12a8 8 0 0 1 13-5.3"/><polyline points="14.5 4 17 6.5 14.5 9"/><path d="M20 12a8 8 0 0 1-13 5.3"/><polyline points="9.5 20 7 17.5 9.5 15"/></svg>');
  }
  .checkbox.recurring.filled{
    background: transparent;
    border: none;
  }
  .checkbox.recurring.filled::after{
    filter: none;
  }

  /* Done+功能样式 */
  .done-plus-badge {
    position: absolute;
    top: -8px;
    right: -10px;
    color: #007aff;
    font-size: 16px;
    font-weight: 600;
    z-index: 15;
    pointer-events: none;
    line-height: 1;
    text-shadow: 0 0 2px rgba(255,255,255,0.8);
  }

  /* 确保Done+角标在模板任务checkbox上也能正确显示 */
  .checkbox.template .done-plus-badge {
    z-index: 20;
    color: #007aff;
  }

  /* Done+表单样式 */
  .done-plus-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1001;
    display: none;
  }

  .done-plus-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
  }

  .done-plus-form {
    position: fixed;
    bottom: 0;
    left: 0;
    right: 0;
    background: rgba(255, 255, 255, 0.95);
    backdrop-filter: saturate(180%) blur(20px);
    -webkit-backdrop-filter: saturate(180%) blur(20px);
    border-top-left-radius: 16px;
    border-top-right-radius: 16px;
    padding: 20px;
    max-height: 80vh;
    overflow-y: auto;
    transform: translateY(100%);
    transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    z-index: 1002;
  }

  .done-plus-form.show {
    transform: translateY(0);
  }

  /* Done+表单头部样式 - iOS标准布局 */
  .done-plus-header.sheet-hd {
    position:relative;
    display:flex;
    align-items:center;
    justify-content:space-between;
    padding:12px 16px;
    background:rgba(255,255,255,0.85);
    backdrop-filter:blur(28px);
    -webkit-backdrop-filter:blur(28px);
    border-top-left-radius:16px;
    border-top-right-radius:16px;
    margin: -20px -20px 20px -20px;
    min-height:56px;
  }

  .done-plus-header .hd-title {
    font-weight:600;
    font-size:17px;
    color:#1d1d1f;
    text-align:center;
    flex:1;
    position:absolute;
    left:50%;
    transform:translateX(-50%);
    pointer-events:none;
  }

  .done-plus-header .hd-btn {
    width:44px;
    height:44px;
    border-radius:50%;
    display:flex;
    align-items:center;
    justify-content:center;
    cursor:pointer;
    transition:all 0.15s ease;
    border:none;
    z-index:2;
    flex-shrink:0;
  }

  .done-plus-header .hd-btn:active {
    transform:scale(0.96);
    opacity:0.8;
  }

  .done-plus-header .hd-close {
    background:#fff;
    box-shadow:0 2px 8px rgba(0,0,0,0.1);
    border:1px solid rgba(0,0,0,0.08);
    font-size:18px;
    color:#8e8e93;
    font-weight:400;
  }

  .done-plus-header .hd-close:hover {
    background:rgba(0,0,0,0.05);
    box-shadow:0 4px 12px rgba(0,0,0,0.15);
  }

  .done-plus-header .hd-done {
    background:var(--red);
    box-shadow:inset 0 1px 0 rgba(255,255,255,.25),
               0 10px 18px rgba(255,59,48,.35);
  }

  .done-plus-header .hd-done::before {
    content:"";
    width:9px;height:18px;
    border-right:3px solid #fff;
    border-bottom:3px solid #fff;
    transform:rotate(45deg);
    filter:drop-shadow(0 1px 1px rgba(0,0,0,.25));
  }

  .done-plus-section {
    margin-bottom: 20px;
  }

  .done-plus-label {
    font-size: 16px;
    font-weight: 600;
    color: #1d1d1f;
    margin-bottom: 8px;
    display: block;
  }

  .done-plus-textarea {
    width: 100%;
    min-height: 100px;
    padding: 12px;
    border: 1px solid rgba(0, 122, 255, 0.2);
    border-radius: 10px;
    font-size: 16px;
    font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    resize: vertical;
    background: rgba(255, 255, 255, 0.8);
    transition: all 0.2s ease;
  }

  .done-plus-textarea:focus {
    outline: none;
    border-color: var(--blue);
    background: white;
  }

  /* Done+分离式布局样式 - iOS风格优化 */
  .done-plus-row {
    display: flex;
    align-items: center;            /* 垂直居中对齐 */
    gap: 12px;                     /* iOS标准间距 */
    margin-bottom: 20px;           /* 增加间距，更符合iOS规范 */
    position: relative;
  }

  /* 第一个区域增加特殊间距 */
  .done-plus-section:first-child .done-plus-row {
    margin-bottom: 24px;
    margin-top: 8px;               /* 顶部增加一些间距 */
  }

  .done-plus-row:last-child {
    margin-bottom: 0;
  }

  /* 左侧独立图标区域 - iOS风格优化 */
  .done-plus-icon-box {
    flex-shrink: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 44px;              /* iOS标准44px触控尺寸 */
    height: 44px;
    padding: 0;
    border: none;             /* 移除边框，使用更简洁的设计 */
    border-radius: 12px;      /* iOS风格圆角 */
    background: rgba(242, 242, 247, 0.8);  /* iOS系统背景色 */
    transition: all 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);  /* iOS标准缓动 */
    position: relative;
    overflow: hidden;
  }

  /* iOS风格激活状态 */
  .done-plus-row:focus-within .done-plus-icon-box {
    background: rgba(0, 122, 255, 0.08);
    transform: scale(1.02);
  }

  /* 添加细微的阴影效果 */
  .done-plus-icon-box::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 100%);
    pointer-events: none;
  }

  /* 右侧独立功能区域 - iOS风格优化 */
  .done-plus-input-box {
    flex: 1;
    min-width: 0;
    padding: 14px 16px;         /* iOS标准内边距 */
    border: 0.5px solid rgba(0, 0, 0, 0.1);  /* 细边框 */
    border-radius: 12px;        /* iOS风格圆角 */
    background: rgba(255, 255, 255, 0.95);   /* 更透明的背景 */
    transition: all 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    backdrop-filter: blur(10px); /* iOS毛玻璃效果 */
    -webkit-backdrop-filter: blur(10px);
    position: relative;
    overflow: hidden;
  }

  /* iOS风格激活状态 */
  .done-plus-row:focus-within .done-plus-input-box {
    border-color: rgba(0, 122, 255, 0.3);
    background: rgba(255, 255, 255, 1);
    box-shadow: 0 0 0 2px rgba(0, 122, 255, 0.15),
                0 2px 8px rgba(0, 0, 0, 0.04);  /* iOS标准阴影 */
    transform: translateY(-1px); /* 微妙的上移效果 */
  }

  /* 添加内部光泽效果 */
  .done-plus-input-box::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 1px;
    background: linear-gradient(90deg,
      rgba(255,255,255,0.8) 0%,
      rgba(255,255,255,0.4) 50%,
      rgba(255,255,255,0.8) 100%);
    pointer-events: none;
  }

  .done-plus-area-icon {
    font-size: 20px;
    opacity: 0.8;
    user-select: none;
    display: flex;
    align-items: center;
    justify-content: center;
    position: relative;
  }

  /* 区域1：任务勾选框 + Done+角标 - iOS风格优化 */
  .done-plus-area-icon.task-with-doneplus {
    width: 24px;
    height: 24px;
    position: relative;
  }

  .done-plus-area-icon.task-with-doneplus .icon-checkbox {
    width: 20px;
    height: 20px;
    border: 2px solid rgba(120, 120, 128, 0.2);  /* iOS系统灰色 */
    border-radius: 50%;
    background: rgba(255, 255, 255, 0.8);
    box-sizing: border-box;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    position: relative;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);  /* iOS标准内阴影 */
  }

  /* 激活状态 */
  .done-plus-row:focus-within .done-plus-area-icon.task-with-doneplus .icon-checkbox {
    border-color: var(--blue);
    background: rgba(0, 122, 255, 0.05);
    transform: scale(1.05);
  }

  /* iOS风格Done+角标 */
  .done-plus-area-icon.task-with-doneplus .icon-doneplus-badge {
    position: absolute;
    top: -6px;
    right: -6px;
    background: linear-gradient(135deg, #007aff 0%, #5856d6 100%);  /* iOS蓝色渐变 */
    color: white;
    border-radius: 50%;
    width: 18px;
    height: 18px;
    font-size: 11px;
    font-weight: 600;            /* iOS标准字重 */
    display: flex;
    align-items: center;
    justify-content: center;
    z-index: 10;
    box-shadow: 0 2px 4px rgba(0, 122, 255, 0.3),
                0 0 0 1px rgba(255, 255, 255, 0.3);  /* iOS标准阴影 */
    transition: all 0.15s cubic-bezier(0.25, 0.46, 0.45, 0.94);
  }

  /* 激活时角标效果 */
  .done-plus-row:focus-within .done-plus-area-icon.task-with-doneplus .icon-doneplus-badge {
    transform: scale(1.1);
    box-shadow: 0 3px 6px rgba(0, 122, 255, 0.4),
                0 0 0 2px rgba(255, 255, 255, 0.5);
  }

  /* 区域2：占位符图标 */
  .done-plus-area-icon.task-placeholder {
    width: 24px;
    height: 24px;
  }

  .done-plus-area-icon.task-placeholder .icon-checkbox {
    width: 18px;
    height: 18px;
    border: 2px dashed #bbb;
    border-radius: 50%;
    background: transparent;
    box-sizing: border-box;
  }

  .done-plus-area-icon.task-placeholder .icon-checkbox.placeholder {
    border-style: dashed;
    border-color: #bbb;
  }

  /* 区域3：笔记图标 */
  .done-plus-area-icon.notes-icon {
    font-size: 20px;
    opacity: 0.8;
  }

  /* 右侧内容区域 */
  .done-plus-content-area {
    flex: 1;
    min-width: 0;
  }

  /* 输入框样式 - iOS风格优化 */
  .done-plus-task-text-input,
  .done-plus-task-input {
    width: 100%;
    padding: 0;
    border: none;
    background: transparent;
    font-size: 16px;              /* iOS标准字体大小 */
    font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    font-weight: 400;             /* iOS标准字重 */
    outline: none;
    color: #1d1d1f;              /* iOS标准文字颜色 */
    line-height: 1.4;            /* iOS标准行高 */
    -webkit-appearance: none;    /* 移除默认样式 */
    border-radius: 0;
  }

  /* iOS风格占位符 */
  .done-plus-task-text-input::placeholder,
  .done-plus-task-input::placeholder {
    color: #8e8e93;              /* iOS系统占位符颜色 */
    opacity: 0.8;
    font-weight: 400;
    line-height: 1.4;
  }

  
  /* 区域1：统一的图标+输入框下划线样式 */
  .done-plus-unified-input {
    border-bottom: 1px solid rgba(0, 0, 0, 0.1);
    padding-bottom: 4px;
    transition: border-color 0.15s ease;
  }

  /* 区域1统一输入框聚焦状态 */
  .done-plus-unified-input:focus-within {
    border-bottom-color: var(--blue);
  }

  /* 区域1Done+图标与输入框的对齐优化 */
  .done-plus-unified-input {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  /* 区域1和2输入框样式调整 - 移除底部边框 */
  .done-plus-unified-input .done-plus-task-text-input,
  .done-plus-unified-input .done-plus-task-input {
    border-bottom: none;
    padding-bottom: 0;
    flex: 1;
  }

  /* 聚焦时的文字颜色 */
  .done-plus-task-text-input:focus,
  .done-plus-task-input:focus {
    color: #000;
    font-weight: 500;            /* 聚焦时稍微加粗 */
  }

  
  /* 禁用自动纠正和首字母大写 */
  .done-plus-task-text-input,
  .done-plus-task-input {
    autocorrect: off;
    autocapitalize: none;
    spellcheck: false;
  }

  /* 文本框样式 */
  .done-plus-textarea {
    width: 100%;
    min-height: 80px;
    padding: 0;
    border: none;
    background: transparent;
    font-size: 16px;
    font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    resize: vertical;
    outline: none;
    color: #1d1d1f;
    line-height: 1.4;
  }

  .done-plus-textarea::placeholder {
    color: #8e8e93;
    opacity: 0.7;
  }

  .done-plus-note-actions {
    margin-top: 12px;
    text-align: right;
  }

  .done-plus-save-note {
    background: rgba(0, 122, 255, 0.1);
    color: var(--blue);
    border: 1px solid var(--blue);
    padding: 8px 16px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .done-plus-save-note:hover {
    background: rgba(0, 122, 255, 0.2);
  }

  .done-plus-actions {
    display: flex !important;
    gap: 12px;
    margin-top: 24px;
    padding-bottom: 20px;
    border: 2px solid green !important; /* 调试边框 */
    position: relative !important;
    z-index: 1002 !important;
  }

  .done-plus-btn {
    flex: 1;
    padding: 12px 24px;
    border-radius: 12px;
    font-size: 16px;
    font-weight: 600;
    border: none;
    cursor: pointer;
    transition: all 0.2s ease;
  }

  .done-plus-cancel {
    background: rgba(142, 142, 147, 0.12);
    color: #8e8e93;
  }

  .done-plus-cancel:hover {
    background: rgba(142, 142, 147, 0.2);
  }

  .done-plus-confirm {
    background: var(--blue);
    color: white;
    border: 2px solid red !important; /* 调试边框 */
    position: relative !important;
    z-index: 1003 !important;
  }

  .done-plus-confirm:hover {
    background: #0051d5;
  }

  /* ===== 任务编辑表单样式 ===== */
  .task-edit-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    z-index: 1000;
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 16px;
  }

  .task-edit-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.4);
    backdrop-filter: blur(8px);
  }

  .task-edit-card {
    position: relative;
    max-width: 760px;
    width: 100%;
    max-height: 90vh;
    background: var(--card, #ffffff);
    border-radius: 18px;
    border: 1px solid var(--line, #e8ecf2);
    box-shadow: 0 8px 28px rgba(0, 0, 0, 0.15);
    overflow: hidden;
    z-index: 1001;
  }

  .task-edit-header {
    display: flex;
    align-items: center;
    gap: 12px;
    padding: 14px 16px;
    border-bottom: 1px solid var(--line, #e8ecf2);
    background: var(--card, #ffffff);
  }

  .task-edit-checkbox {
    width: 26px;
    height: 26px;
    border-radius: 50%;
    border: 1.5px solid var(--line, #e8ecf2);
    background: transparent;
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: pointer;
    transition: all 0.18s ease-in-out;
    font-size: 0;
  }

  .task-edit-checkbox[aria-checked="true"] {
    background: var(--ok, #34c759);
    border-color: var(--ok, #34c759);
    color: #fff;
  }

  .task-edit-checkbox[aria-checked="true"]::after {
    content: "✓";
    font-size: 14px;
    font-weight: bold;
  }

  .task-edit-checkbox.template {
    background: var(--blue, #0a84ff);
    border-color: var(--blue, #0a84ff);
    cursor: not-allowed;
  }

  .task-edit-checkbox.template::after {
    content: "★";
    color: #e4bd37;
    font-size: 14px;
  }

  .task-edit-title {
    flex: 1;
    height: 42px;
    border-radius: 12px;
    border: 1px solid var(--line, #e8ecf2);
    padding: 0 12px;
    font-weight: 600;
    font-size: 16px;
    background: transparent;
    color: var(--text, #0b1220);
    transition: border-color 0.18s ease, box-shadow 0.18s ease;
  }

  .task-edit-title:focus {
    outline: none;
    border-color: var(--accent, #0a84ff);
    box-shadow: 0 0 0 4px rgba(10, 132, 255, 0.1);
  }

  .task-edit-close {
    width: 32px;
    height: 32px;
    border: none;
    background: transparent;
    cursor: pointer;
    border-radius: 8px;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 18px;
    color: var(--text-muted, #6b7280);
    transition: background-color 0.15s ease;
  }

  .task-edit-close:hover {
    background: rgba(0, 0, 0, 0.04);
  }

  .task-edit-section {
    padding: 0;
  }

  .task-edit-row {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    min-height: 44px;
    padding: 12px 16px;
    position: relative;
  }

  .task-edit-row::after {
    content: "";
    position: absolute;
    left: 16px;
    right: 16px;
    bottom: 0;
    height: 1px;
    background: var(--line, #e8ecf2);
  }

  .task-edit-row:last-of-type::after {
    display: none;
  }

  /* 开关样式 */
  .task-edit-switch-wrapper {
    display: flex;
    align-items: center;
    gap: 12px;
  }

  .task-edit-switch {
    position: relative;
    display: inline-block;
    width: 48px;
    height: 28px;
  }

  .task-edit-switch input {
    opacity: 0;
    width: 0;
    height: 0;
  }

  .task-edit-slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background-color: #ccc;
    transition: 0.3s;
    border-radius: 28px;
  }

  .task-edit-slider:before {
    position: absolute;
    content: "";
    height: 22px;
    width: 22px;
    left: 3px;
    bottom: 3px;
    background-color: white;
    transition: 0.3s;
    border-radius: 50%;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.3);
  }

  .task-edit-switch input:checked + .task-edit-slider {
    background-color: var(--blue, #0a84ff);
  }

  .task-edit-switch input:checked + .task-edit-slider:before {
    transform: translateX(20px);
  }

  .task-edit-switch-label {
    font-size: 15px;
    font-weight: 600;
    color: var(--text, #0b1220);
  }

  /* 标签带样式 */
  .task-edit-belt {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 0;
    flex: 1;
    row-gap: 8px;
  }

  .task-edit-ctrl {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 6px 12px;
    font-size: 15px;
    font-weight: 600;
    line-height: 1.3;
    color: var(--text, #0b1220);
    border-left: 1px solid var(--line, #e8ecf2);
    background: none;
    border-radius: 10px;
    min-height: 36px;
    transition: background 0.15s ease, color 0.15s ease, box-shadow 0.18s ease;
    cursor: pointer;
    user-select: none;
    border-top: none;
    border-right: none;
    border-bottom: none;
  }

  .task-edit-belt > .task-edit-ctrl:first-child {
    border-left: none;
  }

  .task-edit-ctrl:hover {
    background: rgba(10, 132, 255, 0.06);
  }

  .task-edit-ctrl:active {
    background: rgba(10, 132, 255, 0.1);
    color: var(--accent, #0a84ff);
  }

  /* 文本标签按钮特殊样式 */
  .task-edit-ctrl.text-tag-btn {
    background: #F5F5F7;
    border: 1px solid #E0E0E5;
    border-radius: 8px;
    font-weight: 500;
    padding: 8px 16px;
    position: relative;
    margin-right: 8px;
  }

  .task-edit-ctrl.text-tag-btn:hover {
    background: #E8E8ED;
    border-color: #D0D0D5;
  }

  .task-edit-ctrl.text-tag-btn:active {
    background: #DDD;
    color: var(--text, #0b1220);
  }

  /* 有内容时的激活状态 */
  .task-edit-ctrl.text-tag-btn.has-content {
    background: #E3F2FF;
    border-color: #C7E0FF;
    color: var(--accent, #0a84ff);
  }

  .task-edit-ctrl.text-tag-btn.has-content:hover {
    background: #D6E9FF;
  }

  /* 数字角标 */
  .task-edit-ctrl.text-tag-btn .badge {
    margin-left: 4px;
    background: var(--accent, #0a84ff);
    color: white;
    font-size: 11px;
    font-weight: 600;
    min-width: 16px;
    height: 16px;
    border-radius: 8px;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 0 5px;
  }

  /* 已添加标签容器 */
  .task-edit-tags-container {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    padding: 0;
    min-height: 0;
  }

  .task-edit-tags-container:empty {
    display: none;
  }

  /* 调整已添加标签的样式 */
  .text-summary-chip,
  .text-editor-chip {
    margin: 0;
  }

  /* 汇总标签悬停效果 */
  .text-summary-chip {
    transition: all 0.2s ease;
    position: relative;
  }

  .text-summary-chip:hover {
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    cursor: pointer;
    transform: translateY(-1px);
  }

  /* 不同类型标签的背景色 */
  .text-summary-chip[data-type="goal"] {
    background: #E3F2FF;
    border-color: #B3D8FF;
  }

  .text-summary-chip[data-type="deliverable"] {
    background: #E8F5E9;
    border-color: #C3E6C5;
  }

  .text-summary-chip[data-type="contact"] {
    background: #FFF3E0;
    border-color: #FFD6A6;
  }

  .text-summary-chip[data-type="place"] {
    background: #F3E5F5;
    border-color: #E1BEE7;
  }

  .text-summary-chip[data-type="note"] {
    background: #F5F5F7;
    border-color: #E0E0E5;
  }

  /* 悬停时稍微加深背景 */
  .text-summary-chip[data-type="goal"]:hover {
    background: #D1E7FF;
  }

  .text-summary-chip[data-type="deliverable"]:hover {
    background: #DCEDC8;
  }

  .text-summary-chip[data-type="contact"]:hover {
    background: #FFE8C8;
  }

  .text-summary-chip[data-type="place"]:hover {
    background: #E8D5EA;
  }

  .text-summary-chip[data-type="note"]:hover {
    background: #E8E8ED;
  }

  /* 添加编辑提示 - 移除，因为已有title提示 */
  /* 移除编辑图标，避免与类型图标冲突 */

  /* 操作按钮 */
  .task-edit-actions {
    display: flex;
    gap: 12px;
    padding: 16px;
    border-top: 1px solid var(--line, #e8ecf2);
    background: var(--bg, #f6f7f9);
  }

  .task-edit-action-btn {
    padding: 10px 20px;
    border: 1px solid var(--accent, #0a84ff);
    background: transparent;
    color: var(--accent, #0a84ff);
    border-radius: 8px;
    font-size: 15px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s ease;
  }

  .task-edit-action-btn:hover {
    background: rgba(10, 132, 255, 0.06);
  }

  .task-edit-confirm-btn {
    flex: 1;
    padding: 10px 20px;
    border: none;
    background: var(--accent, #0a84ff);
    color: white;
    border-radius: 8px;
    font-size: 15px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.15s ease;
  }

  .task-edit-confirm-btn:hover {
    background: #0056b3;
  }

  .task-edit-confirm-btn:active {
    transform: translateY(1px);
  }

  /* 周期编辑器样式 */
  .task-repeat-editor {
    display: none;
    padding: 12px 16px;
    border-top: 1px solid var(--line, #e8ecf2);
    background: var(--bg, #f6f7f9);
  }

  .task-repeat-editor.show {
    display: block;
  }

  .repeat-mode-select {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid var(--line, #e8ecf2);
    border-radius: 8px;
    background: var(--card, #ffffff);
    font-size: 15px;
    margin-bottom: 12px;
  }

  /* iOS Safari选择器option颜色修复 */
  .repeat-mode-select option {
    color: #1d1d1f !important;
    -webkit-text-fill-color: #1d1d1f !important;
  }

  .repeat-params {
    display: flex;
    flex-wrap: wrap;
    align-items: center;
    gap: 8px;
    margin-bottom: 12px;
  }

  .repeat-params input,
  .repeat-params select {
    padding: 6px 8px;
    border: 1px solid var(--line, #e8ecf2);
    border-radius: 6px;
    background: var(--card, #ffffff);
    font-size: 14px;
  }

  .repeat-params input[type="number"] {
    width: 60px;
  }

  .repeat-params input[type="time"] {
    width: 120px;
  }

  .repeat-params input[type="date"] {
    width: 140px;
  }

  .repeat-day-buttons {
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
  }

  .repeat-day-btn {
    min-width: 32px;
    height: 32px;
    border: 1px solid var(--line, #e8ecf2);
    background: var(--card, #ffffff);
    border-radius: 6px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.15s ease;
  }

  .repeat-day-btn.selected {
    background: rgba(10, 132, 255, 0.12);
    border-color: var(--accent, #0a84ff);
    color: var(--accent, #0a84ff);
  }

  .repeat-mode-switch {
    display: flex;
    gap: 8px;
    margin-bottom: 8px;
  }

  .repeat-mode-btn {
    padding: 6px 12px;
    border: 1px solid var(--line, #e8ecf2);
    background: var(--card, #ffffff);
    border-radius: 6px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.15s ease;
  }

  .repeat-mode-btn.selected {
    background: var(--accent, #0a84ff);
    border-color: var(--accent, #0a84ff);
    color: white;
  }

  .repeat-actions {
    display: flex;
    gap: 8px;
    justify-content: flex-end;
    margin-top: 12px;
  }

  .repeat-btn {
    padding: 8px 16px;
    border: 1px solid var(--accent, #0a84ff);
    background: transparent;
    color: var(--accent, #0a84ff);
    border-radius: 6px;
    font-size: 14px;
    cursor: pointer;
    transition: all 0.15s ease;
  }

  .repeat-btn:hover {
    background: rgba(10, 132, 255, 0.06);
  }

  .repeat-btn.primary {
    background: var(--accent, #0a84ff);
    color: white;
  }

  .repeat-btn.primary:hover {
    background: #0056b3;
  }

  .task-input{
    min-width:0;
    background:transparent;
    font-size:13px;
    border:none;
    outline:none;
    color: var(--text);
    white-space:nowrap;
    overflow:hidden;
    text-overflow:ellipsis;
    display:flex;
    align-items:center;
    height:100%;
    line-height:var(--rule-gap);
    -webkit-user-select:text;
    user-select:text;
  }
  .task-input.expanded{
    white-space:normal;
    background: var(--card, #ffffff) !important;
    color: var(--text, #0b1220) !important;
    border-color: var(--line, #ddd) !important;
    border-width: 1px !important;
    border-style: solid !important;
    border-radius: 6px !important;
    padding: 4px !important;
    line-height: 1.4 !important;
    height: auto !important;
    outline: none !important;
    box-shadow: none !important;
    display: block !important;
  }
  .task-input[contenteditable="true"]::before{ content: ""; }  /* 去掉"输入待办…" */
  .task-handle{font-size:22px;color:#999;cursor:pointer;user-select:none;display:flex;align-items:center;justify-content:center;height:100%;padding:0 4px;white-space:nowrap;min-width:44px}
  /* 折叠图标样式 */
  .task-collapse{font-size:14px;color:#999;cursor:pointer;user-select:none;padding:0 8px;transition:transform 0.2s;display:flex;align-items:center;min-width:44px;justify-content:center}
  .task-collapse.collapsed{}

  /* 折叠图标SVG样式 */
  .collapse-icon-svg {
    width: 16px;
    height: 16px;
    color: currentColor;
    transition: all 0.2s ease;
  }

  .task-collapse:hover .collapse-icon-svg {
    color: #666;
  }

  /* ===== 内联编辑区域样式 ===== */
  /* 内联编辑容器 - 优化对齐，支持换行 */
  .inline-edit-container {
    display: none;
    margin-top: 8px;       /* 统一顶部间距 */
    padding-left: 28px;
    padding-right: 16px;
    align-items: flex-start; /* 改为顶部对齐，适应换行布局 */
    flex-wrap: wrap;
    gap: 8px;             /* 统一所有元素间距为8px */
    box-sizing: border-box;
    line-height: 28px;
    width: 100%;
    overflow: hidden;
  }
  .inline-edit-container.active {
    display: flex;
    flex-direction: column; /* 垂直排列，按钮组按行分组 */
  }

  /* 确保所有直接子元素对齐 */
  .inline-edit-container > * {
    margin-top: 0;         /* 移除顶部margin */
    margin-bottom: 0;      /* 移除底部margin */
    vertical-align: middle; /* 垂直对齐 */
  }

  /* 开关按钮样式 - 统一高度 */
  .inline-switch-button {
    display: inline-flex;
    align-items: center;
    padding: 0 10px;      /* 移除上下padding */
    font-size: 13px;
    background: #f0f0f0;
    border: 1px solid transparent;
    border-radius: 6px;
    gap: 6px;
    height: 28px;
    line-height: 28px;
    box-sizing: border-box;
    vertical-align: middle;  /* 改为 middle 对齐，与其他元素保持一致 */
    margin: 2px 4px 2px 0;  /* 添加与 inline-button-group 相同的 margin */
  }
  .inline-switch {
    position: relative;
    display: inline-block;
    width: 36px;
    height: 20px;
  }
  .inline-switch input {
    opacity: 0;
    width: 0;
    height: 0;
  }
  .inline-slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: #ccc;
    transition: .3s;
    border-radius: 20px;
  }
  .inline-slider:before {
    position: absolute;
    content: "";
    height: 14px;
    width: 14px;
    left: 3px;
    bottom: 3px;
    background: #fff;
    transition: .3s;
    border-radius: 50%;
  }
  .inline-switch input:checked + .inline-slider {
    background: #007aff;
  }
  .inline-switch input:checked + .inline-slider:before {
    transform: translateX(16px);
  }

  /* 按钮组样式 - 支持换行 */
  .inline-button-group {
    display: flex;
    flex-wrap: wrap;       /* 允许换行，解决水平溢出问题 */
    align-items: center;
    gap: 6px;              /* 调整间距以适应换行 */
    margin: 0;             /* 移除外边距，由容器gap控制 */
    max-width: 100%;       /* 确保不超出容器宽度 */
    vertical-align: middle;
    max-width: 100%;
  }
  .inline-button {
    display: inline-flex;
    align-items: center;
    justify-content: center;  /* 水平居中 */
    padding: 0 10px 0 14px;    /* 移除上下padding，依靠height定高 */
    font-size: 13px;
    font-weight: 500;
    line-height: 28px;         /* 行高与高度一致 */
    color: #333;
    background: #f0f0f0;
    border: 1px solid transparent;  /* 添加透明边框占位 */
    border-radius: 6px;
    cursor: pointer;
    position: relative;
    height: 28px;
    box-sizing: border-box;    /* 包含边框在高度内 */
    vertical-align: bottom;    /* 底部对齐 */
  }
  .inline-button::before {
    content: '';
    width: 4px;
    height: 60%;
    background: currentColor;
    position: absolute;
    left: 6px;
    top: 20%;
    border-radius: 2px;
  }
  .inline-count {
    font-size: 11px;
    margin-left: 4px;
    color: #666;
  }

  /* 标签样式 - 统一高度和对齐，支持换行布局 */
  .inline-tag {
    display: inline-flex;   /* 使用inline-flex保持一致 */
    align-items: center;
    font-size: 13px;
    border: 1px solid #ccc;
    border-radius: 6px;
    background: #f9f9f9;
    margin: 0;              /* 移除外边距，由容器gap控制 */
    height: 28px;
    box-sizing: border-box;
    flex-shrink: 0;
    max-width: calc(100vw - 40px); /* 限制最大宽度，避免超出屏幕 */
    min-width: 60px;        /* 设置最小宽度，保持可用性 */
  }
  /* 内联编辑区域的SVG图标样式 */
  .inline-icon-svg {
    width: 16px;
    height: 16px;
    color: currentColor;
    margin-right: 4px;
    flex-shrink: 0;
  }

  .inline-tag input {
    border: none;
    background: transparent;
    padding: 0 6px;     /* 调整padding */
    font-size: 13px;
    line-height: 26px;  /* 减去边框后的行高 */
    min-width: 40px;    /* 增加最小宽度，提升用户体验 */
    max-width: min(120px, calc(100vw - 80px)); /* 响应式最大宽度 */
    outline: none;
    height: 26px;       /* 减去边框的高度 */
    vertical-align: middle;
    box-sizing: border-box;
    flex: 1;            /* 让输入框占用剩余空间 */
  }
  .inline-tag .close {
    background: transparent;
    border: none;
    font-size: 16px;
    color: #666;
    cursor: pointer;
    margin-left: 2px;
    padding: 0 6px;
    line-height: 1;
    height: 26px;
    display: flex;           /* 确保删除按钮正确显示 */
    align-items: center;
    flex-shrink: 0;          /* 防止删除按钮被压缩 */
    min-width: 24px;         /* 确保删除按钮有最小宽度 */
  }

  /* 行内输入框样式 - 精确对齐28px高度 */
  .inline-input {
    display: none;
    margin: 0 !important;   /* 移除所有外边距，使用容器gap */
    font-size: 13px;
    font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    height: 28px !important;
    line-height: 28px;
    padding: 0 8px !important;
    border: 1px solid #e0e0e0;
    border-radius: 6px;
    background: #fff;
    vertical-align: middle !important;  /* 居中对齐 */
    box-sizing: border-box !important;
  }

  /* 覆盖所有类型输入框的样式 */
  .inline-input[type="datetime-local"],
  .inline-input[type="number"],
  .inline-input[type="time"],
  .inline-input[type="date"],
  .inline-input.time-input,
  .inline-input.duration-input,
  .inline-input.cycle-select,
  .inline-input.duration-unit,
  select.inline-input {
    display: none;
    margin: 0 !important;   /* 移除所有外边距，使用容器gap */
    font-size: 13px;
    font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    height: 28px !important;
    line-height: 28px;
    padding: 0 8px !important;
    border: 1px solid #e0e0e0;
    border-radius: 6px;
    background: #fff;
    vertical-align: middle !important;  /* 居中对齐 */
    box-sizing: border-box !important;
    -webkit-appearance: none;
    appearance: none;
  }

  /* iOS Safari选择器option颜色修复 - 用时单位和周期选择器 */
  .duration-unit option,
  .cycle-select option {
    color: #666 !important;
    -webkit-text-fill-color: #666 !important;
  }

  /* 全局option颜色修复 - 覆盖所有可能的样式继承 */
  select option {
    color: #666 !important;
    -webkit-text-fill-color: #666 !important;
    background: #ffffff !important;
  }

  /* 专门针对iPad和iOS Safari的全局修复 */
  @supports (-webkit-touch-callout: none) {
    select option {
      color: #666 !important;
      -webkit-text-fill-color: #666 !important;
      background-color: #ffffff !important;
    }
  }

  /* 终极强制修复 - 覆盖所有可能的蓝色继承 */
  select,
  select option,
  .duration-unit,
  .duration-unit option,
  .cycle-select,
  .cycle-select option,
  .repeat-mode-select,
  .repeat-mode-select option {
    color: #666 !important;
    -webkit-text-fill-color: #666 !important;
    background: #ffffff !important;
  }

  /* iOS Safari特殊强制 */
  @media screen and (-webkit-min-device-pixel-ratio: 2) {
    select option,
    .duration-unit option,
    .cycle-select option,
    .repeat-mode-select option {
      color: #000000 !important;
      -webkit-text-fill-color: #000000 !important;
      background: #ffffff !important;
    }
  }

  /* iOS Safari时间选择器颜色修复 */
  .inline-input[type="datetime-local"],
  .inline-input[type="number"],
  .inline-input[type="time"],
  .inline-input.time-input,
  .inline-input.duration-input {
    /* 强制设置文字颜色，覆盖iOS默认样式 */
    color: #666 !important;
    -webkit-text-fill-color: #666 !important;

    /* iOS Safari特定的颜色重置 */
    -webkit-calendar-picker-color: #666 !important;
    -webkit-date-picker-color: #666 !important;
    -webkit-time-picker-color: #666 !important;

    /* 确保背景色不被覆盖 */
    background: #ffffff !important;
  }

  /* 确保select有下拉箭头 */
  select.inline-input {
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3e%3cpolyline points='6 9 12 15 18 9'%3e%3c/polyline%3e%3c/svg%3e");
    background-repeat: no-repeat;
    background-position: right 8px center;
    background-size: 16px;
    padding-right: 32px !important;
  }

  /* 周末选择器 - 优化对齐 */
  .inline-weekdays {
    display: inline-flex;  /* 改为inline-flex */
    align-items: center;   /* 垂直居中 */
    gap: 4px;
    margin-left: 10px;
    height: 28px;          /* 统一高度 */
    vertical-align: bottom;
  }
  .inline-weekdays label {
    display: inline-flex;
    align-items: center;
    font-size: 12px;
    height: 24px;
    padding: 0 4px;
    cursor: pointer;
  }
  .inline-weekdays input[type="checkbox"] {
    margin-right: 2px;
    vertical-align: middle;
  }

  /* 预览区域样式 */
  .inline-summary {
    display: inline-block;
    font-size: 13px;
    color: #444;
    background: #f0f0f0;
    padding: 4px 10px;
    border-radius: 10px;
    margin-left: 28px;
    margin-top: -4px;
    margin-bottom: 6px;
  }

  /* 全局内联元素对齐规则 */
  .inline-edit-container.active .inline-button-group,
  .inline-edit-container.active .inline-switch-button,
  .inline-edit-container.active .inline-input,
  .inline-edit-container.active .inline-weekdays,
  .inline-edit-container.active .inline-tag {
    display: inline-flex;
    vertical-align: middle;  /* 统一垂直居中 */
    margin: 0;              /* 移除所有外边距，使用容器gap */
  }

  /* 确保按钮组内部元素不会有额外间距 */
  .inline-button-group .inline-button,
  .inline-button-group .inline-input,
  .inline-button-group .inline-tag {
    margin: 0;              /* 移除所有内部元素的margin */
  }

  /* 不同类型标签的颜色 */
  .目标 { background: #FFE5E5; color: #D43A3A; }
  .产出物 { background: #FFF6CC; color: #C9A103; }
  .地点 { background: #D6F8D6; color: #3C9F3C; }
  .联系人 { background: #ECE1FF; color: #7E57C2; }
  .备注 { background: #E0F0FF; color: #2980b9; }


  /* 底部滑动同步（默认隐藏，滚到最底部显示） */
  .sync-bar{
    position:fixed; left:0; right:0; bottom:0; height:56px; z-index:20;
    background:linear-gradient(180deg, rgba(255,255,255,.6), #fff);
    display:flex; align-items:center; justify-content:center;
    padding:8px 16px; box-shadow:0 -6px 20px rgba(0,0,0,.06);
    transform: translateY(100%);
    pointer-events: none;
    transition: transform .25s ease;
  }
  .sync-bar.show{
    transform: translateY(0);
    pointer-events: auto;
  }
  /* 滑块阶段样式 */
  .sync-track{ position:relative; width:100%; max-width:480px; height:40px; background:#f6f7f8; border:1px solid #e5e5e7; border-radius:999px; overflow:hidden; }
  .sync-label{ position:absolute; left:0; right:0; top:0; bottom:0; display:flex; align-items:center; justify-content:center; font-size:12px; color:#8e8e93; user-select:none; pointer-events:none; }
  .sync-thumb{ position:absolute; left:2px; top:2px; width:80px; height:36px; background:#007aff; color:#fff; border-radius:999px; display:flex; align-items:center; justify-content:center; font-weight:600; font-size:12px; user-select:none; touch-action:none; cursor:grab; box-shadow:0 2px 6px rgba(0,122,255,.3); transition:left .15s ease; }
  .sync-thumb:active{cursor:grabbing}

  /* 按钮阶段样式 */
  .sync-button-stage{
    display: none;
    width:100%; max-width:480px;
  }
  .sync-button-stage.show{display: block;}

  .sync-submit-btn{
    width:100%; height:40px; border:none; border-radius:999px;
    background:linear-gradient(90deg, #007AFF, #0056CC);
    color:#fff; font-size:14px; font-weight:600; cursor:pointer;
    box-shadow:0 2px 8px rgba(0,122,255,.3);
    transition:all .2s ease;
  }
  .sync-submit-btn:active{
    transform:translateY(1px);
    box-shadow:0 1px 4px rgba(0,122,255,.2);
  }
  .sync-submit-btn:disabled{
    background:#999; cursor:not-allowed; opacity:0.6;
  }

  .submit-btn{display:none}
  .dragging-shadow{background:#fff!important;opacity:1!important;box-shadow:0 5px 15px rgba(0,0,0,0.15)!important;transform:scale(1.02)!important;border:1px solid #007aff!important;max-width:calc(100vw - 40px)!important;overflow:hidden!important;box-sizing:border-box!important}
  .sortable-chosen{opacity:0.5!important;background:#f0f0f0!important}
  .sortable-drag{opacity:0!important;background:#f5f5f5!important;max-width:calc(100vw - 40px)!important;overflow:hidden!important}
  /* 新增拖拽位置提示样式 */
  .valid-drop{border:2px solid #34c759!important;box-shadow:0 5px 20px rgba(52,199,89,0.3)!important}
  .invalid-drop{border:2px solid #ff3b30!important;box-shadow:0 5px 20px rgba(255,59,48,0.3)!important;opacity:0.8!important}

  /* 模板任务拖拽提示样式 */
  .template-task-drag-hint {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.5);
    backdrop-filter: saturate(180%) blur(20px);
    -webkit-backdrop-filter: saturate(180%) blur(20px);
    color: #ffffff;
    font-size: 15px;
    font-weight: 600;
    padding: 8px 16px;
    border-radius: 18px;
    z-index: 99999;
    pointer-events: none;
    white-space: nowrap;
    animation: iosBounceAndGlow 2s ease-in-out infinite;
    font-family: -apple-system, BlinkMacSystemFont, sans-serif;
    text-align: center;
    line-height: 1.3;
    border: 0.5px solid rgba(255, 255, 255, 0.2);
    opacity: 1;
    min-width: 160px;
    letter-spacing: -0.4px;
  }

  @keyframes iosBounceAndGlow {
    0% {
      transform: translate(-50%, -50%) scale(0.9);
      opacity: 0;
    }
    20% {
      transform: translate(-50%, -50%) scale(1.05);
      opacity: 1;
    }
    40% {
      transform: translate(-50%, -50%) scale(0.98);
      opacity: 1;
    }
    60% {
      transform: translate(-50%, -50%) scale(1.02);
      opacity: 1;
    }
    80% {
      transform: translate(-50%, -50%) scale(0.99);
      opacity: 1;
    }
    100% {
      transform: translate(-50%, -50%) scale(1);
      opacity: 1;
    }
  }

  /* 确保提示不被父元素裁切 */
  .task-wrapper:has(.template-task-drag-hint) {
    overflow: visible !important;
  }

  .task-wrapper.dragging {
    overflow: visible !important;
  }

  .dragging-shadow:has(.template-task-drag-hint) {
    overflow: visible !important;
  }

  /* 小屏幕适配 */
  @media (max-width: 375px) {
    .template-task-drag-hint {
      font-size: 16px;
      padding: 9px 18px;
      min-width: 150px;
      border-radius: 20px;
      letter-spacing: -0.3px;
      line-height: 1.3;
    }
  }

  /* 超小屏幕适配 */
  @media (max-width: 320px) {
    .template-task-drag-hint {
      font-size: 15px;
      padding: 8px 16px;
      min-width: 140px;
      border-radius: 18px;
      letter-spacing: -0.2px;
      line-height: 1.3;
    }
  }

  /* 滑块占位：默认不占高，显示滑块时占 60px 高度，避免遮挡 */
  .sync-spacer{height:0; transition:height .2s ease;}
  .sync-spacer.show{height:60px;}

  /* 日程容器动态底部缓冲 */
  #schedule{
    padding-bottom:20px;
    transition: padding-bottom .25s ease;
  }

  /* 滑块即将显示时的预留空间 */
  #schedule.sync-approaching{padding-bottom:40px;}

  /* 滑块完全显示时的空间 */
  #schedule.sync-visible{padding-bottom:40px;}

  /* 同步确认按钮样式 */
  .sync-confirm-btn {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    background: #34C759;
    color: white;
    border: none;
    border-radius: 20px;
    padding: 8px 16px;
    font-size: 14px;
    font-weight: 500;
    cursor: pointer;
    animation: confirmBtnShow 0.3s ease-out;
  }
  .sync-confirm-btn:active {
    transform: translate(-50%, -50%) scale(0.95);
    background: #28A745;
  }

  @keyframes confirmBtnShow {
    0% { opacity: 0; transform: translate(-50%, -50%) scale(0.8); }
    100% { opacity: 1; transform: translate(-50%, -50%) scale(1); }
  }

  /* 折叠分区在拖拽悬停时的浅描边提示 */
  .partition.drop-hint {
    outline: 2px dashed var(--stripe-color, #C7C7CC);
    outline-offset: 4px;
  }
  .partition.drop-hint .partition-header {
    filter: brightness(1.02);
  }

  /* 自动展开提示 */
  .partition.drop-hint::after {
    /*content: '自动展开中';*/
    position: absolute;
    top: -28px;
    right: 8px;
    background: rgba(52, 199, 89, 0.95);
    color: white;
    padding: 4px 8px;
    border-radius: 12px;
    font-size: 12px;
    font-weight: 500;
    white-space: nowrap;
    pointer-events: none;
    z-index: 1000;
    animation: expandingPulse 0.6s ease-out;
  }

  @keyframes expandingPulse {
    0% { opacity: 0; transform: translateY(8px) scale(0.9); }
    20% { opacity: 1; transform: translateY(0) scale(1.02); }
    100% { opacity: 1; transform: translateY(0) scale(1); }
  }

  /* ===== 动态时间选择器样式 ===== */
  .time-picker-indicator {
    position: fixed;
    z-index: 9999;
    pointer-events: none;
    animation: timePickerShow 0.25s cubic-bezier(0.175, 0.885, 0.32, 1.275);
  }

  .time-picker-bubble {
    position: relative;
    background: rgba(0, 0, 0, 0.85);
    color: white;
    padding: 8px 16px;
    border-radius: 12px;
    font-size: 13px;
    font-weight: 500;
    white-space: nowrap;
    box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
    backdrop-filter: blur(10px);
    -webkit-backdrop-filter: blur(10px);
  }

  /* 小三角指示器 */
  .triangle-pointer {
    position: absolute;
    width: 0;
    height: 0;
  }

  /* 小三角朝下（气泡在上方） */
  .triangle-pointer.down {
    bottom: -8px;
    left: 50%;
    transform: translateX(-50%);
    border-left: 8px solid transparent;
    border-right: 8px solid transparent;
    border-top: 8px solid rgba(0, 0, 0, 0.85);
  }

  /* 小三角朝上（气泡在下方） */
  .triangle-pointer.up {
    top: -8px;
    left: 50%;
    transform: translateX(-50%);
    border-left: 8px solid transparent;
    border-right: 8px solid transparent;
    border-bottom: 8px solid rgba(0, 0, 0, 0.85);
  }

  /* 小三角朝右（气泡在左方） */
  .triangle-pointer.right {
    top: 50%;
    left: -8px;
    transform: translateY(-50%);
    border-top: 8px solid transparent;
    border-bottom: 8px solid transparent;
    border-right: 8px solid rgba(0, 0, 0, 0.85);
  }

  /* 小三角朝左（气泡在右方） */
  .triangle-pointer.left {
    top: 50%;
    right: -8px;
    transform: translateY(-50%);
    border-top: 8px solid transparent;
    border-bottom: 8px solid transparent;
    border-left: 8px solid rgba(0, 0, 0, 0.85);
  }

  /* 动画定义 */
  @keyframes timePickerShow {
    0% {
      transform: scale(0.8) translateY(10px);
      opacity: 0;
    }
    100% {
      transform: scale(1) translateY(0);
      opacity: 1;
    }
  }

  @keyframes timePickerHide {
    0% {
      transform: scale(1) translateY(0);
      opacity: 1;
    }
    100% {
      transform: scale(0.8) translateY(10px);
      opacity: 0;
    }
  }

  /* ===== 原型v3.html CSS样式（完全照抄） ===== */
  :root {
    --ios-red:#FF3B30;
    --tile:rgba(255,255,255,0.6);
    --tile-border:rgba(255,255,255,0.4);
  }
  .overlay {
    position:fixed;
    inset:0;
    background:rgba(0,0,0,.4);
    backdrop-filter:blur(8px);
    display:none;
    z-index:10;
  }
  .overlay.active{display:block;}
  .sheet {
    position:fixed;
    left:0;right:0;bottom:-100%;
    background:rgba(255,255,255,0.9);
    border-radius:28px 28px 0 0;
    backdrop-filter:blur(28px);
    transition:bottom .35s ease;
    box-shadow:0 -6px 25px rgba(0,0,0,0.25);
    z-index:20;
    display:flex;
    flex-direction:column;
    max-height:92vh;
  }
  .overlay.active + .sheet {bottom:0;}
  .sheet .sheet-hd {
    position:relative;
    padding:12px 18px;
    display:flex;
    align-items:center;
    justify-content:space-between;
    background:rgba(255,255,255,0.85);
    backdrop-filter:blur(28px);
    border-top-left-radius:28px;
    border-top-right-radius:28px;
  }
  .hd-title {
    font-weight:700;
    font-size:17px;
    flex:1;
    text-align:center;
  }
  .sheet .hd-btn {
    width:44px;height:44px;
    border-radius:50%;
    display:flex;
    align-items:center;
    justify-content:center;
    cursor:pointer;
    transition:filter .2s ease, transform .1s ease;
    flex-shrink:0;
  }
  .sheet .hd-btn:active {transform:scale(0.96);}
  .sheet .hd-close {
    background:#fff;
    box-shadow:inset 0 1px 0 rgba(255,255,255,.9),
               inset 0 -1px 0 rgba(0,0,0,.06),
               0 6px 16px rgba(0,0,0,.12);
    border:1px solid rgba(0,0,0,.08);
    font-size:20px;
  }
  .sheet .hd-done {
    background:var(--ios-red);
    box-shadow:inset 0 1px 0 rgba(255,255,255,.25),
               0 10px 18px rgba(255,59,48,.35);
  }
  .hd-done::before {
    content:"";
    width:9px;height:18px;
    border-right:3px solid #fff;
    border-bottom:3px solid #fff;
    transform:rotate(45deg);
    filter:drop-shadow(0 1px 1px rgba(0,0,0,.25));
  }
  .sheet-bd {
    padding:8px 4% 18px;
    position:relative;
  }

  /* 番茄徽标（标题行右侧，水平对齐） */
  .focus-badge-wrap {
    position:relative;
    display:flex;
    align-items:center;
    justify-self:end;
    margin-left:12px;
  }
  .pill-sm {
    display:flex;
    align-items:center;
    gap:6px;
    font-size:12px;
    padding:6px 10px;
    height:24px;
    line-height:12px;
    border-radius:999px;
    background:var(--tile);
    border:1px solid var(--tile-border);
    backdrop-filter:blur(20px);
    box-shadow:0 2px 6px rgba(0,0,0,0.08);
    cursor:pointer;
  }
  .arrow {
    width:0;height:0;
    border-left:5px solid transparent;
    border-right:5px solid transparent;
    border-top:5px solid #555;
  }

  /* 标题行 */
  .title-row {
    display:grid;
    grid-template-columns:6px 28px 1fr auto;
    align-items:center;
    column-gap:10px;
    margin-top:12px;
  }
  .bar {width:4px;height:28px;border-radius:2px;background:#999;}
  .title-emoji {font-size:24px;height:28px;display:flex;align-items:center;justify-content:center;}
  .title-input {
    border:none;outline:none;background:transparent;
    font-size:16px;line-height:28px;
    height:28px;display:flex;align-items:center;
  }

  /* 日历 & 专注模式行（徽标风） */
  .row {
    display:flex;
    gap:10px;
    margin-bottom:12px;
    margin-top:10px;
  }
  .badge-card {position:relative;flex:1;}
  .badge-card.reminder-full-width {flex:2;max-width:none;}
  .pill {
    display:flex;align-items:center;justify-content:space-between;
    gap:6px;min-height:28px;padding:6px 10px;
    border-radius:999px;
    background:var(--tile);
    border:1px solid var(--tile-border);
    backdrop-filter:blur(20px);
    cursor:pointer;
  }
  .label {display:flex;align-items:center;gap:5px;}
  .badge-menu {
    position:absolute;right:0;top:30px;min-width:180px;
    background:#fff;border:1px solid rgba(0,0,0,.1);
    border-radius:14px;box-shadow:0 6px 18px rgba(0,0,0,.15);
    display:none;z-index:10;
  }
  .badge-card.active .badge-menu {display:block;}
  .focus-badge-wrap.active .badge-menu {display:block;}
  .menu-item {
    display:flex;align-items:center;justify-content:space-between;
    gap:8px;padding:8px 12px;cursor:pointer;
  }

    .menu-item:hover {background:rgba(0,0,0,.05);}
  .left {display:flex;align-items:center;gap:6px;}
  .dot {width:10px;height:10px;border-radius:50%;}
  .dot-mini {width:8px;height:8px;border-radius:50%;background:#d1d1d6;}
  .check {
    width:16px;height:16px;position:relative;
  }
  .check::before {
    content:"";position:absolute;width:5px;height:10px;
    border-right:2px solid rgba(255,255,255,.92);
    border-bottom:2px solid rgba(255,255,255,.92);
    transform:rotate(45deg) scale(0);
    transform-origin:bottom left;
    transition:transform .18s;
    filter:drop-shadow(0 0 2px rgba(0,0,0,.25));
  }
  .menu-item.selected {
    background:rgba(0,0,0,.25);color:#fff;
  }
  .menu-item.selected .check::before {transform:rotate(45deg) scale(1);}

  /* Emoji 区 */
  .emoji-grid {
    margin-top:10px;
    display:grid;
    grid-template-columns:repeat(5,1fr);
    gap:10px;
  }
  .emoji-btn {
    width:52px;height:52px;border-radius:50%;
    background:#f2f2f7;display:flex;
    align-items:center;justify-content:center;
    font-size:26px;border:1px solid rgba(0,0,0,.06);
    box-shadow:inset 0 1px 0 rgba(255,255,255,.9);
    cursor:pointer;transition:transform .15s, box-shadow .15s;
  }
  .emoji-btn:hover {transform:scale(1.07);}
  .emoji-btn.active {
    box-shadow:0 0 0 2px #0a84ff inset,0 0 6px rgba(10,132,255,.3);
  }

  </style>
<style>
  /* ===== 新任务输入框样式修复 ===== */
  /* expanded-fixed类现在只处理空内容的特殊情况 */
  .task-input.expanded-fixed:empty::before {
    content: none !important;
  }

  /* 确保在编辑状态下有正确的最小高度 */
  .task-input.expanded-fixed:empty {
    min-height: 1.4em !important;
    display: block !important;
  }

  /* ===== 横屏适配布局 ===== */
  @media screen and (orientation: landscape) {
    /* 横屏模式下body使用Grid布局 */
    body {
      display: grid;
      grid-template-rows: auto 1fr; /* 顶部header + 主内容区 */
      grid-template-areas:
        "header"
        "main";
      height: 100vh;
      padding: 0;
      overflow: hidden;
    }

    /* 顶部页眉固定在顶部区域 */
    .page-header {
      grid-area: header;
      position: static;
      background: #fff;
      border-bottom: 1px solid var(--stripe-default);
      z-index: 10;
    }

    /* 创建主内容容器包裹待办和日程 */
    .page-header {
      grid-area: header;
    }

    /* 在待办和日程外包裹主内容容器 */
    body::after {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      pointer-events: none;
      z-index: -1;
    }

    /* 待办和日程分区的共同容器 */
    #todoSection, #schedule {
      scroll-behavior: smooth;
      -webkit-overflow-scrolling: touch;
    }

    /* 调整padding为横屏模式 */
    #todoSection {
      padding: 8px 12px 0 12px;
    }

    #schedule {
      padding: 8px 12px 64px 12px;
    }
  }

  /* 中等尺寸横屏设备 */
  @media screen and (orientation: landscape) and (min-width: 667px) {
    body {
      grid-template-columns: 1fr 1fr;
      grid-template-rows: auto 1fr;
      grid-template-areas:
        "header header"
        "todo schedule";
    }

    /* 待办分区占据左侧 */
    #todoSection {
      grid-area: todo;
      height: calc(100vh - var(--rule-gap) - 1px);
      overflow-y: auto;
      border-right: 1px solid var(--stripe-default);
      padding: 8px 12px 0 12px;
    }

    /* 日程分区占据右侧 */
    #schedule {
      grid-area: schedule;
      height: calc(100vh - var(--rule-gap));
      overflow-y: auto;
      padding: 8px 12px 64px 12px;
    }

    /* 隐藏原始的分隔线 */
    #todoSection .section-divider {
      display: none;
    }

    /* 横屏模式下的分隔线样式优化 */
    #todoSection {
      box-shadow: 2px 0 8px rgba(0, 0, 0, 0.05);
    }

    /* 确保横屏模式下任务列表不会过分拥挤 */
    .task-list {
      padding-right: 4px;
    }

    /* 横屏模式下优化分区间距 */
    .partition {
      margin-bottom: 20px;
    }
  }

  /* 大尺寸横屏设备 */
  @media screen and (orientation: landscape) and (min-width: 1024px) {
    body {
      padding: 0 20px;
    }

    #todoSection, #schedule {
      padding-left: 16px;
      padding-right: 16px;
    }
  }

  /* ===== AI功能集成样式 ===== */
  /* AI按钮样式 */
  .ai-btn {
    color: #8E44AD; /* 紫色，区别于蓝色和红色 */
  }
  .ai-btn:hover {
    background: rgba(142, 68, 173, 0.1);
    transform: scale(1.05);
  }
  .ai-btn:active {
    background: rgba(142, 68, 173, 0.15);
    transform: scale(0.9);
  }

  /* ===== 完成任务显示控制样式 ===== */
  /* 眼睛按钮样式 */
  .visibility-btn {
    color: #FF6B35; /* 橙色，区别于蓝色、红色和紫色 */
  }
  .visibility-btn:hover {
    background: rgba(255, 107, 53, 0.1);
    transform: scale(1.05);
  }
  .visibility-btn:active {
    background: rgba(255, 107, 53, 0.15);
    transform: scale(0.9);
  }
  .visibility-btn.showing {
    color: #2ECC71; /* 绿色，表示显示状态 */
  }

  /* AI下拉菜单 */
  /* AI下拉菜单 - 专注模式风格调整 */
  #aiDropdown {
    background: #fff;
    border: 1px solid rgba(0,0,0,.1);
    border-radius: 14px;
    box-shadow: 0 6px 18px rgba(0,0,0,.15);
    display: none;
    padding: 4px;
    -webkit-backdrop-filter: blur(20px);
    backdrop-filter: blur(20px);
  }
  #aiDropdown.show {
    display: block;
  }
  #aiDropdown .menu-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    padding: 8px 12px;
    cursor: pointer;
    border-radius: 10px;
    margin: 2px 0;
    transition: all 0.2s ease;
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
  }
  #aiDropdown .menu-item:hover {
    background: rgba(0,0,0,.05);
  }
  #aiDropdown .menu-item:active {
    background: rgba(0,0,0,.1);
    transform: scale(0.98);
    transition: all 0.1s ease;
  }
  #aiDropdown .menu-item .left {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  #aiDropdown .menu-item .left span:first-child {
    font-size: 16px;
  }
  #aiDropdown .menu-item .left span:last-child {
    font-size: 14px;
    font-weight: 500;
  }

  /* 横屏模式下AI下拉菜单优化 */
  @media screen and (orientation: landscape) and (min-width: 667px) {
    #aiDropdown {
      right: 8px;
      min-width: 200px;
    }
  }

  /* 小屏幕AI下拉菜单适配 */
  @media screen and (max-width: 374px) {
    #aiDropdown {
      min-width: 160px;
      right: 4px;
    }
    #aiDropdown .menu-item .left span:last-child {
      font-size: 13px;
    }
  }

  /* ===== SVG图标样式 ===== */
  .icon-svg {
    width: 20px;
    height: 20px;
    color: currentColor;
    transition: all 0.2s ease;
    display: block;
    flex-shrink: 0;
  }

  /* AI按钮的SVG图标特殊样式 */
  .ai-btn .icon-svg {
    width: 20px;
    height: 20px;
  }

  /* 可见/隐藏按钮的SVG图标特殊样式 */
  .visibility-btn .icon-svg {
    width: 20px;
    height: 20px;
  }

  /* ===== 新建功能合并样式 ===== */
  /* 主要添加按钮 - iOS蓝色主题 */
  .primary-add-btn {
    color: var(--blue); /* #007AFF */
    font-size: 20px;     /* 稍大字体，突出重要性 */
    font-weight: 600;
  }
  .primary-add-btn:hover {
    background: rgba(0, 122, 255, 0.1);
    transform: scale(1.05);
  }
  .primary-add-btn:active {
    background: rgba(0, 122, 255, 0.15);
    transform: scale(0.95);
    transition: transform 0.1s ease;
  }

  /* 新建功能下拉菜单 - 专注模式风格调整 */
  #addDropdownMenu {
    background: #fff;
    border: 1px solid rgba(0,0,0,.1);
    border-radius: 14px;
    box-shadow: 0 6px 18px rgba(0,0,0,.15);
    display: none;
    padding: 4px;
    -webkit-backdrop-filter: blur(20px);
    backdrop-filter: blur(20px);
  }
  #addDropdownMenu.show {
    display: block;
  }
  #addDropdownMenu .menu-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    gap: 8px;
    padding: 8px 12px;
    cursor: pointer;
    border-radius: 10px;
    margin: 2px 0;
    transition: all 0.2s ease;
    -webkit-tap-highlight-color: transparent;
    touch-action: manipulation;
  }
  #addDropdownMenu .menu-item:hover {
    background: rgba(0,0,0,.05);
  }
  #addDropdownMenu .menu-item:active {
    background: rgba(0,0,0,.1);
    transform: scale(0.98);
    transition: all 0.1s ease;
  }
  #addDropdownMenu .menu-item .left {
    display: flex;
    align-items: center;
    gap: 8px;
  }
  #addDropdownMenu .menu-item .left span:first-child {
    font-size: 16px;
  }
  #addDropdownMenu .menu-item .left span:last-child {
    font-size: 14px;
    font-weight: 500;
  }

  /* 横屏模式优化 */
  @media screen and (orientation: landscape) and (min-width: 667px) {
    #addDropdownMenu {
      right: 8px;
      min-width: 200px;
    }
  }

  /* 小屏幕适配 */
  @media screen and (max-width: 374px) {
    #addDropdownMenu {
      min-width: 160px;
      right: 4px;
    }
    #addDropdownMenu .menu-item .left span:last-child {
      font-size: 13px;
    }
  }

  </style>
</head>
<body>
  <!-- 顶部（日期+＋） -->
  <div class="page-header">
    <div class="page-header-row">
      <div class="header-left" id="headerDateBig"></div>
      <div class="header-right">
        <span id="headerDate"></span>
        <span id="addBtn" class="add-btn primary-add-btn" title="新建">
          <svg class="icon-svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" aria-label="plus">
            <path d="M12 5v14M5 12h14"/>
          </svg>
        </span>
        <span id="aiBtn" class="add-btn ai-btn" title="AI功能">
          <svg class="icon-svg" viewBox="0 0 24 24" fill="none" aria-label="Ai-text">
            <text x="12" y="15" font-size="16" text-anchor="middle" dominant-baseline="middle" font-family="system-ui,-apple-system,'SF Pro Text','SF Pro Display',Helvetica,Arial" fill="currentColor" font-weight="600">Ai</text>
          </svg>
        </span>
        <span id="visibilityBtn" class="add-btn visibility-btn" title="显示/隐藏完成任务">
          <svg class="icon-svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" aria-label="eye-off">
            <path d="M2 12s3.5-7 10-7 10 7 10 7-3.5 7-10 7S2 12 2 12z"/>
            <circle cx="12" cy="12" r="3"/>
            <line x1="2" y1="2" x2="22" y2="22"/>
          </svg>
        </span>
      </div>
    </div>
  </div>

  <!-- AI下拉菜单 - 专注模式风格 -->
  <div class="badge-menu" id="aiDropdown" style="position: fixed; top: 60px; right: 16px; z-index: 1000; min-width: 180px;">
    <div class="menu-item" data-action="aiReview">
      <div class="left">
        <span>📊</span>
        <span>AI复盘</span>
      </div>
      <div class="check"></div>
    </div>
    <div class="menu-item" data-action="aiArrange">
      <div class="left">
        <span>📅</span>
        <span>AI安排</span>
      </div>
      <div class="check"></div>
    </div>
  </div>

  <!-- 新建功能下拉菜单 - 专注模式风格 -->
  <div class="badge-menu" id="addDropdownMenu" style="position: fixed; top: 60px; right: 16px; z-index: 1001; min-width: 180px;">
    <div class="menu-item" data-action="addTodo">
      <div class="left">
        <span>📋</span>
        <span>新建提醒事项列表</span>
      </div>
      <div class="check"></div>
    </div>
    <div class="menu-item" data-action="addSchedule">
      <div class="left">
        <span>📅</span>
        <span>新建日程</span>
      </div>
      <div class="check"></div>
    </div>
  </div>

  <!-- 待办大分区（也作为"partition"参与悬停描边） -->
  <section id="todoSection" class="partition">
    <!--<div class="partition-header todo-header">-->
    <!--  <div></div>-->
<!--      <div class="section-title">待办</div>-->
<!--      <div class="right-box">-->
<!--        <span id="todoBadge" class="badge badge-chevron" role="button" aria-label="折叠/展开" tabindex="0">-->
<!--          <span class="chev"></span>-->
<!--        </span>-->
<!--      </div>-->
<!--    </div>-->
    <div id="todoList" class="task-list"></div>
    <div class="section-divider"></div>
  </section>

  <!-- 日程大分区容器 -->
  <div id="schedule"></div>

  <!-- 隐藏 time 输入容器 -->
  <div id="timeInputsBucket" style="position:fixed;left:-9999px;top:-9999px;width:1px;height:1px;overflow:hidden;"></div>

  <!-- 原型v3.html 完整结构 -->
  <div class="overlay" id="ov"></div>
  <div class="sheet" id="sheet">
    <div class="sheet-hd">
      <div class="hd-btn hd-close" id="btnClose">✕</div>
      <div class="hd-title">编辑日程</div>
      <div class="hd-btn hd-done" id="btnDone"></div>
    </div>
    <div class="sheet-bd">
      <!-- 标题 -->
      <div class="title-row">
        <div class="bar" id="bar"></div>
        <div class="title-emoji" id="emojiShow">💻</div>
        <input class="title-input" id="title" value="下午会议">
        <!-- 番茄徽标 -->
        <div class="focus-badge-wrap">
          <div class="pill-sm" id="focusBadge">
            <span id="focusBadgeText">🍅 番茄时间</span>
            <div class="arrow"></div>
          </div>
          <div class="badge-menu" id="focusMenu" style="right:0;left:auto;top:30px;min-width:180px;">
            <div class="menu-item" data-value="无"><div class="left"><span class="dot-mini"></span><span>无</span></div><div class="check"></div></div>
            <div class="menu-item" data-value="番茄时间"><div class="left"><span>🍅</span><span>番茄时间</span></div><div class="check"></div></div>
            <div class="menu-item" data-value="时间盒"><div class="left"><span>🗃️</span><span>时间盒</span></div><div class="check"></div></div>
          </div>
        </div>
      </div>
      <!-- 日历 + 专注模式 -->
      <div class="row">
        <div class="badge-card" id="calCard">
          <div class="pill" id="calSel">
            <div class="label" id="calText">
              <span class="dot" id="calDot" style="background:#999"></span><span>分类</span>
            </div>
            <div class="arrow"></div>
          </div>
          <div class="badge-menu" id="calMenu">
            <div class="menu-item" data-value="工作" data-color="#bf5af2" data-emoji="💻"><div class="left"><span class="dot" style="background:#bf5af2"></span><span>💻 工作</span></div><div class="check"></div></div>
            <div class="menu-item" data-value="休闲" data-color="#0a84ff" data-emoji="🛋️"><div class="left"><span class="dot" style="background:#0a84ff"></span><span>🛋️ 休闲</span></div><div class="check"></div></div>
            <div class="menu-item" data-value="家庭" data-color="#30d158" data-emoji="🏠"><div class="left"><span class="dot" style="background:#30d158"></span><span>🏠 家庭</span></div><div class="check"></div></div>
            <div class="menu-item" data-value="学习" data-color="#ff453a" data-emoji="📖"><div class="left"><span class="dot" style="background:#ff453a"></span><span>📖 学习</span></div><div class="check"></div></div>
            <div class="menu-item" data-value="机动" data-color="#ffd60a" data-emoji="🆓"><div class="left"><span class="dot" style="background:#ffd60a"></span><span>🆓 机动</span></div><div class="check"></div></div>
            <div class="menu-item" data-value="习惯" data-color="#ac8e68" data-emoji="🧑‍🦱"><div class="left"><span class="dot" style="background:#ac8e68"></span><span>🧑‍🦱 习惯</span></div><div class="check"></div></div>
          </div>
        </div>
        <div class="badge-card" id="modeCard">
          <div class="pill" id="modeSel">
            <div class="label" id="modeText">专注模式</div>
            <div class="arrow"></div>
          </div>
          <div class="badge-menu" id="modeMenu">
            <div class="menu-item" data-value="无"><div class="left"><span class="dot-mini"></span><span>无</span></div><div class="check"></div></div>
            <div class="menu-item" data-value="💻工作"><div class="left"><span>💻 工作</span></div><div class="check"></div></div>
            <div class="menu-item" data-value="🛝娱乐"><div class="left"><span>🛝 娱乐</span></div><div class="check"></div></div>
            <div class="menu-item" data-value="🧑‍🏫课堂"><div class="left"><span>🧑‍🏫 课堂</span></div><div class="check"></div></div>
            <div class="menu-item" data-value="🎙️会议"><div class="left"><span>🎙️ 会议</span></div><div class="check"></div></div>
          </div>
        </div>
      </div>
      <!-- 待办事项列表 -->
      <div class="row">
        <div class="badge-card reminder-full-width" id="reminderCard">
          <div class="pill" id="reminderSel">
            <div class="label" id="reminderText">
              <span>提醒事项列表</span>
            </div>
            <div class="arrow"></div>
          </div>
          <div class="badge-menu" id="reminderMenu">
            <!-- 动态生成的待办分区选项 -->
          </div>
        </div>
      </div>
      <!-- Emoji 区 -->
      <div class="emoji-grid" id="eg"></div>
    </div>
  </div>

  <!-- 底部滑块占位：显示滑块时占位，避免遮住内容 -->
  <div id="syncSpacer" class="sync-spacer" aria-hidden="true"></div>

  <!-- 任务编辑表单 -->
  <div id="taskEditModal" class="task-edit-modal" style="display:none">
    <div class="task-edit-overlay"></div>
    <div class="task-edit-card">
      <div class="task-edit-header">
        <button id="taskEditChk" class="task-edit-checkbox" aria-checked="false" aria-label="标记完成"></button>
        <input id="taskEditTitle" class="task-edit-title" placeholder="任务标题" aria-label="任务标题" />
        <button id="taskEditClose" class="task-edit-close" aria-label="关闭">×</button>
      </div>

      <!-- 模板任务开关 -->
      <div class="task-edit-section" id="templateSection">
        <div class="task-edit-row">
          <div class="task-edit-switch-wrapper">
            <label class="task-edit-switch">
              <input type="checkbox" id="templateToggle">
              <span class="task-edit-slider"></span>
            </label>
            <span class="task-edit-switch-label">模板任务</span>
          </div>
        </div>
      </div>

      <!-- 时间相关标签 -->
      <div class="task-edit-section" id="timeEditSection">
        <div class="task-edit-row">
          <div class="task-edit-belt" id="taskEditBeltTime">
            <button class="task-edit-ctrl" data-type="start">开始＋</button>
            <button class="task-edit-ctrl" data-type="duration">用时＋</button>
            <button class="task-edit-ctrl" data-type="due">截止＋</button>
            <button class="task-edit-ctrl" data-type="repeat">周期＋</button>
          </div>
        </div>
      </div>

      <!-- 其他标签 -->
      <div class="task-edit-section">
        <div class="task-edit-row">
          <div class="task-edit-belt" id="taskEditBeltTags">
            <button class="task-edit-ctrl text-tag-btn" data-type="goal">目标</button>
            <button class="task-edit-ctrl text-tag-btn" data-type="deliverable">产出物</button>
            <button class="task-edit-ctrl text-tag-btn" data-type="contact">联系人</button>
            <button class="task-edit-ctrl text-tag-btn" data-type="place">地点</button>
            <button class="task-edit-ctrl text-tag-btn" data-type="note">备注</button>
          </div>
        </div>
        <!-- 已添加标签容器 -->
        <div class="task-edit-row">
          <div class="task-edit-tags-container" id="taskEditTagsContainer">
            <!-- 已添加的标签将显示在这里 -->
          </div>
        </div>
      </div>

      <!-- 周期编辑器 -->
      <div id="taskRepeatEditor" class="task-repeat-editor">
        <select id="repeatModeSelect" class="repeat-mode-select">
          <option value="none">不重复</option>
          <option value="dailyAt">每天@</option>
          <option value="workdayAt">工作日@</option>
          <option value="everyN">每N天</option>
          <option value="nWork">每N个工作日</option>
          <option value="weekly">每周@</option>
          <option value="nWeeks">每N周@</option>
          <option value="monthly">每月@</option>
          <option value="nMonths">每N个月@</option>
          <option value="yearly">每年@</option>
        </select>

        <div id="repeatParams" class="repeat-params">
          <!-- 动态生成的参数输入控件 -->
        </div>

        <div class="repeat-actions">
          <button id="repeatCancel" class="repeat-btn">取消</button>
          <button id="repeatConfirm" class="repeat-btn primary">确定</button>
        </div>
      </div>

      <!-- 操作按钮 -->
      <div class="task-edit-actions">
        <button id="createScheduleBtn" class="task-edit-action-btn" style="display:none">创建日程</button>
        <button id="taskEditConfirm" class="task-edit-confirm-btn">确认</button>
      </div>
    </div>
  </div>

  <!-- Done+完成表单 -->
  <div id="donePlusModal" class="done-plus-modal">
    <div class="done-plus-overlay"></div>
    <div class="done-plus-form">
      <!-- 参考原型v3.html的头部布局：左关闭右保存 -->
      <div class="done-plus-header sheet-hd">
        <div class="hd-btn hd-close done-plus-close" aria-label="关闭">✕</div>
        <div class="hd-title done-plus-title">Done+ 完成</div>
        <div class="hd-btn hd-done done-plus-confirm" aria-label="保存"></div>
      </div>

      <!-- 区域1：Done+所属任务文本编辑 -->
      <div class="done-plus-section">
        <div class="done-plus-row done-plus-unified-input">
          <!-- 左侧Done+图标 -->
          <div class="done-plus-area-icon task-with-doneplus">
            <div class="icon-checkbox"></div>
            <div class="icon-doneplus-badge">+</div>
          </div>
          <!-- 右侧输入框 -->
          <input class="done-plus-task-text-input" type="text" placeholder="编辑任务文本...">
        </div>
      </div>

      <!-- 区域2：创建新任务功能 -->
      <div class="done-plus-section">
        <div class="done-plus-row done-plus-unified-input">
          <!-- 左侧占位符图标 -->
          <div class="done-plus-area-icon task-placeholder">
            <div class="icon-checkbox placeholder"></div>
          </div>
          <!-- 右侧输入框 -->
          <input class="done-plus-task-input" type="text" placeholder="输入下一步">
        </div>
      </div>

      <!-- 区域3：输入笔记功能 -->
      <div class="done-plus-section">
        <div class="done-plus-row done-plus-unified-input">
          <textarea class="done-plus-textarea" placeholder="输入笔记"></textarea>
        </div>
      </div>
    </div>
  </div>

  <!-- 页面底部哨兵：滚到这里时显示滑块 -->
  <div id="bottomSentinel" style="height: 1px;"></div>

  <!-- 底部滑动同步（到达最底部才显示） -->
  <div class="sync-bar">
    <!-- 滑块阶段 -->
    <div id="syncSliderStage" class="sync-track">
      <div class="sync-label">滑动以同步</div>
      <div id="syncThumb" class="sync-thumb">同步 ➜</div>
    </div>

    <!-- 按钮阶段 -->
    <div id="syncButtonStage" class="sync-button-stage">
      <button id="syncSubmitBtn" class="sync-submit-btn" onclick="submitForm()">
        轻点同步
      </button>
    </div>
  </div>

  <!-- SortableJS -->
  <script>
    (function loadSortable(){
      const s=document.createElement('script');
      s.src='https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js';
      s.async=true;
      s.onload=()=>{
        window.__sortableReady=true;
        // 延迟调用render，确保函数已定义
        setTimeout(() => {
          if (typeof render === 'function') {
            render(true);
          } else {
          }
        }, 100);
      };
      s.onerror=()=>{
        setTimeout(() => {
          if (typeof render === 'function') {
            render(false);
          }
        }, 100);
      };
      document.head.appendChild(s);
    })();
  </script>

  <script>
    /**
     * ===== 核心系统类定义 =====
     */

    /**
     * ID生成器类 - 确保全局唯一性
     */
    class IDGenerator {
      constructor() {
        this.lastSecond = '';        // 上次生成ID的秒级时间戳
        this.secondCounter = 0;      // 当前秒内的计数器
        this.usedIds = new Set();    // 已使用的ID集合（可选的安全检查）
      }

      /**
       * 格式化时间为字符串
       * @param {Date} date - 日期对象
       * @returns {string} 格式化的时间字符串 YYYYMMDDHHMMSS
       */
      formatDateTime(date) {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, '0');
        const day = String(date.getDate()).padStart(2, '0');
        const hour = String(date.getHours()).padStart(2, '0');
        const minute = String(date.getMinutes()).padStart(2, '0');
        const second = String(date.getSeconds()).padStart(2, '0');

        return `${year}${month}${day}${hour}${minute}${second}`;
      }

      /**
       * 生成3位随机字符
       * @returns {string} 3位随机字符
       */
      generateRandomSuffix() {
        const chars = 'abcdefghijklmnopqrstuvwxyz0123456789';
        let result = '';
        for (let i = 0; i < 3; i++) {
          result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
      }

      /**
       * 生成流水号ID
       * @param {string} prefix - ID前缀（T=任务, P=分区）
       * @returns {string} 流水号ID
       */
      generateFlowId(prefix = 'T') {
        const now = new Date();
        const currentSecond = this.formatDateTime(now);

        // 如果是新的秒，重置计数器
        if (currentSecond !== this.lastSecond) {
          this.lastSecond = currentSecond;
          this.secondCounter = 0;
        }

        // 递增当前秒内的计数器
        this.secondCounter++;

        // 构造ID：前缀 + 时间戳(14位) + 序号(3位) + 随机字符(3位)
        const sequence = String(this.secondCounter).padStart(3, '0');
        const randomSuffix = this.generateRandomSuffix();
        const id = `${prefix}${currentSecond}${sequence}${randomSuffix}`;

        // 可选的重复检查（双重保险）
        if (this.usedIds.has(id)) {
          // 递归重新生成（极少发生）
          return this.generateFlowId(prefix);
        }

        this.usedIds.add(id);

        return id;
      }

      /**
       * 生成任务ID
       * @returns {string} 任务ID，以T开头
       */
      generateTaskId() {
        return this.generateFlowId('T');
      }

      /**
       * 生成分区ID
       * @returns {string} 分区ID，以P开头
       */
      generatePartitionId() {
        return this.generateFlowId('P');
      }

      /**
       * 标记ID已使用（用于导入现有数据）
       * @param {string} id - 要标记的ID
       */
      markUsed(id) {
        this.usedIds.add(id);
      }

      /**
       * 检查ID是否已使用
       * @param {string} id - 要检查的ID
       * @returns {boolean} 是否已使用
       */
      isUsed(id) {
        return this.usedIds.has(id);
      }

      /**
       * 获取统计信息
       * @returns {Object} 统计信息
       */
      getStats() {
        return {
          totalGenerated: this.usedIds.size,
          currentSecond: this.lastSecond,
          secondCounter: this.secondCounter,
          lastGeneratedAt: new Date().toLocaleString()
        };
      }

      /**
       * 重置生成器（仅测试用）
       */
      reset() {
        this.lastSecond = '';
        this.secondCounter = 0;
        this.usedIds.clear();
      }
    }

    /**
     * 状态管理器 - 响应式数据管理
     */
    class StateManager {
      constructor() {
        this.listeners = new Map(); // 事件监听器
        this.debounceTimers = new Map(); // 防抖定时器
      }

      /**
       * 订阅数据变化
       * @param {string} key - 监听的键
       * @param {Function} callback - 回调函数
       */
      subscribe(key, callback) {
        if (!this.listeners.has(key)) {
          this.listeners.set(key, new Set());
        }
        this.listeners.get(key).add(callback);
      }

      /**
       * 取消订阅
       * @param {string} key - 键
       * @param {Function} callback - 回调函数
       */
      unsubscribe(key, callback) {
        if (this.listeners.has(key)) {
          this.listeners.get(key).delete(callback);
        }
      }

      /**
       * 触发事件（带防抖）
       * @param {string} key - 事件键
       * @param {*} data - 事件数据
       */
      emit(key, data) {
        // 清除之前的防抖定时器
        if (this.debounceTimers.has(key)) {
          clearTimeout(this.debounceTimers.get(key));
        }

        // 设置新的防抖定时器
        this.debounceTimers.set(key, setTimeout(() => {
          if (this.listeners.has(key)) {
            this.listeners.get(key).forEach(callback => {
              try {
                callback(data);
              } catch (error) {
              }
            });
          }
          this.debounceTimers.delete(key);
        }, 16)); // 16ms ≈ 60fps
      }
    }

    /**
     * DOM管理器 - 增量DOM更新
     */
    class DOMManager {
      constructor() {
        this.domCache = new WeakMap(); // DOM元素缓存
        this.pendingUpdates = new Set(); // 待处理更新
        this.updateScheduled = false;
      }

      /**
       * 缓存DOM元素
       * @param {string} key - 缓存键
       * @param {HTMLElement} element - DOM元素
       */
      cache(key, element) {
        this.domCache.set({ key }, element);
      }

      /**
       * 获取缓存的DOM元素
       * @param {string} key - 缓存键
       * @returns {HTMLElement|null}
       */
      getCache(key) {
        for (let [keyObj, element] of this.domCache.entries()) {
          if (keyObj.key === key) {
            return element;
          }
        }
        return null;
      }

      /**
       * 批量DOM更新
       * @param {Function} updateFn - 更新函数
       */
      batchUpdate(updateFn) {
        this.pendingUpdates.add(updateFn);

        if (!this.updateScheduled) {
          this.updateScheduled = true;

          // 使用 requestAnimationFrame 优化性能
          requestAnimationFrame(() => {
            const updates = Array.from(this.pendingUpdates);
            this.pendingUpdates.clear();
            this.updateScheduled = false;

            // 批量执行DOM更新
            updates.forEach(fn => {
              try {
                fn();
              } catch (error) {
              }
            });
          });
        }
      }

      /**
       * 安全地更新DOM元素
       * @param {HTMLElement} element - 要更新的元素
       * @param {Function} updateFn - 更新函数
       */
      safeUpdate(element, updateFn) {
        if (element && element.isConnected) {
          this.batchUpdate(() => updateFn(element));
        }
      }
    }

    /**
     * iPhone性能优化工具
     */
    class PerformanceOptimizer {
      /**
       * 防抖函数
       * @param {Function} fn - 要防抖的函数
       * @param {number} delay - 延迟时间
       * @returns {Function}
       */
      static debounce(fn, delay = 300) {
        let timeoutId;
        return function (...args) {
          clearTimeout(timeoutId);
          timeoutId = setTimeout(() => fn.apply(this, args), delay);
        };
      }

      /**
       * 节流函数
       * @param {Function} fn - 要节流的函数
       * @param {number} delay - 延迟时间
       * @returns {Function}
       */
      static throttle(fn, delay = 100) {
        let lastCallTime = 0;
        return function (...args) {
          const now = Date.now();
          if (now - lastCallTime >= delay) {
            lastCallTime = now;
            return fn.apply(this, args);
          }
        };
      }

      /**
       * 被动事件监听器配置
       * @returns {Object}
       */
      static get passiveEventOptions() {
        return { passive: true, capture: false };
      }
    }


    /**
     * ===== 全局数据和常量定义 =====
     */

    /**
     * 应用主数据结构（二维数组结构）
     * @type {Array<Array>}
     * @description 包含待办事项和日程分区的二维数组
     * - data[0]：待办事项数组
     * - data[1]：日程分区数组
     */
    // 全局实例初始化
    const idGenerator = new IDGenerator();
    const stateManager = new StateManager();
    const domManager = new DOMManager();


    /**
     * 生成任务唯一ID
     * @returns {string} 任务ID
     */
    function generateTaskId() {
      return idGenerator.generateTaskId();
    }

    /**
     * 生成分区唯一ID
     * @returns {string} 分区ID
     */
    function generatePartitionId() {
      return idGenerator.generatePartitionId();
    }

    /**
     * ===== 新增：原型v3.html功能预定义常量 =====
     */

    // 番茄徽标配置 (基于原型v3.html focusBadge)
    const POMODORO_BADGE_TYPES = {
      none: {
        name: "无",
        emoji: "",
        color: "transparent"
      },
      "番茄时间": {
        name: "番茄时间",
        emoji: "🍅",
        color: "#ff453a"
      },
      "时间盒": {
        name: "时间盒",
        emoji: "🗃️",
        color: "#007aff"
      }
    };

    // 日历分类配置 (基于原型v3.html calCard)
    const CALENDAR_CATEGORIES = {
      "工作": {
        emoji: "💻",
        color: "#bf5af2"
      },
      "休闲": {
        emoji: "🛋️",
        color: "#0a84ff"
      },
      "家庭": {
        emoji: "🏠",
        color: "#30d158"
      },
      "学习": {
        emoji: "📖",
        color: "#ff453a"
      },
      "机动": {
        emoji: "🆓",
        color: "#ffd60a"
      },
      "习惯": {
        emoji: "🧑‍🦱",
        color: "#ac8e68"
      }
    };

    // 专注模式配置 (基于原型v3.html modeCard)
    const FOCUS_MODE_TYPES = {
      "无": {
        emoji: "",
        color: "transparent"
      },
      "💻工作": {
        emoji: "💻",
        color: "#bf5af2"
      },
      "🛝娱乐": {
        emoji: "🛝",
        color: "#0a84ff"
      },
      "🧑‍🏫课堂": {
        emoji: "🧑‍🏫",
        color: "#30d158"
      },
      "🎙️会议": {
        emoji: "🎙️",
        color: "#ff453a"
      }
    };


    /**
     * 任务管理系统数据结构（扁平化设计）
     *
     * 任务对象属性说明：
     * - id: 任务唯一标识符
     * - text: 任务文本内容
     * - done: 任务完成状态
     * - parentId: 父任务ID，null表示主任务
     * - level: 任务层级（0=主任务，1=子任务，支持多级嵌套）
     * - isTemplate: 是否为模板任务（模板任务不可完成，可复制到日程）
     * - isRecurring: 是否为周期任务（周期任务不可完成，定期生成新任务）
     * - details: 任务详细信息对象{目标、产出物、联系人、地点、时间等}
     */
    const data =
        [
            [
                {
                    "id": null,
                    "title": "待办事项列表",
                    "meta": {
                        "time": "",
                        "collapsed": false,
                        "isTodoPartition": true,
                        "multiPartitionReady": true
                    },
                    "tasks": [
                        {
                            "id": null,
                            "text": "整理朋友圈",
                            "done": false,
                            "parentId": null,
                            "level": 0,
                            "isRecurring": false,
                            "donePlus": {
                                "enabled": true,
                                "notes": [],
                                "subtasks": []
                            },
                            "details": {                               // 任务详细信息对象
                                "isTemplate": false,                   // 是否为模板任务
                                "time": {                              // 时间相关信息
                                    "start": "2025-09-30 22:57:00",   // 开始时间 (格式: yyyy-mm-dd hh:mm:ss)
                                    "end": "2025-09-24 23:59:59",     // 截止时间 (格式: yyyy-mm-dd hh:mm:ss)
                                    "duration": {                      // 预估用时
                                        "value": 1,                    // 时长数值
                                        "unit": "min"                  // 时长单位 (min/h/d/month)
                                    }
                                },
                                "recurrence": {                        // 周期任务配置
                                    "enabled": false,                  // 取消周期
                                    "pattern": "none",                 // 无周期模式
                                    "config": {}                       // 空配置
                                },
                                "tags": {                              // 文本标签信息（非唯一性，可多个）
                                    "goals": ["目标1"],               // 目标数组
                                    "outputs": ["产出物2"],            // 产出物数组
                                    "contacts": ["联系人3"],           // 联系人数组
                                    "locations": ["地点4"],            // 地点数组
                                    "notes": ["备注5","备注5","备注5","备注5","备注5","备注5","备注5","备注5"]                // 备注数组
                                },
                                "visibility": {                        // 字段可见性控制
                                    "start": false,                     // 开始时间是否展开显示
                                    "duration": false,                  // 用时是否展开显示
                                    "end": false,                       // 截止时间是否展开显示
                                    "repeat": false                    // 周期是否展开显示
                                }
                            }
                        },
                        {
                            "id": null,
                            "text": "收集椰子书法案例",
                            "done": false,
                            "parentIndex": 0,
                            "level": 1,
                            "isRecurring": false,
                            "details": {}                              // 详细信息为空
                        },
                        {
                            "id": null,
                            "text": "整理核心优势文案",
                            "done": false,
                            "parentIndex": 0,
                            "level": 1,
                            "isRecurring": false,
                            "details": {}                              // 详细信息为空
                        },
                        {
                            "id": null,
                            "text": "更新大爆炸",
                            "done": false,
                            "parentId": null,
                            "level": 0,
                            "isRecurring": true,
                            "donePlus": {
                                "enabled": true,
                                "notes": [],
                                "subtasks": []
                            },
                            "details": {
                                "isTemplate": false,
                                "recurrence": {
                                    "enabled": true,
                                    "pattern": "每天",
                                    "config": {
                                        "time": "09:00"
                                    }
                                },
                                "visibility": {
                                    "start": true,
                                    "duration": false,
                                    "end": false,
                                    "repeat": true
                                }
                            }
                        },
                        {
                            "id": null,
                            "text": "学习Java",
                            "done": false,
                            "parentId": null,
                            "level": 0,
                            "isRecurring": false,
                            "details": {}                              // 详细信息为空
                        },
                        {
                            "id": null,
                            "text": "制作课程视频模板",
                            "done": false,
                            "parentId": null,
                            "level": 0,
                            "isRecurring": false,
                            "details": {
                                "isTemplate": true                    // 标记为模板任务
                            }
                        },
                        {
                            "id": null,
                            "text": "准备录制设备",
                            "done": false,
                            "parentIndex": 5,
                            "level": 1,
                            "isRecurring": false,
                            "details": {}                              // 详细信息为空
                        },
                        {
                            "id": null,
                            "text": "编写课程大纲",
                            "done": false,
                            "parentIndex": 5,
                            "level": 1,
                            "isRecurring": false,
                            "details": {}                              // 详细信息为空
                        }
                    ]
                },
                {
                    "id": null,
                    "title": "学习计划",
                    "meta": {
                        "time": "",
                        "collapsed": false,
                        "isTodoPartition": true,
                        "multiPartitionReady": true,
                        "icon": "📚"
                    },
                    "tasks": [
                        {
                            "id": null,
                            "text": "学习前端开发",
                            "done": false,
                            "parentId": null,
                            "level": 0,
                            "isRecurring": false,
                            "donePlus": {
                                "enabled": true,
                                "notes": [],
                                "subtasks": []
                            },
                            "details": {
                                "isTemplate": false,
                                "time": {
                                    "start": "2025-09-25 09:00:00",
                                    "end": "2025-09-25 11:00:00",
                                    "duration": {
                                        "value": 2,
                                        "unit": "h"
                                    }
                                },
                                "recurrence": {
                                    "enabled": true,
                                    "pattern": "每天",
                                    "config": {
                                        "time": "09:00"
                                    }
                                },
                                "tags": {
                                    "goals": ["提升技能"],
                                    "outputs": ["完成项目"],
                                    "contacts": [],
                                    "locations": ["家里"],
                                    "notes": []
                                },
                                "visibility": {
                                    "start": true,
                                    "duration": true,
                                    "end": true,
                                    "repeat": true
                                }
                            }
                        },
                        {
                            "id": null,
                            "text": "学习JavaScript基础",
                            "done": false,
                            "parentIndex": 0,
                            "level": 1,
                            "isRecurring": false,
                            "details": {}
                        },
                        {
                            "id": null,
                            "text": "练习React框架",
                            "done": false,
                            "parentIndex": 0,
                            "level": 1,
                            "isRecurring": false,
                            "details": {}
                        },
                        {
                            "id": null,
                            "text": "阅读技术文档",
                            "done": false,
                            "parentId": null,
                            "level": 0,
                            "isRecurring": false,
                            "details": {}
                        },
                        {
                            "id": null,
                            "text": "健身运动",
                            "done": false,
                            "parentId": null,
                            "level": 0,
                            "isRecurring": true,
                            "donePlus": {
                                "enabled": true,
                                "notes": [],
                                "subtasks": []
                            },
                            "details": {
                                "isTemplate": false,
                                "recurrence": {
                                    "enabled": true,
                                    "pattern": "每周3次",
                                    "config": {
                                        "days": ["周一", "周三", "周五"],
                                        "time": "18:00"
                                    }
                                },
                                "visibility": {
                                    "start": false,
                                    "duration": false,
                                    "end": false,
                                    "repeat": true
                                }
                            }
                        }
                    ]
                }
            ],
            [
                {
                    "id": null,
                    "title": "全天日程",
                    "meta": {
                        "time": "",
                        "icon": "",
                        "isAllDay": true,
                        "fixed": true,
                        "badge": {
                            "baseDone": 0,
                            "baseTotal": 0,
                            "dDone": 0,
                            "dTotal": 0,
                            "titleNoFrac": "全天日程"
                        }
                    },
                    "tasks": []
                },
                {
                    "title": "👁️ 清洁｜出发 0/5",
                    "meta": {
                        "time": "星期三 10:30-11:30",
                        "icon": "👁️",
                        "badge": {
                            "baseDone": 0,
                            "baseTotal": 4,
                            "dDone": 0,
                            "dTotal": 0,
                            "titleNoFrac": "清洁｜出发"
                        }
                    },
                    "tasks": [
                        {
                            "id": null,
                            "text": "洗漱",
                            "done": false,
                            "parentId": null,
                            "level": 0,
                            "isRecurring": false,
                            "details": {}
                        },
                        {
                            "id": null,
                            "text": "铲屎、喂食、换尿垫",
                            "done": false,
                            "parentId": null,
                            "level": 0,
                            "isRecurring": false,
                            "details": {}
                        },
                        {
                            "id": null,
                            "text": "铲猫砂",
                            "done": false,
                            "parentIndex": 1,
                            "level": 1,
                            "isRecurring": false,
                            "details": {}
                        },
                        {
                            "id": null,
                            "text": "添加猫粮和水",
                            "done": false,
                            "parentIndex": 1,
                            "level": 1,
                            "isRecurring": false,
                            "details": {}
                        },
                        {
                            "id": null,
                            "text": "出发去文心",
                            "done": false,
                            "parentId": null,
                            "level": 0,
                            "isRecurring": false,
                            "details": {}
                        },
                        {
                            "id": null,
                            "text": "出行检查清单模板",
                            "done": false,
                            "parentId": null,
                            "level": 0,
                            "isRecurring": false,
                            "details": {}
                        },
                        {
                            "id": null,
                            "text": "检查钥匙",
                            "done": false,
                            "parentIndex": 5,
                            "level": 1,
                            "isRecurring": false,
                            "details": {}
                        },
                        {
                            "id": null,
                            "text": "检查手机和充电器",
                            "done": false,
                            "parentIndex": 5,
                            "level": 1,
                            "isRecurring": false,
                            "details": {}
                        },
                        {
                            "id": null,
                            "text": "检查钱包和身份证",
                            "done": false,
                            "parentIndex": 5,
                            "level": 1,
                            "isRecurring": false,
                            "details": {}
                        }
                    ],
                    "id": null
                },
                {
                    "title": "👨🏻‍🍼 看午休｜机动 0/5",
                    "meta": {
                        "time": "星期三 11:30—14:00",
                        "icon": "👨🏻‍🍼",
                        "badge": {
                            "baseDone": 0,
                            "baseTotal": 1,
                            "dDone": 0,
                            "dTotal": 0,
                            "titleNoFrac": "看午休｜机动"
                        }
                    },
                    "tasks": [
                        {
                            "id": null,
                            "text": "吃饭",
                            "done": false,
                            "parentId": null,
                            "level": 0,
                            "isRecurring": false,
                            "details": {}
                        }
                    ],
                    "id": null
                },
                {
                    "title": "☕️ 下午茶 0/1",
                    "meta": {
                        "time": "星期三 14：00 - 16：00",
                        "icon": "☕️",
                        "badge": {
                            "baseDone": 0,
                            "baseTotal": 1,
                            "dDone": 0,
                            "dTotal": 0,
                            "titleNoFrac": "下午茶"
                        }
                    },
                    "tasks": [
                        {
                            "id": null,
                            "text": "喝牛奶",
                            "done": false,
                            "parentId": null,
                            "level": 0,
                            "isRecurring": false,
                            "details": {}
                        }
                    ],
                    "id": null
                },
                {
                    "title": "🧑🏻‍🏫 接学生｜上课 0/3",
                    "meta": {
                        "time": "星期三 16:00-20:45",
                        "icon": "🧑🏻‍🏫",
                        "badge": {
                            "baseDone": 0,
                            "baseTotal": 3,
                            "dDone": 0,
                            "dTotal": 0,
                            "titleNoFrac": "接学生｜上课"
                        }
                    },
                    "tasks": [
                        {
                            "id": null,
                            "text": "接学生",
                            "done": false,
                            "parentId": null,
                            "level": 0,
                            "isRecurring": false,
                            "details": {}
                        },
                        {
                            "id": null,
                            "text": "整理练习",
                            "done": false,
                            "parentId": null,
                            "level": 0,
                            "isRecurring": false,
                            "details": {}
                        },
                        {
                            "id": null,
                            "text": "上课",
                            "done": false,
                            "parentId": null,
                            "level": 0,
                            "isRecurring": false,
                            "details": {}
                        }
                    ],
                    "id": null
                }
            ]
        ]

    /**
     * 初始化数据ID
     * 遍历data结构，为所有分区和任务生成唯一ID
     * 同时处理子任务的parentId映射
     */
    function initializeDataIds() {
      data.forEach(section => {
        section.forEach(partition => {
          // 生成分区ID
          partition.id = generatePartitionId();

          // 第一遍：为所有任务生成ID
          partition.tasks.forEach(task => {
            task.id = generateTaskId();
          });

          // 第二遍：处理子任务的父子关系
          partition.tasks.forEach(task => {
            if (task.level > 0 && task.parentIndex !== undefined) {
              // 将parentIndex转换为parentId
              task.parentId = partition.tasks[task.parentIndex].id;
              // 删除临时的parentIndex字段
              delete task.parentIndex;
            }
          });
        });
      });
    }

    // 初始化所有ID
    initializeDataIds();

    /**
     * 可选择的Emoji图标列表
     * @type {Array<string>}
     * @description 用于分区图标选择器的emoji列表，涵盖常用的活动类型图标
     */

    /**
     * ===== 工具函数定义 =====
     */

    /**
     * 计算时间选择器标签最佳位置和三角方向
     * @param {number} clickX - 点击X坐标
     * @param {number} clickY - 点击Y坐标
     * @returns {Object} 位置和方向信息 {x, y, triangleDirection, triangleX}
     */
    function calculateBubblePosition(clickX, clickY) {
      const label = { width: 70, height: 24 }; // 实际标签尺寸
      const screen = { width: window.innerWidth, height: window.innerHeight };
      const margin = 10;

      let labelX, labelY, triangleDirection;

      // 默认在上方显示
      if (clickY > label.height + margin + 50) {
        // 上方有足够空间
        labelY = clickY - label.height - margin;
        triangleDirection = 'down';
      } else {
        // 下方显示
        labelY = clickY + margin;
        triangleDirection = 'up';
      }

      // 水平居中，但避免超出屏幕
      labelX = Math.max(margin, Math.min(clickX - label.width / 2, screen.width - label.width - margin));

      return {
        x: labelX,
        y: labelY,
        triangleDirection,
        triangleX: Math.max(10, Math.min(clickX - labelX, label.width - 10)) // 三角相对于标签的位置
      };
    }

    /**
     * 创建小三角指示器
     * @param {string} direction - 三角方向 (up/down/left/right)
     * @param {number} relativeX - 三角相对于气泡的X位置
     * @returns {HTMLElement} 三角指示器元素
     */
    function createTrianglePointer(direction, relativeX = 50) {
      const triangle = document.createElement('div');
      triangle.className = `triangle-pointer ${direction}`;

      if (direction === 'up' || direction === 'down') {
        triangle.style.left = relativeX + 'px';
      }

      return triangle;
    }

    /**
     * iPhone原生时间选择器 - 正确实现版本
     * @param {number} clickX - 点击X坐标
     * @param {number} clickY - 点击Y坐标
     * @param {string} currentValue - 当前时间值
     * @param {Function} onTimeSelected - 时间选择完成回调
     * @param {Object} options - 可选配置
     */
    function showTimePickerAt(clickX, clickY, currentValue, onTimeSelected, options = {}) {
      // 计算气泡位置
      const position = calculateBubblePosition(clickX, clickY);
      // 获取隐藏输入框容器
      const bucket = document.getElementById('timeInputsBucket');
      if (!bucket) {
        return;
      }
      // 创建真正的时间输入框（完全按照原来的方式）
      const timeInput = document.createElement('input');
      timeInput.type = 'time';
      timeInput.step = options.step || 900;
      timeInput.value = currentValue || '09:00';
      timeInput.className = 'time-input';

      // 关键：确保iPhone识别为时间选择器而不是文本输入
      timeInput.setAttribute('inputmode', 'none');    // 禁止键盘
      timeInput.setAttribute('readonly', 'false');    // 但允许选择器
      timeInput.style.caretColor = 'transparent';     // 隐藏光标

      // 生成唯一ID
      const inputId = `dynamic-time-${generateTaskId()}`;
      timeInput.id = inputId;

      // 放入隐藏容器（关键：使用原有的成功方式）
      bucket.appendChild(timeInput);

      // 创建真正的label（完全按照原来的方式）
      const label = document.createElement('label');
      label.setAttribute('for', inputId);
      label.className = 'clickable-time time-pill';
      label.textContent = currentValue;
      label.style.cursor = 'pointer';

      // 将label定位到与气泡指示器相同的位置
      Object.assign(label.style, {
        position: 'fixed',
        left: position.x + 'px',
        top: position.y + 'px',
        zIndex: '10001',
        // 保持原有的视觉样式，增强可点击性
        background: '#007aff',
        color: '#fff',
        border: '1px solid #007aff',
        borderRadius: '999px',
        padding: '4px 12px',
        height: '24px',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        fontSize: '12px',
        fontWeight: '500',
        minWidth: '60px',
        boxShadow: '0 2px 8px rgba(0,122,255,0.3)',
        // iPhone触控优化
        '-webkit-user-select': 'none',
        'user-select': 'none',
        'touch-action': 'manipulation',
        // 确保可见和可点击
        opacity: '1',
        pointerEvents: 'auto'
      });

      // 创建气泡指示器
      const indicator = document.createElement('div');
      indicator.className = 'time-picker-indicator';
      indicator.style.left = position.x + 'px';
      indicator.style.top = position.y + 'px';

      const bubble = document.createElement('div');
      bubble.className = 'time-picker-bubble';
      bubble.textContent = `点击选择时间`;

      const triangle = createTrianglePointer(position.triangleDirection, position.triangleX);
      bubble.appendChild(triangle);
      indicator.appendChild(bubble);

      // 插入元素
      document.body.appendChild(label);
      document.body.appendChild(indicator);

      // 处理时间变化
      const handleTimeChange = () => {
        const selectedTime = timeInput.value;
        const alignedTime = roundToQuarter(selectedTime);
        // 更新视觉
        label.textContent = alignedTime;
        bubble.textContent = `已选择 ${alignedTime}`;

        // 延迟清理并回调
        setTimeout(() => {
          cleanup();
          if (typeof onTimeSelected === 'function') {
            onTimeSelected(alignedTime);
          }
        }, 1000);
      };

      // 清理函数
      const cleanup = () => {
        [timeInput, label, indicator].forEach(el => {
          if (el && el.parentNode) {
            el.parentNode.removeChild(el);
          }
        });
      };

      // 监听时间变化
      timeInput.addEventListener('change', handleTimeChange);

      // 点击外部取消
      const handleOutsideClick = (e) => {
        if (!label.contains(e.target) && !indicator.contains(e.target)) {
          document.removeEventListener('click', handleOutsideClick, true);
          cleanup();
        }
      };

      setTimeout(() => {
        document.addEventListener('click', handleOutsideClick, true);
      }, 300);

      // 超时清理
      setTimeout(() => {
        if (timeInput.parentNode) {
          cleanup();
        }
      }, 30000);
    }

    /**
     * 获取字符串的第一个字符
     * @param {string} s - 输入字符串
     * @returns {string} 第一个字符，如果字符串为空则返回空字符串
     */
    const firstCodePoint = s => (s&&s.length)?s[0]:'';

    /**
     * 将数字补零到两位数
     * @param {number} n - 输入数字
     * @returns {string} 补零后的两位数字符串
     */
    const pad2 = n => n<10?('0'+n):''+n;

    /**
     * 将数值限制在指定范围内
     * @param {number} v - 待限制的值
     * @param {number} min - 最小值
     * @param {number} max - 最大值
     * @returns {number} 限制后的值
     */
    const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));

    /**
     * 时间换算：支持跨零点（来自old.html）
     */
    function toMin(hhmm){
      const [h,m]=hhmm.split(':').map(n=>parseInt(n,10));
      return (h*60+m)%1440;
    }

    function fromMin(mins){
      const m=((mins%1440)+1440)%1440;
      const h=Math.floor(m/60);
      const mm=m%60;
      return String(h).padStart(2,'0')+':'+String(mm).padStart(2,'0');
    }

    /**
     * 将时间字符串对齐到最近的15分钟间隔
     * @param {string} hhmm - 时间字符串，格式如 "14:30" 或 "14：30"
     * @returns {string} 对齐后的时间字符串，格式为 "HH:mm"
     * @description 支持中英文冒号，自动处理小时进位
     */
    function roundToQuarter(hhmm){
      const m=(hhmm||'').match(/^(\d{1,2})[:：](\d{2})$/); if(!m) return '00:00';
      let h=clamp(parseInt(m[1],10),0,23), mins=clamp(parseInt(m[2],10),0,59);
      const q=Math.round(mins/15)*15; if(q===60){h=(h+1)%24; mins=0}else{mins=q}
      return `${pad2(h)}:${pad2(mins)}`
    }

    /**
     * 从标题中去除指定的emoji前缀
     * @param {string} title - 原标题
     * @param {string} icon - 要去除的emoji图标
     * @returns {string} 去除emoji后的标题（已去除首尾空格）
     */
    function stripLeadingEmojiByIcon(title, icon){
      return (icon && title.indexOf(icon)===0) ? title.slice(icon.length).trimStart() : (title||'').trimStart();
    }

    /**
     * 从文本中去除星期几信息
     * @param {string} txt - 输入文本
     * @returns {string} 去除星期几后的文本
     * @description 支持"星期X"和"周X"两种格式
     */
    function stripWeekday(txt){
      return (txt||'').replace(/\s*(?:星期|周)[一二三四五六日天]\s*/g,' ').trim()
    }

    /**
     * 解析标题中的完成进度分数（如 "任务名 2/5"）
     * @param {string} plainTitle - 纯文本标题
     * @returns {{titleNoFrac: string, baseDone: number|null, baseTotal: number|null}} 解析结果
     * @description 返回不含分数的标题和分数信息
     */
    function parseTitleFraction(plainTitle){
      const m=(plainTitle||'').match(/(.*?)(?:\s*[｜|]\s*)?(\d+)\s*\/\s*(\d+)\s*$/);
      if(!m) return { titleNoFrac:(plainTitle||'').trim(), baseDone:null, baseTotal:null };
      const t=(m[1]||plainTitle||'').trim();
      return { titleNoFrac:t, baseDone:parseInt(m[2],10), baseTotal:parseInt(m[3],10) };
    }

    /**
     * 确保分区数据具有徽标元数据
     * @param {Object} partition - 分区数据对象
     * @param {string} plainTitle - 纯文本标题
     * @returns {Object} 徽标元数据对象
     * @description 如果不存在badge元数据，则根据标题解析创建默认值
     */
    /**
     * 确保分区的徽标元数据存在
     * @param {Object} partition - 分区对象
     * @param {string} plainTitle - 分区标题
     * @returns {Object} 徽标元数据对象
     * @description 初始化徽标元数据，baseTotal只计算level为0的父任务数量
     */
    function ensureBadgeMeta(partition, plainTitle){
      partition.meta = partition.meta || {};
      if(!partition.meta.badge){
        const {titleNoFrac, baseDone, baseTotal} = parseTitleFraction(plainTitle);
        const parentTaskCount = (partition.tasks||[]).filter(t => t.level === 0).length;
        partition.meta.badge = {
          baseDone: baseDone ?? 0,
          baseTotal: baseTotal ?? parentTaskCount,
          dDone: 0,
          dTotal: 0,
          titleNoFrac
        };
      }
      return partition.meta.badge;
    }

    /**
     * 将十六进制颜色转换为RGB对象
     * @param {string} hex - 十六进制颜色值（带或不带#前缀）
     * @returns {{r: number, g: number, b: number}} RGB颜色对象
     * @description 支持3位和6位十六进制格式
     */
    function hexToRgb(hex){
      const m=(hex||'').replace('#','').match(/^([0-9a-f]{6}|[0-9a-f]{3})$/i); if(!m) return {r:0,g:0,b:0};
      let s=m[1]; if(s.length===3){ s=s.split('').map(c=>c+c).join(''); }
      const n=parseInt(s,16); return {r:(n>>16)&255,g:(n>>8)&255,b:n&255};
    }

    /**
     * 将十六进制颜色转换为带透明度的RGBA字符串
     * @param {string} hex - 十六进制颜色值
     * @param {number} [a=0.12] - 透明度值（0-1）
     * @returns {string} RGBA颜色字符串
     */
    function softColor(hex, a=0.12){ const {r,g,b}=hexToRgb(hex); return `rgba(${r},${g},${b},${a})`; }

    /**
     * 根据图标获取对应的竖条颜色
     * @param {string|Object} iconOrPartition - emoji字符串或分区数据对象
     * @param {string} computedTitle - 计算后的标题
     * @returns {string} 对应的颜色值
     * @description 为不同类型的活动提供预设的主题色
     */
    function getStripeColor(iconOrPartition, computedTitle){
      const icon = typeof iconOrPartition==='string' ? iconOrPartition :
        ((iconOrPartition.meta&&iconOrPartition.meta.icon) || firstCodePoint(computedTitle));
      const map={"📋":"#5AC8FA","👁️":"#34C759","👨🏻‍🍼":"#AF52DE","☕️":"#FF9500","🧑🏻‍🏫":"#FF2D55","🗓️":"#007AFF","🛋️":"#8E8E93"};
      return map[icon] || getComputedStyle(document.documentElement).getPropertyValue('--stripe-default') || '#C7C7CC';
    }

    /**
     * 解析时间范围字符串
     * @param {string} raw - 原始时间字符串，如 "星期三 10:30-11:30"
     * @returns {Object|null} 解析结果对象或null
     * @description 返回 {prefix, start, end, suffix} 格式的对象
     */
    function parseTimeRange(raw){
      if(!raw) return null;
      const RE=/(\d{1,2})[:：](\d{2})\s*[-–—]\s*(\d{1,2})[:：](\d{2})/;
      const m=raw.match(RE); if(!m) return null;
      const idx=m.index;
      const prefix=stripWeekday(raw.slice(0,idx).replace(/\s*$/,''));
      const suffix=raw.slice(idx+m[0].length);
      const start=`${pad2(parseInt(m[1],10))}:${pad2(parseInt(m[2],10))}`;
      const end=`${pad2(parseInt(m[3],10))}:${pad2(parseInt(m[4],10))}`;
      return {prefix,start,end,suffix};
    }

    /**
     * 获取分区的开始时间（以分钟为单位）
     * @param {Object} partition - 分区数据对象
     * @returns {number} 开始时间的分钟数，如果没有时间则返回无穷大
     * @description 用于分区排序，将时间转换为从午夜开始的分钟数
     */
    function getStartMinutes(partition){
      const t=parseTimeRange(partition?.meta?.time||'');
      if(!t) return Number.POSITIVE_INFINITY;
      const [hh,mm]=t.start.split(':').map(n=>parseInt(n,10));
      return hh*60+mm;
    }

    /**
     * 按时间顺序排序日程分区
     * @description 只对日程分区进行排序，待办事项分区不参与排序
     */
    function sortSchedulesByTime(){
      data[1].sort((a, b) => {
        // 全天日程分区始终排在第一位
        if (isAllDaySchedule(a)) return -1;
        if (isAllDaySchedule(b)) return 1;

        // 其他分区按时间排序
        return getStartMinutes(a) - getStartMinutes(b);
      });
    }

    /**
     * ===== 数据访问重构函数（二维数组版本） =====
     */

    /**
     * 根据ID查找分区
     * @param {string} id - 分区ID
     * @returns {Object|null} 分区对象，如果未找到返回null
     */
    function findPartitionById(id) {
      // 先在待办事项数组中查找
      const todoPartition = data[0].find(partition => partition.id === id);
      if (todoPartition) return todoPartition;

      // 再在日程分区数组中查找
      const schedulePartition = data[1].find(partition => partition.id === id);
      return schedulePartition || null;
    }

    /**
     * 获取待办事项分区
     * @returns {Object|null} 待办事项分区对象
     */
    function getTodoPartition() {

      return getTodoPartitions()[0] || null;
    }

    /**
     * 获取所有待办事项分区
     * @returns {Array} 待办事项分区数组
     */
    function getTodoPartitions() {
      return data[0] || [];
    }

    /**
     * 判断分区是否为待办分区
     * @param {Object} partition - 分区对象
     * @returns {boolean} 是否为待办分区
     */
    function isTodoPartitionObject(partition) {
      return partition && (
        partition.meta?.isTodoPartition === true ||
        partition.title?.includes('待办') ||
        partition.meta?.icon === '📋'
      );
    }

    /**
     * 获取所有日程分区
     * @returns {Array} 日程分区数组
     */
    function getSchedulePartitions() {
      return data[1] || [];
    }

    /**
     * 判断分区所属的大分区类型
     * @param {string} partitionId - 分区ID
     * @returns {string} 'todo' | 'schedule' | 'unknown'
     */
    function getPartitionType(partitionId) {
      if (getTodoPartitions().some(p => p.id === partitionId)) {
        return 'todo';
      }
      if (getSchedulePartitions().some(p => p.id === partitionId)) {
        return 'schedule';
      }
      return 'unknown';
    }

    /**
     * 判断两个分区是否属于同一个大分区
     * @param {string} fromId - 源分区ID
     * @param {string} toId - 目标分区ID
     * @returns {boolean} 是否属于同一大分区
     */
    function isSameMajorPartition(fromId, toId) {
      const fromType = getPartitionType(fromId);
      const toType = getPartitionType(toId);
      return fromType !== 'unknown' && fromType === toType;
    }

    /**
     * 根据ID获取对应的任务列表
     * @param {string} id - 分区ID
     * @returns {Array} 任务列表数组
     * @description 获取分区的任务列表，如果分区不存在则返回空数组，不再自动创建
     */
    function getTasksById(id){
      let partition = findPartitionById(id);
      if (!partition) {
        // 不再自动创建分区，直接返回空数组
        return [];
      }
      return partition.tasks;
    }

    /**
     * 创建新日程分区
     * @param {string} title - 分区标题
     * @param {Object} [meta={}] - 分区元数据
     * @returns {Object} 新创建的分区对象
     */
    function createSchedulePartition(title, meta = {}) {
      const id = generatePartitionId();
      const partition = {
        id,
        title,
        meta: { icon: "🗓️", time: "09:00 - 10:00", ...meta },
        tasks: []  // 不再创建默认任务
      };
      data[1].push(partition);
      return partition;
    }

    /**
     * 确保全天日程分区存在
     * @description 检查并创建全天日程分区，确保它始终在日程分区数组的第一位
     */
    function ensureAllDayScheduleExists() {
      const schedulePartitions = getSchedulePartitions();

      // 检查是否已存在全天日程分区
      const allDayPartition = schedulePartitions.find(p => p.meta?.isAllDay);

      if (!allDayPartition) {
        // 创建全天日程分区
        const allDaySchedule = {
          id: "allday_schedule",
          title: "全天日程",
          meta: {
            time: "",
            icon: "",
            isAllDay: true,
            fixed: true,
            badge: { baseDone: 0, baseTotal: 0, dDone: 0, dTotal: 0, titleNoFrac: "全天日程" }
          },
          tasks: []
        };

        // 插入到日程分区数组的开头
        data[1].unshift(allDaySchedule);
      } else {
        // 确保全天日程分区在第一位
        const index = schedulePartitions.indexOf(allDayPartition);
        if (index > 0) {
          // 移动到第一位
          schedulePartitions.splice(index, 1);
          schedulePartitions.unshift(allDayPartition);
        }
      }
    }

    /**
     * 判断分区是否为全天日程
     * @param {Object} partition - 分区对象
     * @returns {boolean} 是否为全天日程分区
     */
    function isAllDaySchedule(partition) {
      return partition && partition.meta && partition.meta.isAllDay === true;
    }

    /**
     * 判断分区是否为待办事项
     * @param {string} id - 分区ID
     * @returns {boolean} 是否为待办事项
     */
    function isTodoPartition(id) {
      const partition = findPartitionById(id);
      if (!partition) return false;

      // 首先检查是否在待办分区数组 data[0] 中
      const todoPartitions = getTodoPartitions();
      const isInTodoArray = todoPartitions.some(p => p.id === id || p === partition);

      if (isInTodoArray) return true;

      // 备用判断：通过标题和图标判断
      return partition.title?.includes('待办') ||
             partition.meta?.icon === '📋' ||
             partition.meta?.isTodoPartition === true;
    }

    /**
     * ===== 组件化系统 =====
     */

    /**
     * 任务组件 - 管理单个任务的DOM和状态
     */
    class TaskComponent {
      constructor(taskData, partitionId) {
        this.taskData = taskData;
        this.partitionId = partitionId;
        this.element = null;
        this.inputElement = null;
        this.checkboxElement = null;
        this.isEditing = false;

        // 绑定方法
        this.handleEdit = this.handleEdit.bind(this);
        this.handleSave = this.handleSave.bind(this);
        this.handleToggleDone = this.handleToggleDone.bind(this);
        this.handleKeyDown = this.handleKeyDown.bind(this);
      }

      /**
       * 创建任务DOM元素
       * @returns {HTMLElement}
       */
      createElement() {
        if (this.element) {
          return this.element;
        }

        const wrap = document.createElement('div');
        wrap.className = 'task-wrapper';
        wrap.dataset.taskId = this.taskData.id;

        const del = document.createElement('div');
        del.className = 'task-delete';
        del.textContent = '删除';

        const row = document.createElement('div');
        row.className = 'task';

        const box = document.createElement('div');
        box.className = 'checkbox' + (this.taskData.done ? ' done' : '');
        box.onclick = this.handleToggleDone;

        const txt = document.createElement('div');
        txt.className = 'task-input';
        txt.contentEditable = 'true';
        txt.textContent = this.taskData.text || '';
        txt.onclick = this.handleEdit;
        txt.onblur = this.handleSave;
        txt.addEventListener('keydown', this.handleKeyDown);

        const handle = document.createElement('div');
        handle.className = 'task-handle';
        handle.textContent = '≡';
        handle.onclick = () => {
          currentTask = this.taskData;
          currentPartitionId = this.partitionId;
          showEditModal(this.taskData, this.partitionId);
        };

        // 组装DOM
        row.appendChild(box);
        row.appendChild(txt);
        row.appendChild(handle);
        wrap.appendChild(del);
        wrap.appendChild(row);

        // 缓存引用
        this.element = wrap;
        this.inputElement = txt;
        this.checkboxElement = box;

        // 缓存到DOM管理器
        domManager.cache(`task-${this.taskData.id}`, wrap);

        return wrap;
      }

      /**
       * 更新任务数据和DOM
       * @param {Object} newData - 新的任务数据
       */
      update(newData) {
        if (!this.element || !this.element.isConnected) {
          return;
        }

        const hasChanges =
          this.taskData.text !== newData.text ||
          this.taskData.done !== newData.done;

        if (!hasChanges) {
          return;
        }

        this.taskData = { ...newData };

        domManager.safeUpdate(this.element, () => {
          // 更新文本（如果不在编辑状态）
          if (!this.isEditing && this.inputElement.textContent !== this.taskData.text) {
            this.inputElement.textContent = this.taskData.text;
          }

          // 更新复选框状态
          if (this.taskData.done) {
            this.checkboxElement.classList.add('done');
          } else {
            this.checkboxElement.classList.remove('done');
          }
        });
      }

      /**
       * 处理任务编辑
       */
      handleEdit() {
        this.isEditing = true;
        this.inputElement.classList.add('expanded');
      }

      /**
       * 处理任务保存
       */
      handleSave() {
        this.isEditing = false;
        this.inputElement.classList.remove('expanded');

        const newText = (this.inputElement.textContent || '').trim();
        if (newText !== this.taskData.text) {
          this.taskData.text = newText;
          stateManager.emit(`task-updated-${this.taskData.id}`, {
            taskId: this.taskData.id,
            partitionId: this.partitionId,
            text: newText
          });
        }
      }

      /**
       * 处理任务完成状态切换
       */
      handleToggleDone() {
        this.taskData.done = !this.taskData.done;
        this.update(this.taskData);

        stateManager.emit(`task-toggled-${this.taskData.id}`, {
          taskId: this.taskData.id,
          partitionId: this.partitionId,
          done: this.taskData.done
        });
      }

      /**
       * 在当前任务下方创建新任务并聚焦
       */
      createNewTaskBelow() {
        // 获取分区信息
        const partition = findPartitionById(this.partitionId);
        if (!partition || !partition.tasks) return;

        // 找到当前任务在分区中的索引
        const currentIndex = partition.tasks.findIndex(t => t.id === this.taskData.id);
        if (currentIndex === -1) return;

        // 创建新任务
        const newTask = {
          id: generateTaskId(),
          text: '',
          done: false,
          parentId: this.taskData.parentId,  // 继承父任务关系
          level: this.taskData.level        // 继承层级
        };

        // 在当前任务下方插入新任务
        const insertIndex = currentIndex + 1;
        partition.tasks.splice(insertIndex, 0, newTask);

        // 更新徽标计数
        if (partition.meta?.badge && newTask.level === 0) {
          partition.meta.badge.dTotal = (partition.meta.badge.dTotal || 0) + 1;
        }

        // 保存新任务ID，用于渲染后聚焦
        this.__newTaskId = newTask.id;

        // 重新渲染
        sortSchedulesByTime();
        renderTodo(true);
        renderSchedules(true);

        // 延迟聚焦到新创建的任务
        setTimeout(() => {
          this.focusToTask(newTask.id);
        }, 100);
      }

      /**
       * 聚焦到指定任务
       * @param {string} taskId - 任务ID
       */
      focusToTask(taskId) {
        // 查找新任务的输入框
        const taskElement = document.querySelector(`[data-task-id="${taskId}"] .task-input`);
        if (taskElement) {
          // 清除可能存在的内联样式
          taskElement.style.cssText = '';

          // 使用CSS类进行样式修复，避免内联样式的时序问题
          taskElement.classList.add('expanded', 'expanded-fixed');

          // 关键：添加正常的点击处理逻辑，与原有任务保持一致
          taskElement.onclick = () => {
            taskElement.classList.add('expanded', 'expanded-fixed');
            taskElement.focus();
          };

          // 关键：添加失焦事件处理，与原有逻辑保持一致
          const handleBlur = () => {
            taskElement.classList.remove('expanded', 'expanded-fixed');
            // 保存任务文本内容（如果需要的话）
            const taskResult = findTaskById(taskId);
            if (taskResult && taskResult.task) {
              taskResult.task.text = (taskElement.textContent || '').trim();
            }
          };

          // 使用 { once: true } 确保只执行一次，避免重复绑定
          taskElement.addEventListener('blur', handleBlur, { once: true });

          taskElement.focus();
          taskElement.scrollIntoView({ block: 'nearest', inline: 'nearest' });

          // 选中文本内容（虽然是空的，但为了更好的用户体验）
          const selection = window.getSelection();
          const range = document.createRange();
          range.selectNodeContents(taskElement);
          selection.removeAllRanges();
          selection.addRange(range);
        }
      }

      /**
       * 处理键盘事件
       * @param {KeyboardEvent} e
       */
      handleKeyDown(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          // 保存当前任务
          this.handleSave();

          // 创建新任务并聚焦
          this.createNewTaskBelow();
        } else if (e.key === 'Escape') {
          e.preventDefault();
          this.inputElement.textContent = this.taskData.text;
          this.inputElement.blur();
        }
      }

      /**
       * 销毁组件
       */
      destroy() {
        if (this.element && this.element.parentNode) {
          this.element.parentNode.removeChild(this.element);
        }
        this.element = null;
        this.inputElement = null;
        this.checkboxElement = null;
      }
    }

    /**
     * 占位符任务组件 - 用于添加新任务
     */
    class PlaceholderTaskComponent {
      constructor(partitionId) {
        this.partitionId = partitionId;
        this.element = null;
        this.inputElement = null;

        // 绑定方法
        this.handleCommit = this.handleCommit.bind(this);
        this.handleKeyDown = this.handleKeyDown.bind(this);
        this.handleFocus = this.handleFocus.bind(this);
      }

      /**
       * 创建占位符DOM元素
       * @returns {HTMLElement}
       */
      createElement() {
        if (this.element) {
          return this.element;
        }

        const wrap = document.createElement('div');
        wrap.className = 'task-wrapper placeholder-row';

        const del = document.createElement('div');
        del.className = 'task-delete';
        del.textContent = '删除';
        del.style.display = 'none';

        const row = document.createElement('div');
        row.className = 'task';

        const box = document.createElement('div');
        box.className = 'checkbox placeholder';
        box.onclick = this.handleFocus;

        const txt = document.createElement('div');
        txt.className = 'task-input';
        txt.contentEditable = 'true';
        txt.addEventListener('keydown', this.handleKeyDown);
        txt.addEventListener('blur', this.handleCommit);

        const handle = document.createElement('div');
        handle.className = 'task-handle';
        handle.textContent = '≡';

        // 组装DOM
        row.appendChild(box);
        row.appendChild(txt);
        row.appendChild(handle);
        wrap.appendChild(del);
        wrap.appendChild(row);

        // 点击任何地方聚焦到输入框
        wrap.addEventListener('click', (e) => {
          if (e.target !== txt) txt.focus();
        });

        // 缓存引用
        this.element = wrap;
        this.inputElement = txt;

        return wrap;
      }

      /**
       * 处理新任务提交
       */
      handleCommit() {
        const text = (this.inputElement.textContent || '').trim();
        if (!text) return;

        // 发送新增任务事件
        stateManager.emit(`task-add-${this.partitionId}`, {
          partitionId: this.partitionId,
          text: text
        });

        // 清空输入框
        this.inputElement.textContent = '';
      }

      /**
       * 处理键盘事件
       * @param {KeyboardEvent} e
       */
      handleKeyDown(e) {
        if (e.key === 'Enter') {
          e.preventDefault();
          this.handleCommit();
        } else if (e.key === 'Escape') {
          e.preventDefault();
          this.inputElement.blur();
        }
      }

      /**
       * 处理聚焦
       */
      handleFocus() {
        this.inputElement.focus();
      }

      /**
       * 聚焦到输入框
       */
      focus() {
        if (this.inputElement) {
          this.inputElement.focus();
          this.inputElement.scrollIntoView({ block: 'nearest', inline: 'nearest' });
        }
      }
    }


    /**
     * 根据任务ID查找任务及其所属分区
     * @param {string} taskId - 任务ID
     * @returns {{partition: Object, task: Object, index: number}|null} 查找结果
     */
    function findTaskById(taskId) {
      // 在所有待办事项中查找
      const todoPartitions = getTodoPartitions();
      for (const partition of todoPartitions) {
        const taskIndex = partition.tasks.findIndex(task => task.id === taskId);
        if (taskIndex !== -1) {
          const task = partition.tasks[taskIndex];
          return {
            partition: partition,
            task: task,
            index: taskIndex
          };
        }
      }

      // 在日程分区中查找
      const schedulePartitions = getSchedulePartitions();
      for (const partition of schedulePartitions) {
        const taskIndex = partition.tasks.findIndex(task => task.id === taskId);
        if (taskIndex !== -1) {
          return {
            partition: partition,
            task: partition.tasks[taskIndex],
            index: taskIndex
          };
        }
      }

      return null;
    }

    /**
     * ===== 增量更新核心逻辑 =====
     */

    /**
     * 增量更新管理器
     */
    class IncrementalUpdater {
      constructor() {
        this.taskComponents = new Map(); // 任务组件缓存
        this.placeholderComponents = new Map(); // 占位符组件缓存
        this.initialized = false;

        // 绑定事件监听
        this.setupEventListeners();
      }

      /**
       * 设置事件监听器
       */
      setupEventListeners() {
        // 删除事件委托
        document.body.addEventListener('click', (event) => {
          if (event.target.classList.contains('task-delete')) {
            this.handleDeleteClick(event);
          }
        }, true);

        // 监听数据变化事件
        stateManager.subscribe('task-delete', (data) => {
          this.removeTask(data.taskId);
        });

        // 监听所有分区的任务添加事件
        const setupAddListeners = () => {
          // 待办事项添加监听
          stateManager.subscribe('task-add-todo', (data) => {
            this.addTask(data.partitionId, data.text);
          });

          // 日程分区添加监听
          getSchedulePartitions().forEach(partition => {
            stateManager.subscribe(`task-add-${partition.id}`, (data) => {
              this.addTask(data.partitionId, data.text);
            });
          });
        };

        // 初始设置监听器
        setupAddListeners();

        // 每次渲染后重新设置监听器（处理新分区）
        stateManager.subscribe('render-complete', setupAddListeners);

        stateManager.subscribe('partition-toggle', (data) => {
          this.togglePartition(data.partitionId);
        });
      }

      /**
       * 处理删除按钮点击
       */
      handleDeleteClick(event) {
        event.stopPropagation();
        event.preventDefault();

        const taskWrapper = event.target.closest('.task-wrapper');
        if (!taskWrapper || !taskWrapper.dataset.taskId) {
          return;
        }

        const taskId = taskWrapper.dataset.taskId;

        // 发送删除事件
        stateManager.emit('task-delete', { taskId });
      }

      /**
       * 增量删除任务
       * @param {string} taskId - 任务ID
       */
      removeTask(taskId) {
        // 从数据中删除
        if (deleteTaskById(taskId)) {
          // 从组件缓存中移除并销毁DOM
          const component = this.taskComponents.get(taskId);
          if (component) {
            component.destroy();
            this.taskComponents.delete(taskId);
          }

          // 更新相关的徽标显示
          this.updatePartitionBadges();
        }
      }

      /**
       * 增量添加任务
       * @param {string} partitionId - 分区ID
       * @param {string} text - 任务文本
       */
      addTask(partitionId, text) {

        // 创建新任务数据
        const newTask = {
          id: generateTaskId(),
          text: text,
          done: false,
          level: 0,
          parentId: null
        };

        // 直接添加到对应的数据数组中
        if (partitionId === 'todo') {
          const todoPartition = getTodoPartition();
          if (todoPartition) {
            todoPartition.tasks.push(newTask);
          }
        } else {
          const partition = findPartitionById(partitionId);
          if (partition) {
            partition.tasks.push(newTask);

            // 更新徽标计数（仅父任务，使用dTotal统计动态添加的任务）
            if (partition.meta?.badge && newTask.level === 0) {
              partition.meta.badge.dTotal = (partition.meta.badge.dTotal || 0) + 1;
            }
          } else {
            return;
          }
        }

        // 创建任务组件
        const component = new TaskComponent(newTask, partitionId);
        this.taskComponents.set(newTask.id, component);

        // 找到对应的任务列表容器
        const listElement = document.querySelector(`.task-list[data-id="${partitionId}"]`);
        const placeholderElement = listElement?.querySelector('.placeholder-row');

        if (listElement && placeholderElement) {
          // 在占位符前插入新任务
          const taskElement = component.createElement();

          // 绑定滑动删除
          const taskRow = taskElement.querySelector('.task');
          const deleteBtn = taskElement.querySelector('.task-delete');
          if (taskRow && deleteBtn) {
            attachSwipeToDelete(taskRow, deleteBtn);
          }

          listElement.insertBefore(taskElement, placeholderElement);

          // 更新徽标显示
          this.updatePartitionBadges();

          // 聚焦到占位符
          const placeholder = this.placeholderComponents.get(partitionId);
          if (placeholder) {
            setTimeout(() => placeholder.focus(), 50);
          }
        } else {
        }
      }

      /**
       * 更新分区徽标显示
       */
      updatePartitionBadges() {
        getSchedulePartitions().forEach(partition => {
          const badge = partition.meta?.badge;
          if (badge) {
            const badgeElement = document.querySelector(`[data-id="${partition.id}"] .badge`);
            if (badgeElement) {
              const numsDone = (badge.baseDone || 0) + (badge.dDone || 0);
              const numsTotal = (badge.baseTotal || 0) + (badge.dTotal || 0);
              domManager.safeUpdate(badgeElement, () => {
                badgeElement.textContent = `${numsDone}/${numsTotal}`;
              });
            }
          }
        });
      }

      /**
       * 切换分区折叠状态
       * @param {string} partitionId - 分区ID
       */
      togglePartition(partitionId) {
        const partition = findPartitionById(partitionId);
        if (partition) {
          partition.meta = partition.meta || {};
          partition.meta.collapsed = !partition.meta.collapsed;

          const listElement = document.querySelector(`.task-list[data-id="${partitionId}"]`);
          const badgeElement = document.querySelector(`[data-id="${partitionId}"] .badge`);

          if (listElement && badgeElement) {
            domManager.safeUpdate(listElement, () => {
              listElement.classList.toggle('collapsed', partition.meta.collapsed);
              badgeElement.classList.toggle('is-collapsed', partition.meta.collapsed);
            });
          }
        }
      }

      /**
       * 初始化组件系统
       */
      init() {
        if (this.initialized) return;
        // 只进行一次完整渲染来建立DOM结构
        this.fullRender();
        // 设置数据监听
        this.setupDataListeners();
        this.initialized = true;
      }

      /**
       * 执行一次完整渲染（仅初始化时使用）
       */
      fullRender() {
        // 使用原有的render函数进行初始化
        render(!!window.Sortable);
        // 建立组件映射
        this.buildComponentMap();
      }

      /**
       * 建立组件映射
       */
      buildComponentMap() {
        // 清空现有映射
        this.taskComponents.clear();
        this.placeholderComponents.clear();

        // 映射待办任务
        const todoPartition = getTodoPartition();
        if (todoPartition) {
          todoPartition.tasks.forEach(task => {
            const component = new TaskComponent(task, 'todo');
            this.taskComponents.set(task.id, component);
          });
        }

        // 映射日程任务
        getSchedulePartitions().forEach(partition => {
          partition.tasks.forEach(task => {
            const component = new TaskComponent(task, partition.id);
            this.taskComponents.set(task.id, component);
          });

          // 创建占位符组件
          const placeholder = new PlaceholderTaskComponent(partition.id);
          this.placeholderComponents.set(partition.id, placeholder);
        });
      }

      /**
       * 设置数据监听器
       */
      setupDataListeners() {
        // 监听各种数据变化事件...
        // 这里会添加更多监听器
      }
    }

    // 全局增量更新管理器实例
    const incrementalUpdater = new IncrementalUpdater();

    /**
     * 简化版删除函数（直接操作DOM和数据）
     * @param {string} taskId - 任务ID
     * @returns {boolean} 删除是否成功
     */
    function deleteTaskById(taskId) {
      // 先找到DOM元素
      const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
      if (!taskElement) {
        return false;
      }

      // 从DOM获取分区信息
      const listElement = taskElement.closest('.task-list');
      if (!listElement) {
        return false;
      }

      const partitionId = listElement.dataset.id;

      // 在数据中查找并删除
      let taskDeleted = false;
      let deletedTaskText = '';

      const partition = findPartitionById(partitionId);
      if (partition) {
        const taskIndex = partition.tasks.findIndex(task => task.id === taskId);
        if (taskIndex !== -1) {
          const taskToDelete = partition.tasks[taskIndex];
          deletedTaskText = taskToDelete.text;

          // 如果是父任务，先删除所有子任务
          if (taskToDelete.level === 0) {
            const childTasks = partition.tasks.filter(t => t.parentId === taskId);
            childTasks.forEach(childTask => {
              // 删除子任务的DOM
              const childElement = document.querySelector(`[data-task-id="${childTask.id}"]`);
              if (childElement) {
                childElement.remove();
              }
              // 从数据中删除子任务
              const childIndex = partition.tasks.findIndex(t => t.id === childTask.id);
              if (childIndex !== -1) {
                partition.tasks.splice(childIndex, 1);
              }
            });
          }

          // 更新徽标计数（仅父任务）
          if (partition.meta?.badge && taskToDelete.level === 0) {
            const badge = partition.meta.badge;
            // 所有分区都使用 baseTotal（初始任务数）
            badge.baseTotal = Math.max(0, (badge.baseTotal || 0) - 1);
            if (taskToDelete.done) {
              badge.baseDone = Math.max(0, (badge.baseDone || 0) - 1);
            }
          }

          partition.tasks.splice(taskIndex, 1);
          taskDeleted = true;
        }
      }

      // 如果数据删除成功，移除DOM元素
      if (taskDeleted) {
        taskElement.remove();

        // 更新分区徽标显示（所有分区）
        const badgeElement = document.querySelector(`[data-id="${partitionId}"] .badge`);
        if (badgeElement && partition?.meta?.badge) {
          const badge = partition.meta.badge;
          const numsDone = (badge.baseDone || 0) + (badge.dDone || 0);
          const numsTotal = (badge.baseTotal || 0) + (badge.dTotal || 0);
          badgeElement.textContent = `${numsDone}/${numsTotal}`;
        }
        return true;
      }
      return false;
    }

    /**
     * ===== 日期和界面渲染函数 =====
     */

    /**
     * 格式化中文日期显示
     * @returns {string} 中文格式的日期字符串，如 "9月14日-星期六"
     */
    function formatChineseDate(){
      const now=new Date();
      const m=now.getMonth()+1, d=now.getDate();
      const wd=['星期日','星期一','星期二','星期三','星期四','星期五','星期六'][now.getDay()];
      return `${m}月${d}日-${wd}`;
    }

    /**
     * 渲染顶部页眉的日期显示
     * @description 立即执行函数，更新页眉中的日期文本
     */
    (function renderHeaderDate(){
      const txt=formatChineseDate();
      const elSmall=document.getElementById('headerDate');
      const elBig=document.getElementById('headerDateBig');
      if(elSmall) elSmall.textContent=txt;
      if(elBig) elBig.textContent=txt;
    })();

    /**
     * ===== 触控交互事件处理函数 =====
     */

    /**
     * 为任务元素绑定滑动手势功能
     * @param {HTMLElement} taskEl - 任务元素
     * @param {HTMLElement} delEl - 删除按钮元素
     * @description 实现iOS提醒事项风格的滑动交互：左滑删除，右滑缩进/减少缩进
     */
    function attachSwipeToDelete(taskEl, delEl){
      let startX=0, currentX=0, swiped=false, swipeDirection='', lockedDirection='';
      const wrapper = taskEl.closest('.task-wrapper');
      const actionsEl = wrapper.querySelector('.task-actions');

      // 根据是否有层级操作按钮调整滑动距离
      const hasActions = actionsEl && actionsEl.children.length > 0;
      const OPEN_X_LEFT = -60;                     // 左滑显示删除按钮
      const OPEN_X_RIGHT = hasActions ? 120 : 0;   // 右滑显示层级操作按钮
      const THRESH_OPEN = 50;  // 增加触发阈值，减少误触
      const THRESH_CLOSE = 20;
      const LOCK_THRESHOLD = 15;  // 锁定方向的阈值

      // 重置滑动状态
      function resetSwipe(){
        taskEl.style.transform='translateX(0px)';
        delEl.style.right='-60px';
        if (hasActions) {
          actionsEl.style.left='-120px';
        }
        swiped=false;
        lockedDirection='';
      }

      taskEl.addEventListener('touchstart', e=>{
        // 如果触摸点在拖拽把手上，不处理滑动
        if (e.target.closest('.task-handle')) return;

        const t=e.touches[0];
        startX=t.clientX;
        currentX=0;
        // 检查是否已经处于滑动状态
        swiped=(taskEl.style.transform.includes('translateX') && taskEl.style.transform !== 'translateX(0px)');
        swipeDirection = '';
        // 如果已经处于滑动状态，锁定当前方向
        lockedDirection = swiped ? (parseFloat(taskEl.style.transform.match(/-?\d+/)) > 0 ? 'right' : 'left') : '';
      }, {passive:true});

      taskEl.addEventListener('touchmove', e=>{
        // 如果触摸点在拖拽把手上或正在拖拽，不处理滑动
        if (window.__dragging || e.target.closest('.task-handle')) return;
        const t=e.touches[0];
        const dx=t.clientX - startX;
        currentX = dx;

        // 如果还没有锁定方向，检查是否应该锁定
        if(!lockedDirection && Math.abs(dx) > LOCK_THRESHOLD){
          lockedDirection = dx > 0 ? 'right' : 'left';
        }

        // 如果已锁定方向，只允许该方向的滑动
        if(lockedDirection === 'left'){
          // 左滑锁定：只允许左滑和回原位
          if(dx <= 0){
            swipeDirection = 'left';
            const tr = Math.max(OPEN_X_LEFT, dx);
            taskEl.style.transform=`translateX(${tr}px)`;
            delEl.style.right=`${-tr}px`;
            if (hasActions) {
              actionsEl.style.left='-120px';
            }
          } else if(dx > 0 && dx < Math.abs(OPEN_X_LEFT)){
            // 允许滑回原位
            const tr = OPEN_X_LEFT + dx;
            taskEl.style.transform=`translateX(${tr}px)`;
            delEl.style.right=`${-tr}px`;
          }
        } else if(lockedDirection === 'right' && hasActions){
          // 右滑锁定：只允许右滑和回原位
          if(dx >= 0){
            swipeDirection = 'right';
            const tr = Math.min(OPEN_X_RIGHT, dx);
            taskEl.style.transform=`translateX(${tr}px)`;
            delEl.style.right='-60px';
            actionsEl.style.left=`${-tr}px`;
          } else if(dx < 0 && dx > -OPEN_X_RIGHT){
            // 允许滑回原位
            const tr = OPEN_X_RIGHT + dx;
            taskEl.style.transform=`translateX(${tr}px)`;
            actionsEl.style.left=`${-tr}px`;
          }
        } else if(!lockedDirection){
          // 还未锁定方向时的滑动
          if(dx < 0){
            swipeDirection = 'left';
            const tr = Math.max(OPEN_X_LEFT, dx);
            taskEl.style.transform=`translateX(${tr}px)`;
            delEl.style.right=`${-tr}px`;
            if (hasActions) {
              actionsEl.style.left='-120px';
            }
          } else if(dx > 0 && hasActions){
            swipeDirection = 'right';
            const tr = Math.min(OPEN_X_RIGHT, dx);
            taskEl.style.transform=`translateX(${tr}px)`;
            delEl.style.right='-60px';
            actionsEl.style.left=`${-tr}px`;
          }
        }
      }, {passive:true});

      taskEl.addEventListener('touchend', ()=>{
        if(lockedDirection === 'left' && currentX <= -THRESH_OPEN){
          // 左滑超过阈值：固定显示删除按钮
          taskEl.style.transform=`translateX(${OPEN_X_LEFT}px)`;
          delEl.style.right='0px';
          if (hasActions) {
            actionsEl.style.left='-120px';
          }
          swiped=true;
        } else if(lockedDirection === 'right' && currentX >= THRESH_OPEN && hasActions){
          // 右滑超过阈值：固定显示层级操作按钮
          taskEl.style.transform=`translateX(${OPEN_X_RIGHT}px)`;
          delEl.style.right='-60px';
          actionsEl.style.left='0px';
          swiped=true;
        } else {
          // 未达到阈值或滑回：恢复原位
          resetSwipe();
        }
      });

      // 点击任务本身退出滑动状态
      taskEl.addEventListener('click', (e)=>{
        // 如果点击的是文本区域且处于滑动状态，先退出滑动
        if(swiped && e.target.classList.contains('task-input')){
          e.preventDefault();
          e.stopPropagation();
          resetSwipe();
          return;
        }
      });

      // 点击其他地方时也恢复
      document.addEventListener('touchstart', (e)=>{
        if(!wrapper.contains(e.target) && swiped){
          resetSwipe();
        }
      }, {passive:true});
    }

    /**
     * 为分区头部绑定右滑删除功能
     * @param {HTMLElement} headerEl - 分区头部元素
     * @param {HTMLElement} deleteBtn - 删除按钮元素
     * @param {Object} partition - 分区数据对象
     * @description 实现分区级别的右滑删除，仅在折叠状态下可用
     */
    function attachPartitionSwipeToDelete(headerEl, deleteBtn, partition) {
      let startX = 0, currentX = 0, swiped = false;
      const OPEN_X = -70;  // 删除按钮宽度
      const THRESH_OPEN = -35;
      const THRESH_CLOSE = 20;


      // 检查分区是否可以删除
      function canDeletePartition() {
        // 全天日程和固定分区不可删除
        if (isAllDaySchedule(partition) || partition.meta?.fixed) {
          return false;
        }
        // 只有折叠状态的分区可以删除
        return !!partition.meta?.collapsed;
      }

      headerEl.addEventListener('touchstart', (e) => {
        if (!canDeletePartition()) return;

        startX = e.touches[0].clientX;
        currentX = startX;
        swiped = false;

      }, {passive: true});

      headerEl.addEventListener('touchmove', (e) => {
        if (!canDeletePartition()) return;

        currentX = e.touches[0].clientX;
        const deltaX = currentX - startX;

        // 只允许向左滑动
        if (deltaX < 0) {
          e.preventDefault();
          const moveX = Math.max(deltaX, OPEN_X);
          headerEl.style.transform = `translateX(${moveX}px)`;
          // 删除按钮逐渐显示
          const btnPos = Math.min(-70 + (-moveX), 0);
          deleteBtn.style.right = `${btnPos}px`;

        }
      }, {passive: false});

      headerEl.addEventListener('touchend', (e) => {
        if (!canDeletePartition()) return;

        const deltaX = currentX - startX;

        if (deltaX < THRESH_OPEN) {
          // 显示删除按钮
          headerEl.style.transform = `translateX(${OPEN_X}px)`;
          deleteBtn.style.right = '0px';
          swiped = true;

        } else {
          // 恢复原位
          headerEl.style.transform = 'translateX(0px)';
          deleteBtn.style.right = '-70px';
          swiped = false;

        }
      });

      // 点击其他地方时恢复
      document.addEventListener('touchstart', (e) => {
        if (!headerEl.contains(e.target) && !deleteBtn.contains(e.target) && swiped) {
          headerEl.style.transform = 'translateX(0px)';
          deleteBtn.style.right = '-70px';
          swiped = false;
        }
      }, {passive: true});

      // 删除按钮点击事件
      deleteBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        showPartitionDeleteConfirm(partition);
      });
    }

    /**
     * 显示分区删除确认对话框
     * @param {Object} partition - 要删除的分区对象
     */
    function showPartitionDeleteConfirm(partition) {
      const taskCount = partition.tasks.length;
      const message = taskCount > 0
        ? `确定要删除"${partition.title}"分区吗？这将同时删除其中的 ${taskCount} 个任务。`
        : `确定要删除"${partition.title}"分区吗？`;

      if (confirm(message)) {
        deleteSchedulePartition(partition.id);
      }
    }

    /**
     * 删除日程分区
     * @param {string} partitionId - 分区ID
     */
    function deleteSchedulePartition(partitionId) {
      const schedulePartitions = getSchedulePartitions();
      const partitionIndex = schedulePartitions.findIndex(p => p.id === partitionId);
      if (partitionIndex === -1) {
        return false;
      }
      const partition = schedulePartitions[partitionIndex];
      // 安全检查：不能删除全天日程分区
      if (isAllDaySchedule(partition)) {
        return false;
      }
      // 执行删除
      try {
        schedulePartitions.splice(partitionIndex, 1);

        // 清理可能残留的DOM元素和引用
        const partitionEl = document.querySelector(`[data-id="${CSS.escape(partitionId)}"]`);
        if (partitionEl) {
          partitionEl.remove();
        }

        // 清理时间输入容器中的相关元素
        const timeInputs = document.querySelectorAll(`[data-id="${CSS.escape(partitionId)}"]`);
        timeInputs.forEach(el => el.remove());

        // 重新渲染页面
        render(!!window.Sortable);

        return true;
      } catch (error) {
        return false;
      }
    }

    /**
     * ===== 子任务层级管理功能 =====
     */

    /**
     * 缩进任务：将任务变为上方任务的子任务
     * @param {Object} task - 要缩进的任务对象
     * @param {string} partitionId - 分区ID
     */
    function indentTask(task, partitionId) {
      // 获取当前分区的所有任务
      const partition = findPartitionById(partitionId);
      if (!partition) return;
      const tasks = partition.tasks;
      const currentIndex = tasks.findIndex(t => t.id === task.id);
      if (currentIndex < 0) {
        return;
      }
      if (currentIndex === 0) {
        return;
      }

      // 找到上方的任务作为父任务
      let parentTask = null;
      for (let i = currentIndex - 1; i >= 0; i--) {
        const candidateParent = tasks[i];
        if (candidateParent.level === 0) {
          // 找到了主任务，作为父任务
          parentTask = candidateParent;
          break;
        } else if (candidateParent.level === task.level && candidateParent.parentId) {
          // 找到同级的子任务，使用其父任务
          parentTask = tasks.find(t => t.id === candidateParent.parentId);
          break;
        }
      }

      if (!parentTask) {
        return;
      }

      // 执行缩进操作
      task.parentId = parentTask.id;
      task.level = 1; // 当前只支持两层，子任务统一为level 1

      // 重新分配原有子任务：将任务的所有子任务重新分配给新的父任务
      const originalChildren = tasks.filter(t => t.parentId === task.id);
      if (originalChildren.length > 0) {
          originalChildren.forEach(child => {
          child.parentId = parentTask.id;
          child.level = 1; // 保持为子任务
        });
      }

      // 重新渲染
      render(!!window.Sortable);
    }

    /**
     * 减少缩进：将子任务变为主任务
     * @param {Object} task - 要减少缩进的任务对象
     * @param {string} partitionId - 分区ID
     */
    function outdentTask(task, partitionId) {
      if (task.level === 0) {
        return;
      }

      // 执行减少缩进操作
      task.parentId = null;
      task.level = 0;

      // 重新渲染
      render(!!window.Sortable);
    }

    /**
     * ===== 模板任务复制功能 =====
     */

    /**
     * 复制模板任务并转换为普通任务
     * @param {Object} templateTask - 原模板任务对象
     * @param {string} targetPartitionId - 目标分区ID
     * @returns {Object} 复制后的普通任务对象
     */
    function copyTemplateTask(templateTask, targetPartitionId) {

      // 生成新的任务ID
      const newTaskId = generateTaskId();

      // 创建任务副本
      const copiedTask = {
        id: newTaskId,
        text: templateTask.text,
        done: false,                    // 复制后的任务未完成
        parentId: null,                 // 复制后的任务为主任务
        level: 0,                       // 复制后的任务为顶级
        isRecurring: false,             // 复制后不是周期任务
        details: {                      // 复制详细信息
          ...templateTask.details,
          isTemplate: false             // 复制后变为普通任务
        }
      };


      // 如果模板任务有子任务，也需要复制子任务
      // 注意：此时父任务还未插入到目标分区，所以这里暂时不复制子任务
      // 子任务将在父任务插入后，在主调用函数中处理

      return copiedTask;
    }

    /**
     * 复制模板任务的子任务
     * @param {Object} originalParent - 原始父任务
     * @param {Object} copiedParent - 复制后的父任务
     * @param {string} targetPartitionId - 目标分区ID
     * @param {number} parentInsertIndex - 父任务在目标分区的插入位置
     */
    function copyChildTasks(originalParent, copiedParent, targetPartitionId, parentInsertIndex) {

      // 搜索所有分区中的子任务
      const allTasks = [];

      // 搜索所有待办分区（修复：支持多待办分区）
      const todoPartitions = getTodoPartitions();

      todoPartitions.forEach((partition, index) => {
        if (partition && partition.tasks) {
          allTasks.push(...partition.tasks);
        }
      });

      // 搜索日程分区
      getSchedulePartitions().forEach(partition => {
        allTasks.push(...partition.tasks);
      });


      // 找到原父任务的所有子任务
      const childTasks = allTasks.filter(task => task.parentId === originalParent.id);

      if (childTasks.length > 0) {
        // 获取目标分区的任务列表
        const targetTasks = getTasksById(targetPartitionId);

        // 复制每个子任务，按照父子顺序插入
        childTasks.forEach((childTask, index) => {

          const copiedChild = {
            id: generateTaskId(),
            text: childTask.text,
            done: false,
            parentId: copiedParent.id,      // 指向新的父任务
            level: 1,                       // 子任务层级
            isRecurring: false,             // 复制后不是周期任务
            details: {
              ...childTask.details,
              isTemplate: false             // 复制后变为普通任务
            }
          };


          // 将子任务插入到父任务后面的正确位置
          const childInsertIndex = parentInsertIndex + 1 + index;

          targetTasks.splice(childInsertIndex, 0, copiedChild);
        });

      } else {
        // 没有子任务
      }
    }

    /**
     * 复制周期任务并转换为普通任务
     * @param {Object} recurringTask - 原周期任务对象
     * @param {string} targetPartitionId - 目标分区ID
     * @returns {Object} 复制后的普通任务对象
     */
    function copyRecurringTask(recurringTask, targetPartitionId) {
      // 生成新的任务ID
      const newTaskId = generateTaskId();

      // 创建任务副本
      const copiedTask = {
        id: newTaskId,
        text: recurringTask.text,
        done: false,                    // 复制后的任务未完成
        parentId: null,                 // 复制后的任务为主任务
        level: 0,                       // 复制后的任务为顶级
        isRecurring: false,             // 复制后不是周期任务
        details: {                      // 复制详细信息（移除周期配置）
          ...recurringTask.details,
          isTemplate: false,            // 复制后变为普通任务
          recurrence: { enabled: false, pattern: 'none', config: {} }  // 移除周期配置
        }
      };

      // 如果周期任务有子任务，也需要复制子任务
      if (recurringTask.level === 0) {
        copyChildTasksFromRecurring(recurringTask, copiedTask, targetPartitionId);
      }

      return copiedTask;
    }

    /**
     * 复制周期任务的子任务
     * @param {Object} originalParent - 原始父任务
     * @param {Object} copiedParent - 复制后的父任务
     * @param {string} targetPartitionId - 目标分区ID
     */
    function copyChildTasksFromRecurring(originalParent, copiedParent, targetPartitionId) {
      // 搜索所有分区中的子任务
      const allTasks = [];

      // 搜索所有待办分区（修复：支持多待办分区）
      const todoPartitions = getTodoPartitions();
      todoPartitions.forEach(partition => {
        if (partition && partition.tasks) {
          allTasks.push(...partition.tasks);
        }
      });

      // 搜索日程分区
      getSchedulePartitions().forEach(partition => {
        allTasks.push(...partition.tasks);
      });

      // 找到原父任务的所有子任务
      const childTasks = allTasks.filter(task => task.parentId === originalParent.id);

      if (childTasks.length > 0) {
        // 获取目标分区的任务列表
        const targetTasks = getTasksById(targetPartitionId);

        // 复制每个子任务
        childTasks.forEach(childTask => {
          const copiedChild = {
            id: generateTaskId(),
            text: childTask.text,
            done: false,
            parentId: copiedParent.id,      // 指向新的父任务
            level: 1,                       // 子任务层级
            isRecurring: false,             // 复制后不是周期任务
            details: {
              ...childTask.details,
              isTemplate: false,            // 复制后变为普通任务
              recurrence: { enabled: false, pattern: 'none', config: {} }  // 移除周期配置
            }
          };

          // 将子任务添加到目标分区
          targetTasks.push(copiedChild);
        });
      }
    }

    /**
     * 智能调整任务层级：根据拖拽位置自动调整任务的父子关系
     * @param {Object} movedTask - 被移动的任务
     * @param {Array} targetList - 目标分区的任务列表
     * @param {number} newIndex - 新位置索引
     * @param {string} targetPartitionId - 目标分区ID
     */
    function adjustTaskLevel(movedTask, targetList, newIndex, targetPartitionId) {
      /**
       * 拖拽规则：
       * - level 保持不变（只能通过右滑缩进/减少缩进来改变）
       * - 子任务的 parentId 需要根据新位置更新为上方最近的主任务
       */
      if (movedTask.level > 0) {
        // 子任务：向上查找最近的主任务作为新父任务
        let newParentId = null;
        for (let i = newIndex - 1; i >= 0; i--) {
          if (targetList[i].level === 0) {
            newParentId = targetList[i].id;
            break;
          }
        }
        movedTask.parentId = newParentId;
      }
    }

    /**
     * ===== 任务信息缩略显示功能 =====
     */

    /**
     * 创建任务缩略信息元素
     * @param {Object} task - 任务对象
     * @returns {HTMLElement|null} 缩略信息元素或null
     */
    function createTaskSummaryElement(task) {
      if (!task.details) return null;

      const summaryContainer = document.createElement('div');
      summaryContainer.className = 'task-summary';
      summaryContainer.style.padding = '4px 0 0 44px';
      summaryContainer.style.fontSize = '11px';
      summaryContainer.style.color = 'var(--text-muted, #9aa6b2)';
      summaryContainer.style.display = 'flex';
      summaryContainer.style.flexWrap = 'wrap';
      summaryContainer.style.gap = '6px';
      summaryContainer.style.lineHeight = '1.3';

      let hasContent = false;

      // 显示时间信息
      const timeInfo = createTimeSummaryInfo(task.details);
      if (timeInfo) {
        summaryContainer.appendChild(timeInfo);
        hasContent = true;
      }

      // 显示文本标签信息（图标+数量）
      const textInfo = createTextTagsSummaryInfo(task.details);
      if (textInfo) {
        summaryContainer.appendChild(textInfo);
        hasContent = true;
      }

      return hasContent ? summaryContainer : null;
    }

    /**
     * 创建时间信息的缩略显示
     * @param {Object} details - 任务详细信息
     * @returns {HTMLElement|null} 时间信息元素或null
     */
    function createTimeSummaryInfo(details) {
      const timeItems = [];

      // 使用新的数据格式 (details.time)
      if (details.time) {
        // 开始时间（根据 visibility 决定是否显示）
        if (details.time.start && (!details.visibility || details.visibility.start)) {
          // 格式: yyyy-mm-dd hh:mm:ss -> yyyy-mm-dd hh:mm
          const display = details.time.start.substring(0, 16);
          timeItems.push(`🕒 ${display}`);
        }

        // 截止时间（根据 visibility 决定是否显示）
        if (details.time.end && (!details.visibility || details.visibility.end)) {
          const display = details.time.end.substring(0, 16);
          timeItems.push(`⏰ ${display}`);
        }

        // 用时（根据 visibility 决定是否显示）
        if (details.time.duration && (!details.visibility || details.visibility.duration)) {
          const dur = details.time.duration;
          let unitText = dur.unit;
          // 统一单位显示
          if (dur.unit === 'min') unitText = '分钟';
          else if (dur.unit === 'h') unitText = '小时';
          else if (dur.unit === 'd') unitText = '天';
          else if (dur.unit === 'm') unitText = '月';

          timeItems.push(`⏱️ ${dur.value}${unitText}`);
        }
      }

      // 周期信息（根据 visibility 决定是否显示）
      if (details.recurrence && details.recurrence.enabled &&
          (!details.visibility || details.visibility.repeat)) {
        let pattern = details.recurrence.pattern;

        let desc = `<svg style="width:12px;height:12px;color:#007aff;vertical-align:middle;margin-right:2px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M4 12a8 8 0 0 1 13-5.3"/><polyline points="14.5 4 17 6.5 14.5 9"/><path d="M20 12a8 8 0 0 1-13 5.3"/><polyline points="9.5 20 7 17.5 9.5 15"/></svg>${pattern}`;
        if (pattern === '每周' && details.recurrence.config && details.recurrence.config.weekdays) {
          desc += `(${details.recurrence.config.weekdays.join('')})`;
        }
        timeItems.push(desc);
      }

      if (timeItems.length === 0) return null;

      const timeSpan = document.createElement('span');
      timeSpan.className = 'time-summary-info';
      timeSpan.innerHTML = timeItems.join(' · ');
      timeSpan.style.color = 'var(--accent, #0a84ff)';
      timeSpan.style.fontWeight = '500';

      return timeSpan;
    }

    /**
     * 创建文本标签的缩略显示（图标+数量）
     * @param {Object} details - 任务详细信息
     * @returns {HTMLElement|null} 文本标签信息元素或null
     */
    function createTextTagsSummaryInfo(details) {
      const tagItems = [];

      // 使用新的数据格式 (details.tags)
      if (!details.tags) return null;

      // 新格式的图标映射
      const tagMapping = {
        'goals': { icon: '🎯', label: '目标' },
        'outputs': { icon: '📦', label: '产出物' },
        'contacts': { icon: '👤', label: '联系人' },
        'locations': { icon: '📍', label: '地点' },
        'notes': { icon: '📝', label: '备注' }
      };

      Object.entries(details.tags).forEach(([field, values]) => {
        if (Array.isArray(values) && values.length > 0) {
          const mapping = tagMapping[field];
          if (mapping) {
            tagItems.push(`${mapping.icon}${values.length}`);
          }
        }
      });

      if (tagItems.length === 0) return null;

      const tagsSpan = document.createElement('span');
      tagsSpan.className = 'tags-summary-info';
      tagsSpan.textContent = tagItems.join(' ');
      tagsSpan.style.color = 'var(--text-muted, #9aa6b2)';
      tagsSpan.style.fontSize = '10px';

      return tagsSpan;
    }


    /**
     * 生成由周期任务模板创建的可勾选任务
     * @param {Object} recurringTemplate - 周期任务模板
     * @param {string} targetPartitionId - 目标分区ID
     * @param {Date} scheduledDate - 计划执行日期（可选）
     * @returns {Object} 生成的可勾选周期任务
     */
    function generateRecurringTask(recurringTemplate, targetPartitionId, scheduledDate = null) {
      // 生成新的任务ID
      const newTaskId = generateTaskId();

      // 创建任务副本
      const generatedTask = {
        id: newTaskId,
        text: recurringTemplate.text,
        done: false,                      // 生成的任务未完成
        parentId: null,                   // 生成的任务为主任务
        level: 0,                         // 生成的任务为顶级
        isRecurring: true,                // 生成的任务是周期任务
        isGeneratedFromRecurring: true,   // 标记为由周期任务生成
        recurringTemplateId: recurringTemplate.id, // 关联到原始模板
        scheduledDate: scheduledDate,     // 计划执行日期
        details: {                        // 复制详细信息（保留周期配置用于显示）
          ...recurringTemplate.details,
          isTemplate: false               // 生成的任务不是模板
        }
      };

      // 如果周期任务模板有子任务，也需要生成子任务
      if (recurringTemplate.level === 0) {
        generateChildTasksFromRecurring(recurringTemplate, generatedTask, targetPartitionId);
      }
      return generatedTask;
    }

    /**
     * 生成周期任务模板的子任务
     * @param {Object} originalParent - 原始父任务模板
     * @param {Object} generatedParent - 生成后的父任务
     * @param {string} targetPartitionId - 目标分区ID
     */
    function generateChildTasksFromRecurring(originalParent, generatedParent, targetPartitionId) {
      // 搜索所有分区中的子任务
      const allTasks = [];

      // 搜索所有待办分区（修复：支持多待办分区）
      const todoPartitions = getTodoPartitions();
      todoPartitions.forEach(partition => {
        if (partition && partition.tasks) {
          allTasks.push(...partition.tasks);
        }
      });

      // 搜索日程分区
      getSchedulePartitions().forEach(partition => {
        allTasks.push(...partition.tasks);
      });

      // 找到原父任务的所有子任务
      const childTasks = allTasks.filter(task => task.parentId === originalParent.id);

      if (childTasks.length > 0) {
        // 获取目标分区的任务列表
        const targetTasks = getTasksById(targetPartitionId);

        // 生成每个子任务
        childTasks.forEach(childTask => {
          const generatedChild = {
            id: generateTaskId(),
            text: childTask.text,
            done: false,
            parentId: generatedParent.id,           // 指向新的父任务
            level: 1,                               // 子任务层级
            isRecurring: true,                      // 生成的任务是周期任务
            isGeneratedFromRecurring: true,         // 标记为由周期任务生成
            recurringTemplateId: childTask.id,      // 关联到原始子任务模板
            scheduledDate: generatedParent.scheduledDate, // 继承父任务的计划日期
            details: {
              ...childTask.details,
              isTemplate: false                     // 生成的任务不是模板
            }
          };

          // 将子任务添加到目标分区
          targetTasks.push(generatedChild);
        });
      }
    }

    /**
     * 测试函数：手动生成周期任务（临时测试用）
     * @param {string} recurringTaskId - 周期任务模板ID
     * @param {string} targetPartitionId - 目标分区ID（可选，默认生成到第一个日程分区）
     */
    function testGenerateRecurringTask(recurringTaskId, targetPartitionId = null) {
      // 搜索周期任务模板
      let recurringTemplate = null;

      // 搜索待办分区
      const todoPartition = getTodoPartition();
      if (todoPartition) {
        recurringTemplate = todoPartition.tasks.find(task => task.id === recurringTaskId && task.isRecurring && !task.isGeneratedFromRecurring);
      }

      // 如果没找到，搜索日程分区
      if (!recurringTemplate) {
        const schedulePartitions = getSchedulePartitions();
        for (const partition of schedulePartitions) {
          recurringTemplate = partition.tasks.find(task => task.id === recurringTaskId && task.isRecurring && !task.isGeneratedFromRecurring);
          if (recurringTemplate) break;
        }
      }

      if (!recurringTemplate) {
        return null;
      }

      // 确定目标分区
      let target = targetPartitionId;
      if (!target) {
        const schedulePartitions = getSchedulePartitions();
        if (schedulePartitions.length > 0) {
          target = schedulePartitions[0].id;
        } else {
          return null;
        }
      }

      // 生成任务
      const generatedTask = generateRecurringTask(recurringTemplate, target, new Date());

      // 添加到目标分区
      const targetTasks = getTasksById(target);
      targetTasks.push(generatedTask);

      // 重新渲染
      render(!!window.Sortable);
      return generatedTask;
    }

    // 添加到全局作用域以便在控制台测试
    window.testGenerateRecurringTask = testGenerateRecurringTask;

    /**
     * ===== 拖拽系统核心功能 =====
     */

    /**
     * 全局拖拽状态管理
     * @description 这些全局变量用于跟踪拖拽操作的完整状态
     */
    // 全局拖拽状态
    window.__dragging = false;              // 是否正在拖拽
    window.__dragFrom = null;               // 拖拽源信息 {id, index}
    window.__dragHoverId = null;            // 当前悬停目标分区 ID
    window.__dragHoverTimer = null;         // 自动展开计时器ID
    window.__manualDropTargetId = null;     // 手动释放目标分区 ID
    window.__expandedForDrag = new Set();   // 为拖拽而展开的分区ID集合
    window.__needsRenderAfterDrag = false;  // 拖拽后需要延迟渲染标志

    // 新日程计数器
    let scheduleCounter = 0;                // 新日程的递增计数器
    let todoCounter = 0;                    // 新待办分区的递增计数器

    /**
     * 清除拖拽悬停状态
     * @description 清除计时器、移除视觉提示，重置悬停目标
     */
    function clearDragHover(){
      if (window.__dragHoverTimer){ clearTimeout(window.__dragHoverTimer); window.__dragHoverTimer = null; }
      if (window.__dragHoverId){
        const el = document.querySelector(`.partition[data-id="${CSS.escape(window.__dragHoverId)}"]`);
        if(el) el.classList.remove('drop-hint');
      }
      window.__dragHoverId = null;
    }

    /**
     * 验证拖拽位置是否合法
     * @description 检查拖拽位置是否满足原有的规则限制
     * @param {Object} draggedTask - 被拖拽的任务
     * @param {HTMLElement} targetElement - 目标元素
     * @param {HTMLElement} targetList - 目标列表
     * @param {boolean} willInsertAfter - 是否插入到目标元素之后
     * @returns {boolean} 位置是否合法
     */
    function validateDropPosition(draggedTask, targetElement, targetList, willInsertAfter) {
      if (!draggedTask || !targetElement || !targetList) return false;

      // 只对主任务（level=0）进行限制
      if (draggedTask.level !== 0) return true;

      const listId = targetList.dataset.id;
      const taskList = getTasksById(listId);
      const relatedTaskId = targetElement.dataset.taskId;

      // 全天日程特殊处理 - 允许所有拖拽
      const targetPartition = findPartitionById(listId);
      const isTargetAllDay = isAllDaySchedule(targetPartition);
      if (isTargetAllDay) {
        return true;
      }

      // 检查相关元素是否是子任务
      const taskElement = targetElement.querySelector('.task');
      const isRelatedSubTask = taskElement && taskElement.classList.contains('level-1');

      // 规则1：主任务不能插入到子任务位置（但允许插入到子任务后面的合适位置）
      if (isRelatedSubTask && !willInsertAfter) {
        return false;
      }

      // 规则2：主任务不能插入到模板父任务的下方（因为下方是模板子任务区域）
      if (relatedTaskId) {
        const relatedTask = taskList.find(t => t.id === relatedTaskId);

        if (relatedTask && relatedTask.level === 0 && relatedTask.details && relatedTask.details.isTemplate) {
          if (willInsertAfter) {
            const hasChildren = taskList.some(t => t.parentId === relatedTask.id);
            if (hasChildren) {
              return false;
            }
          }
        }
      }

      // 规则3：禁止主任务插入到另一个主任务与其第一个子任务之间
      if (relatedTaskId && !isRelatedSubTask) {
        const relatedTask = taskList.find(t => t.id === relatedTaskId);

        if (relatedTask && relatedTask.level === 0) {
          if (willInsertAfter) {
            const relatedIndex = taskList.findIndex(t => t.id === relatedTask.id);
            if (relatedIndex !== -1 && relatedIndex + 1 < taskList.length) {
              const nextTask = taskList[relatedIndex + 1];
              if (nextTask.parentId === relatedTask.id) {
                return false;
              }
            }
          }
        }
      }

      // 规则4：禁止主任务插入到任何双层级任务的子任务序列中间
      if (relatedTaskId) {
        const relatedTask = taskList.find(t => t.id === relatedTaskId);

        if (relatedTask) {
          // 如果目标是子任务，检查是否会在父任务的子任务序列中间插入
          if (relatedTask.level === 1) {
            const parentTask = taskList.find(t => t.id === relatedTask.parentId);
            if (parentTask) {
              // 获取该父任务的所有子任务
              const allSiblings = taskList.filter(t => t.parentId === parentTask.id);
              if (allSiblings.length > 1) {
                // 如果子任务多于1个，检查是否插入到中间位置
                const targetIndex = allSiblings.findIndex(t => t.id === relatedTask.id);
                const isMiddleInsertion = (!willInsertAfter && targetIndex > 0) ||
                                         (willInsertAfter && targetIndex < allSiblings.length - 1);

                if (isMiddleInsertion) {
                  return false;
                }
              }
            }
          }
        }
      }
      return true;
    }

    /**
     * 显示拖拽位置提示
     * @param {HTMLElement} draggedElement - 被拖拽的元素
     * @param {boolean} isValid - 位置是否合法
     */
    function showDropHint(draggedElement, isValid) {
      if (!draggedElement) return;

      // 移除之前的状态类
      draggedElement.classList.remove('valid-drop', 'invalid-drop');

      // 添加对应的状态类
      if (isValid) {
        draggedElement.classList.add('valid-drop');
      } else {
        draggedElement.classList.add('invalid-drop');
      }
    }

    /**
     * 清除拖拽位置提示
     * @param {HTMLElement} draggedElement - 被拖拽的元素
     */
    function clearDropHint(draggedElement) {
      if (draggedElement) {
        draggedElement.classList.remove('valid-drop', 'invalid-drop');
      }
    }

    /**
     * 为折叠分区的头部绑定拖拽悬停交互
     * @param {Object} config - 配置对象
     * @param {HTMLElement} config.partitionEl - 分区容器元素
     * @param {HTMLElement} config.headerEl - 分区头部元素
     * @param {string} config.partitionId - 分区的ID
     * @param {Function} config.getMeta - 获取分区元数据的函数
     * @param {Function} config.onExpand - 展开分区的回调函数
     * @description 实现拖拽悬停700ms后自动展开折叠分区的功能
     */
    function bindHeaderHoverForCollapsed({partitionEl, headerEl, partitionId, getMeta, onExpand}){
      const meta = getMeta();
      const isCollapsed = !!(meta && meta.collapsed);
      if(!isCollapsed) return;

      function onEnter(e){
        const timestamp = new Date().toLocaleTimeString();
        const coords = e ? `(${e.clientX}, ${e.clientY})` : '(未知坐标)';
        if (!window.__dragging) {
          return;
        }
        partitionEl.classList.add('drop-hint');
        window.__dragHoverId = partitionId;

        if (window.__dragHoverTimer) {
          clearTimeout(window.__dragHoverTimer);
        }
        window.__dragHoverTimer = setTimeout(()=>{
          if (window.__dragging && window.__dragHoverId === partitionId) {
            // 自动展开分区，但不中断拖拽流程
            onExpand(); // 更新数据状态

            // 手动更新DOM显示，不调用render()以保持拖拽状态
            const listEl = partitionEl.querySelector('.task-list');
            const badgeEl = partitionEl.querySelector('.badge');

            if (listEl) {
              listEl.classList.remove('collapsed');
              // 确保列表可见并且可以接受拖拽
              listEl.style.display = '';
            }
            if (badgeEl) {
              badgeEl.classList.remove('is-collapsed');
            }

            // 关键修复：启用 Sortable 实例
            if (listEl && listEl.sortableInstance) {
              // 如果 Sortable 实例存在但被禁用（折叠分区的情况），立即启用它
              listEl.sortableInstance.option('disabled', false);
              // 确保 group 设置正确
              listEl.sortableInstance.option('group', 'tasks');
            } else if (listEl && window.Sortable && window.bindSortable) {
              // 如果没有 Sortable 实例（理论上不应该发生），立即创建
              window.bindSortable(listEl, true);
            }

            clearDragHover();
          }
        }, 700);
      }
      function onLeave(e){
        const timestamp = new Date().toLocaleTimeString();
        const coords = e ? `(${e.clientX}, ${e.clientY})` : '(未知坐标)';

        if (window.__dragHoverId === partitionId) {
          clearDragHover();
        } else {
        }
      }
      function onPointerUp(e){
        const timestamp = new Date().toLocaleTimeString();
        if (!window.__dragging) {
          return;
        }

        window.__manualDropTargetId = partitionId;
      }

      // 同时绑定到header和整个分区容器，确保事件能被捕获
      headerEl.addEventListener('pointerenter', onEnter);
      headerEl.addEventListener('pointerleave', onLeave);
      headerEl.addEventListener('pointerup', onPointerUp);

      // 关键修复：也绑定到整个分区容器
      partitionEl.addEventListener('pointerenter', onEnter);
      partitionEl.addEventListener('pointerleave', onLeave);
      partitionEl.addEventListener('pointerup', onPointerUp);

      // 移动端修复：添加触摸事件支持
      const isTouchDevice = 'ontouchstart' in window;
      if (isTouchDevice) {
        // 监听触摸移动事件来模拟悬停
        document.addEventListener('touchmove', (e) => {
          if (!window.__dragging) return;

          const touch = e.touches[0];
          const element = document.elementFromPoint(touch.clientX, touch.clientY);

          // 检查触摸点是否在目标分区上
          if (element && (headerEl.contains(element) || partitionEl.contains(element))) {
            // 触摸点在折叠分区上，触发进入事件
            if (window.__dragHoverId !== partitionId) {
              onEnter({ clientX: touch.clientX, clientY: touch.clientY });
            }
          } else {
            // 触摸点离开分区
            if (window.__dragHoverId === partitionId) {
              onLeave({ clientX: touch.clientX, clientY: touch.clientY });
            }
          }
        }, { passive: true });

        // 触摸结束时的处理
        document.addEventListener('touchend', (e) => {
          if (!window.__dragging) return;

          const touch = e.changedTouches[0];
          const element = document.elementFromPoint(touch.clientX, touch.clientY);

          if (element && (headerEl.contains(element) || partitionEl.contains(element))) {
            onPointerUp(e);
          }
        }, { passive: true });
      }

      // 额外调试：监听鼠标移动事件
      headerEl.addEventListener('pointermove', (e) => {
        if (window.__dragging) {
        }
      });
    }

    /**
     * ===== 跨区拖拽工具函数 =====
     */

    /**
     * 拖拽移动后调整徽标计数
     * @param {string} fromId - 源分区ID
     * @param {string} toId - 目标分区ID
     * @param {Object} movedTask - 被移动的任务对象
     * @description 更新源分区和目标分区的任务计数，维护进度徽标的准确性
     */
    function adjustBadgesAfterMove(fromId, toId, movedTask){
      const fromPartition = fromId ? findPartitionById(fromId) : null;
      const toPartition = findPartitionById(toId);

      // 从源分区减少计数（如果不是复制操作且是父任务）
      if(fromPartition && !isTodoPartition(fromId) && fromPartition.meta?.badge && movedTask?.level === 0){
        const bmFrom = fromPartition.meta.badge;
        bmFrom.baseTotal = (bmFrom.baseTotal||0) - 1;
        if(movedTask?.done) bmFrom.baseDone = (bmFrom.baseDone||0) - 1;
      }

      // 向目标分区增加计数（仅父任务）
      if(toPartition && !isTodoPartition(toId) && movedTask?.level === 0){
        if(!toPartition.meta) toPartition.meta = {};
        if(!toPartition.meta.badge) {
          toPartition.meta.badge = {baseDone:0,baseTotal:0,dDone:0,dTotal:0};
        }
        const bmTo = toPartition.meta.badge;
        bmTo.baseTotal = (bmTo.baseTotal||0) + 1;
        if(movedTask?.done) bmTo.baseDone = (bmTo.baseDone||0) + 1;
      }
    }

    /**
     * 根据任务ID在数据数组中查找索引
     * @param {Array} taskList - 任务数据数组
     * @param {string} taskId - 任务ID
     * @returns {number} 任务在数组中的索引，未找到返回-1
     */
    function findTaskIndexById(taskList, taskId) {
      return taskList.findIndex(t => t.id === taskId);
    }

    /**
     * 将DOM索引转换为数据数组索引
     * @param {number} domIndex - DOM中的索引位置
     * @param {string} partitionId - 分区ID
     * @param {HTMLElement} domElement - DOM容器元素
     * @returns {number} 数据数组中的实际索引
     * @description 直接从DOM读取可见任务，避免依赖collapsed属性
     */
    function convertDomIndexToDataIndex(domIndex, partitionId, domElement) {
      if (!domElement) {
        domElement = document.querySelector(`[data-id="${partitionId}"]`);
      }
      if (!domElement) return domIndex;
      const allElements = Array.from(domElement.querySelectorAll('.task-wrapper:not(.placeholder-row)'));
      const visibleElements = allElements.filter(el => {
        const style = window.getComputedStyle(el);
        return style.display !== 'none' && style.visibility !== 'hidden' && el.offsetParent !== null;
      });
      const targetElement = visibleElements[domIndex];
      if (!targetElement) {
        return domIndex;
      }
      const targetTaskId = targetElement.dataset.taskId;
      const partition = findPartitionById(partitionId);
      if (!partition) return domIndex;
      const dataIndex = partition.tasks.findIndex(t => t.id === targetTaskId);
      return dataIndex !== -1 ? dataIndex : domIndex;
    }

    /**
     * 为任务列表绑定拖拽排序功能
     * @param {HTMLElement} listEl - 任务列表容器元素
     * @param {boolean} enableDrag - 是否启用拖拽功能
     * @description 使用SortableJS库实现跨列表拖拽排序，支持任务在不同分区间移动
     */
    function bindSortable(listEl, enableDrag){
      if(!enableDrag || !window.Sortable) return;
      if(listEl.__sortableBound) return;
      listEl.__sortableBound = true;
      const sortableInstance = new Sortable(listEl,{
        group:'tasks',
        animation:150,
        ghostClass:'dragging-shadow',
        chosenClass:'sortable-chosen',
        dragClass:'sortable-drag',
        handle: '.task-handle',
        draggable: '.task-wrapper:not(.placeholder-row)',
        // 移动端优化配置
        delayOnTouchOnly: true,  // 仅在触摸时启用延迟
        delay: 100,               // 触摸延迟100ms，避免与滚动冲突
        touchStartThreshold: 5,   // 触摸移动5px后才开始拖拽
        // 拖拽敏感度优化
        threshold: 8,             // 增加移动阈值，减少误触发
        swapThreshold: 0.75,      // 提高交换阈值，让定位更精准
        invertSwap: false,        // 保持正常的交换逻辑
        emptyInsertThreshold: 8,  // 空区域插入阈值
        direction: 'vertical',    // 明确指定为垂直拖拽，减少横向干扰

        // 拖拽移动时的过滤规则 - 保持流畅，只在边界检查
        onMove: (evt) => {
          // 只在实际超出屏幕边界时才阻止，不影响正常的上下拖拽
          if (evt.dragged) {
            const draggedRect = evt.dragged.getBoundingClientRect();
            const windowWidth = window.innerWidth;
            const windowHeight = window.innerHeight;
            const isLandscape = windowWidth > windowHeight;
            const safetyMargin = isLandscape ? 10 : 5; // 横屏模式下增加安全边距

            // 横屏模式下的边界检查优化
            if (isLandscape) {
              // 横屏时允许更宽的拖拽范围，考虑左右分栏布局
              const leftBoundary = 0;
              const rightBoundary = windowWidth;

              if (draggedRect.right > rightBoundary || draggedRect.left < leftBoundary) {
                return false; // 阻止超出屏幕边界
              }
            } else {
              // 竖屏模式保持原有逻辑
              if (draggedRect.right > windowWidth || draggedRect.left < 0) {
                return false; // 阻止超出屏幕边界
              }
            }
          }

          // 移除所有限制，允许自由拖拽
          // 添加实时位置验证和视觉反馈
          const draggedTask = window.__dragFrom?.originalTask;
          if (draggedTask && evt.related) {
            const isValid = validateDropPosition(draggedTask, evt.related, evt.to, evt.willInsertAfter);
            showDropHint(evt.dragged, isValid);
          }

          return true; // 始终允许插入
        },

        onStart:(evt)=>{
          const timestamp = new Date().toLocaleTimeString();
          const taskText = evt.item.querySelector('.task-input, .task-text')?.textContent?.trim() || '未知任务';

          window.__dragging = true;

          // 使用任务ID获取任务数据，避免折叠时索引错乱
          const taskId = evt.item.dataset.taskId;
          const fromList = getTasksById(evt.from.dataset.id);
          const originalTask = fromList.find(t => t.id === taskId);
          const taskIndex = findTaskIndexById(fromList, taskId);

          window.__dragFrom = {
            id: evt.from.dataset.id,
            index: taskIndex,
            originalTask: originalTask,
            domElement: evt.item.cloneNode(true), // 保存原始DOM元素的副本
            nextSibling: evt.item.nextElementSibling // 保存原始位置的下一个元素引用
          };

          // 新增：模板任务提示
          if (originalTask && originalTask.details && originalTask.details.isTemplate) {
            const hint = document.createElement('div');
            hint.className = 'template-task-drag-hint';
            hint.textContent = '模板任务移动中';

            // 将提示添加到页面头部容器中
            const pageHeader = document.querySelector('.page-header');
            if (pageHeader) {
              pageHeader.style.position = 'relative';
              pageHeader.appendChild(hint);
            } else {
              // 备选：添加到body中
              document.body.appendChild(hint);
            }

            window.__templateTaskHint = hint;
          }

        },
        onEnd:(evt)=>{

          const timestamp = new Date().toLocaleTimeString();
          const taskText = evt.item.querySelector('.task-input, .task-text')?.textContent?.trim() || '未知任务';

          // 新增：清理模板任务提示
          if (window.__templateTaskHint) {
            window.__templateTaskHint.remove();
            window.__templateTaskHint = null;
          }

          window.__dragging=false;

          // 清除拖拽位置提示
          clearDropHint(evt.item);

          // 验证拖拽位置是否合法
          const originalTask = window.__dragFrom?.originalTask;
          if (originalTask) {
            // 获取目标位置的更可靠方法
            let targetElement = evt.related;
            let willInsertAfter = evt.willInsertAfter;

            // 如果evt.related不可靠，使用DOM位置计算目标元素
            if (!targetElement && evt.to && evt.item) {
              const allItems = Array.from(evt.to.querySelectorAll('.task-wrapper:not(.placeholder-row)'));
              const draggedIndex = allItems.indexOf(evt.item);

              if (draggedIndex > 0) {
                // 如果不是第一个，获取前一个元素作为参考
                targetElement = allItems[draggedIndex - 1];
                willInsertAfter = true;
              } else if (allItems.length > 1 && draggedIndex < allItems.length - 1) {
                // 如果不是最后一个，获取后一个元素作为参考
                targetElement = allItems[draggedIndex + 1];
                willInsertAfter = false;
              }
            }

              // 全天日程判断和强制验证
            const fromId = evt.from?.dataset?.id;
            const toId = evt.to?.dataset?.id;
            const targetPartition = findPartitionById(toId);
            const isTargetAllDay = isAllDaySchedule(targetPartition);

            // 进行位置验证
            let isValidPosition = true;
            if (targetElement) {
              isValidPosition = validateDropPosition(originalTask, targetElement, evt.to, willInsertAfter);
            } else {
              // 如果没有目标元素，检查是否为空列表
              const hasItems = evt.to && evt.to.querySelector('.task-wrapper:not(.placeholder-row)');
              if (!hasItems) {
                // 空列表，任何任务都可以放置
                isValidPosition = true;
              } else {
                // 有错误但无法确定目标位置，为安全起见不允许
                isValidPosition = false;
              }
            }

            // 全天日程强制通过验证
            if (isTargetAllDay && !isValidPosition) {
              isValidPosition = true;
            }

            // 如果位置不合法，恢复拖拽前的状态
            if (!isValidPosition) {
              // 恢复DOM位置
              const movedItem = evt.item;
              const parent = evt.from;
              const nextSibling = window.__dragFrom?.nextSibling;

              // 移除当前元素
              movedItem.remove();

              // 插回原位置
              if (nextSibling && nextSibling.parentNode === parent) {
                parent.insertBefore(movedItem, nextSibling);
              } else {
                parent.appendChild(movedItem);
              }

              // 清理状态
              clearDragHover();
              window.__dragFrom = null;
              window.__manualDropTargetId = null;

              // 可选：显示提示信息
  
              return;
            }
          }


          const fromId = evt.from?.dataset?.id;
          const toId   = evt.to?.dataset?.id;

          
          if (fromId && toId) {
            // 正常落在 list 里
            const fromList = getTasksById(fromId);
            const toList   = getTasksById(toId);
            // 使用保存的原始任务引用，避免DOM操作后索引错乱
            const originalTask = window.__dragFrom?.originalTask;

            if (!originalTask) {
              return;
            }

            // ========== 处理模板子任务拖拽 ==========
            // 检查是否为模板任务的子任务
                        if (originalTask.level === 1 && originalTask.parentId) {
              // 查找父任务
              const parentTask = fromList.find(t => t.id === originalTask.parentId);
              
              // 判断父任务是否为模板任务
              if (parentTask && parentTask.details && parentTask.details.isTemplate) {
                const fromType = getPartitionType(fromId);
                const toType = getPartitionType(toId);
                
                // 场景1：待办大分区内移动（移动操作）
                if (fromType === 'todo' && toType === 'todo') {
                                    // 操作前：记录完整的列表数据
                  const beforeListSnapshot = fromList.map(t => ({
                    id: t.id,
                    text: t.text,
                    level: t.level,
                    parentId: t.parentId,
                    isTemplate: t.details?.isTemplate
                  }));

                  // 执行移动操作（使用数据索引而非DOM索引）
                  const taskIndex = findTaskIndexById(fromList, originalTask.id);
                  const moved = fromList.splice(taskIndex, 1)[0];
                  const insertIndex = convertDomIndexToDataIndex(evt.newIndex, toId, evt.to);
                  toList.splice(insertIndex, 0, moved);

                  // 智能层级管理：更新子任务的 parentId
                  adjustTaskLevel(moved, toList, insertIndex, toId);

                  // 操作后：记录完整的列表数据
                  const afterListSnapshot = toList.map(t => ({
                    id: t.id,
                    text: t.text,
                    level: t.level,
                    parentId: t.parentId,
                    isTemplate: t.details?.isTemplate
                  }));


                  clearDragHover();
                  window.__dragFrom = null;
                  window.__manualDropTargetId = null;
                  render(true);
                  return;
                }

                // 场景2：跨大分区拖拽（复制并转为普通任务）
                if (fromType === 'todo' && toType === 'schedule') {
                  // 操作前：记录源分区和目标分区的完整数据
                  const beforeFromList = fromList.map(t => ({
                    id: t.id,
                    text: t.text,
                    level: t.level,
                    parentId: t.parentId,
                    isTemplate: t.details?.isTemplate
                  }));
                  const beforeToList = toList.map(t => ({
                    id: t.id,
                    text: t.text,
                    level: t.level,
                    parentId: t.parentId,
                    isTemplate: t.details?.isTemplate
                  }));

                  // 1. 恢复DOM（撤销SortableJS的移动）
                  if (evt.item && evt.from) {
                    evt.item.remove();
                    if (evt.oldIndex < evt.from.children.length) {
                      evt.from.insertBefore(evt.item, evt.from.children[evt.oldIndex]);
                    } else {
                      evt.from.appendChild(evt.item);
                    }
                  }

                  // 2. 创建副本，转为普通独立任务
                  const newTaskId = generateTaskId();


                  const copiedTask = {
                    ...originalTask,
                    id: newTaskId,
                    text: originalTask.text || '',  // 确保text属性被复制
                    level: originalTask.level || 1,  // 保持子任务层级（子任务拖过来保持level=1）
                    parentId: null,  // 解除父子关系（成为独立子任务）
                    details: {
                      ...(originalTask.details || {}),
                      isTemplate: false  // 转为普通任务
                    }
                  };


                  // 3. 插入到目标分区（使用数据索引）
                  const insertIndex = convertDomIndexToDataIndex(evt.newIndex, toId, evt.to);
                  toList.splice(insertIndex, 0, copiedTask);

                  // 4. 智能调整层级：自动建立父子关系
                  adjustTaskLevel(copiedTask, toList, insertIndex, toId);

                  // 操作后：记录两个分区的完整数据
                  const afterFromList = fromList.map(t => ({
                    id: t.id,
                    text: t.text,
                    level: t.level,
                    parentId: t.parentId,
                    isTemplate: t.details?.isTemplate
                  }));
                  const afterToList = toList.map(t => ({
                    id: t.id,
                    text: t.text,
                    level: t.level,
                    parentId: t.parentId,
                    isTemplate: t.details?.isTemplate
                  }));


                  // 4. 完全重新渲
                  clearDragHover();
                  window.__dragFrom = null;
                  window.__manualDropTargetId = null;

                  // 销毁SortableJS实例，避免DOM残留
                  if (evt.from.__sortable) {
                    evt.from.__sortable.destroy();
                    evt.from.__sortable = null;
                  }
                  if (evt.to && evt.to.__sortable && evt.to !== evt.from) {
                    evt.to.__sortable.destroy();
                    evt.to.__sortable = null;
                  }

                  // 完全清空DOM并重建
                  const todoList = document.getElementById('todoList');
                  if (todoList) {
                    // 保存滚动位置
                    const scrollTop = todoList.scrollTop;

                    // 清空所有DOM
                    todoList.innerHTML = '';

                    // 强制浏览器重排
                    void todoList.offsetHeight;

                    // 调用render重新渲染整个页面
                    render(true);

                    // 恢复滚动位置
                    setTimeout(() => {
                      todoList.scrollTop = scrollTop;
                    }, 0);
                  } else {
                    // 直接重新渲染
                    render(true);
                  }

                  return;
                }
                if (isFromTodo && isToSchedule) {
                  // 操作前：记录待办分区和日程分区的完整数据
                  const beforeFromList = fromList.map(t => ({
                    id: t.id,
                    text: t.text,
                    level: t.level,
                    parentId: t.parentId,
                    isTemplate: t.details?.isTemplate
                  }));
                  const beforeToList = toList.map(t => ({
                    id: t.id,
                    text: t.text,
                    level: t.level,
                    parentId: t.parentId,
                    isTemplate: t.details?.isTemplate
                  }));

                  // 1. 恢复DOM
                  if (evt.item && evt.from) {
                    evt.item.remove();
                    if (evt.oldIndex < evt.from.children.length) {
                      evt.from.insertBefore(evt.item, evt.from.children[evt.oldIndex]);
                    } else {
                      evt.from.appendChild(evt.item);
                    }
                  }

                  // 2. 创建副本，转为普通独立任务
                  const newTaskId = generateTaskId();


                  const copiedTask = {
                    ...originalTask,
                    id: newTaskId,
                    text: originalTask.text || '',  // 确保text属性被复制
                    level: originalTask.level || 1,  // 保持子任务层级（子任务拖过来保持level=1）
                    parentId: null,  // 解除父子关系（成为独立子任务）
                    details: {
                      ...(originalTask.details || {}),
                      isTemplate: false  // 转为普通任务
                    }
                  };


                  // 3. 插入到日程分区（使用数据索引）
                  const insertIndex = convertDomIndexToDataIndex(evt.newIndex, toId, evt.to);
                  toList.splice(insertIndex, 0, copiedTask);

                  // 4. 智能调整层级：自动建立父子关系
                  adjustTaskLevel(copiedTask, toList, insertIndex, toId);

                  // 操作后：记录两个分区的完整数据
                  const afterFromList = fromList.map(t => ({
                    id: t.id,
                    text: t.text,
                    level: t.level,
                    parentId: t.parentId,
                    isTemplate: t.details?.isTemplate
                  }));
                  const afterToList = toList.map(t => ({
                    id: t.id,
                    text: t.text,
                    level: t.level,
                    parentId: t.parentId,
                    isTemplate: t.details?.isTemplate
                  }));


                  // 4. 完全重新渲染
                  clearDragHover();
                  window.__dragFrom = null;
                  window.__manualDropTargetId = null;

                  // 销毁SortableJS实例
                  if (evt.from.__sortable) {
                    evt.from.__sortable.destroy();
                    evt.from.__sortable = null;
                  }
                  if (evt.to && evt.to.__sortable && evt.to !== evt.from) {
                    evt.to.__sortable.destroy();
                    evt.to.__sortable = null;
                  }

                  const scheduleContainer = document.getElementById('schedule');
                  const todoList = document.getElementById('todoList');

                  // 保存滚动位置
                  const todoScrollTop = todoList ? todoList.scrollTop : 0;
                  const scheduleScrollTop = scheduleContainer ? scheduleContainer.scrollTop : 0;

                  // 清空DOM
                  if (todoList) todoList.innerHTML = '';
                  if (scheduleContainer) scheduleContainer.innerHTML = '';

                  // 强制浏览器重排
                  if (todoList) void todoList.offsetHeight;
                  if (scheduleContainer) void scheduleContainer.offsetHeight;

                  // 调用render重新渲染整个页面
                  render(true);

                  // 恢复滚动位置
                  setTimeout(() => {
                    if (todoList) todoList.scrollTop = todoScrollTop;
                    if (scheduleContainer) scheduleContainer.scrollTop = scheduleScrollTop;
                  }, 0);

                  return;
                }
              }
            }

            // ========== 处理模板任务拖拽 ==========
                        if (originalTask.details && originalTask.details.isTemplate) {
              const fromType = getPartitionType(fromId);
              const toType = getPartitionType(toId);

              // 场景一：待办大分区内拖拽（移动操作）
              if (fromType === 'todo' && toType === 'todo') {
                // 找到所有子任务
                const childTasks = fromList.filter(t => t.parentId === originalTask.id);
                const allTasksToMove = [originalTask, ...childTasks];
                
                // 在待办大分区内：统一为移动操作（包括跨具体分区移动）
                if (true) {
                  // 基于数据索引找到所有要移动的任务
                  const tasksWithIndex = [];
                  const originalTaskIndex = findTaskIndexById(fromList, originalTask.id);

                  // 关键：先撤销SortableJS的DOM操作，恢复到拖拽前的原始状态
                  const movedItem = evt.item;
                  const parent = evt.from;
                  // 使用onStart时保存的nextSibling引用来恢复位置
                  const nextSibling = window.__dragFrom?.nextSibling;
                  // 把元素移回原位置
                  movedItem.remove();
                  if (nextSibling && nextSibling.parentNode === parent) {
                    parent.insertBefore(movedItem, nextSibling);
                  } else {
                    parent.appendChild(movedItem);
                  }

                  // 然后基于原始DOM状态计算插入位置（此时evt.newIndex指向的是目标位置）
                  // 修复：跨分区拖拽时，使用目标分区ID计算插入索引
                  const targetPartitionId = (fromId !== toId) ? toId : fromId;
                  let insertIndex = convertDomIndexToDataIndex(evt.newIndex, targetPartitionId, evt.to);

                  tasksWithIndex.push({ task: originalTask, originalIndex: originalTaskIndex });

                  // 找到子任务的索引
                  childTasks.forEach(child => {
                    const index = findTaskIndexById(fromList, child.id);
                    if (index !== -1) {
                      tasksWithIndex.push({ task: child, originalIndex: index });
                    }
                  });

                  // 按索引从大到小排序（从后往前删除避免索引变化）
                  tasksWithIndex.sort((a, b) => b.originalIndex - a.originalIndex);

                  // 删除所有任务
                  tasksWithIndex.forEach(item => {
                    fromList.splice(item.originalIndex, 1);
                  });
                  // 如果是向后拖拽，需要调整插入位置
                  if (originalTaskIndex < insertIndex) {
                    // 由于删除了前面的元素，插入位置需要前移，+1确保插入到目标位置之后
                    insertIndex = insertIndex - allTasksToMove.length + 1;
                  }
                  insertIndex = Math.max(0, insertIndex);

                  // 在新位置插入所有任务（保持原有顺序）
                  // 修复：跨分区拖拽时，应该插入到目标列表而不是源列表
                  const targetList = (fromId !== toId) ? toList : fromList;
                  targetList.splice(insertIndex, 0, ...allTasksToMove);
                  
                  // 自动收编插入位置后续的子任务
                  // 从插入位置开始，找到所有连续的level=1任务，直到遇到level=0任务或列表末尾
                  const startIndex = insertIndex + allTasksToMove.length;
                  const tasksToAdopt = [];

                  for (let i = startIndex; i < fromList.length; i++) {
                    const task = fromList[i];
                    if (task.level === 0) {
                      // 遇到主任务，停止收编
                      break;
                    }
                    if (task.level === 1) {
                      // 收集需要收编的子任务
                      tasksToAdopt.push(task);
                    }
                  }

                  // 更新被收编子任务的parentId
                  tasksToAdopt.forEach(task => {
                    task.parentId = originalTask.id;
                  });

                } else {
                  // 跨列表拖拽，SortableJS已经移动了DOM
                  // 先从目标列表删除SortableJS插入的元素
                  const movedIndex = toList.findIndex(t => t.id === originalTask.id);
                  if (movedIndex !== -1) {
                    toList.splice(movedIndex, 1);
                  }

                  // 从原列表删除所有任务
                  const tasksToRemove = [...allTasksToMove];
                  tasksToRemove.reverse().forEach(task => {
                    const index = fromList.indexOf(task);
                    if (index !== -1) {
                      fromList.splice(index, 1);
                    }
                  });

                  // 插入到目标列表（使用数据索引）
                  const insertIndex = convertDomIndexToDataIndex(evt.newIndex, toId, evt.to);
                  toList.splice(insertIndex, 0, ...allTasksToMove);

                  // 自动收编目标列表中插入位置后续的子任务
                  const startIndex = insertIndex + allTasksToMove.length;
                  const tasksToAdopt = [];

                  for (let i = startIndex; i < toList.length; i++) {
                    const task = toList[i];
                    if (task.level === 0) {
                      break;
                    }
                    if (task.level === 1) {
                      tasksToAdopt.push(task);
                    }
                  }

                  // 更新被收编子任务的parentId
                  tasksToAdopt.forEach(task => {
                    task.parentId = originalTask.id;
                  });
                }

                // 强制完全重新渲染，确保页面与数据同步
                clearDragHover();
                window.__dragFrom = null;
                window.__manualDropTargetId = null;

                // 销毁当前的SortableJS实例，避免DOM残留
                if (evt.from.__sortable) {
                  evt.from.__sortable.destroy();
                  evt.from.__sortable = null;
                }
                if (evt.to && evt.to.__sortable && evt.to !== evt.from) {
                  evt.to.__sortable.destroy();
                  evt.to.__sortable = null;
                }

                // 完全清空DOM并重建
                const todoList = document.getElementById('todoList');
                if (todoList) {
                  // 保存滚动位置
                  const scrollTop = todoList.scrollTop;

                  // 清空所有DOM
                  todoList.innerHTML = '';

                  // 强制浏览器重排
                  void todoList.offsetHeight;

                  // 调用render重新渲染整个页面
                  render(true);

                  // 恢复滚动位置
                  setTimeout(() => {
                    todoList.scrollTop = scrollTop;
                  }, 0);
                } else {
                  // 直接重新渲染
                  render(true);
                }

                return;
              }

              // 场景二：跨大分区拖拽（复制操作）
              if (fromType === 'todo' && toType === 'schedule') {
                // 1. 恢复DOM（撤销SortableJS的移动）
                if (evt.item && evt.from) {
                  evt.item.remove();
                  if (evt.oldIndex < evt.from.children.length) {
                    evt.from.insertBefore(evt.item, evt.from.children[evt.oldIndex]);
                  } else {
                    evt.from.appendChild(evt.item);
                  }
                }

                // 2. 创建副本
                const newTaskId = generateTaskId();
                const copiedTask = {
                  ...originalTask,
                  id: newTaskId,
                  details: {
                    ...originalTask.details,
                    isTemplate: false
                  }
                };

                // 3. 复制子任务
                const childTasks = fromList.filter(t => t.parentId === originalTask.id);
                const copiedChildren = childTasks.map(child => ({
                  ...child,
                  id: generateTaskId(),
                  parentId: newTaskId
                }));

                // 4. 插入到目标位置（使用数据索引）
                const insertIndex = convertDomIndexToDataIndex(evt.newIndex, toId, evt.to);
                toList.splice(insertIndex, 0, copiedTask, ...copiedChildren);

                // 强制完全重新渲染，确保页面与数据同步
                clearDragHover();
                window.__dragFrom = null;
                window.__manualDropTargetId = null;

                // 销毁当前的SortableJS实例，避免DOM残留
                if (evt.from.__sortable) {
                  evt.from.__sortable.destroy();
                  evt.from.__sortable = null;
                }
                if (evt.to && evt.to.__sortable && evt.to !== evt.from) {
                  evt.to.__sortable.destroy();
                  evt.to.__sortable = null;
                }

                // 完全清空DOM并重建
                const scheduleContainer = document.getElementById('schedule');
                const todoList = document.getElementById('todoList');

                // 保存滚动位置
                const todoScrollTop = todoList ? todoList.scrollTop : 0;
                const scheduleScrollTop = scheduleContainer ? scheduleContainer.scrollTop : 0;

                // 清空DOM
                if (todoList) {
                  todoList.innerHTML = '';
                }
                if (scheduleContainer) {
                  scheduleContainer.innerHTML = '';
                }

                // 强制浏览器重排
                if (todoList) void todoList.offsetHeight;
                if (scheduleContainer) void scheduleContainer.offsetHeight;

                // 调用render重新渲染整个页面
                render(true);

                // 恢复滚动位置
                setTimeout(() => {
                  if (todoList) todoList.scrollTop = todoScrollTop;
                  if (scheduleContainer) scheduleContainer.scrollTop = scheduleScrollTop;
                }, 0);

                return;
              }
            }

            // ========== 原有的周期任务和普通任务处理 ==========
            if (originalTask.isRecurring && fromId !== toId) {
              // 检查是否为周期任务跨区拖拽

              // 复制周期任务并变为普通任务
              const copiedTask = copyRecurringTask(originalTask, toId);
              const insertIndex = convertDomIndexToDataIndex(evt.newIndex, toId, evt.to);
              toList.splice(insertIndex, 0, copiedTask);

              // 原周期任务需要恢复到原位置（因为SortableJS已经在DOM层面移动了）
              // 确保原任务还在原列表中
              if (!fromList.includes(originalTask)) {
                const taskIndex = findTaskIndexById(fromList, originalTask.id);
                if (taskIndex === -1) {
                  const originalIndex = window.__dragFrom?.index || 0;
                  fromList.splice(originalIndex, 0, originalTask);
                }
              }

              adjustBadgesAfterMove(null, toId, copiedTask); // fromId为null表示只更新目标

            } else if (originalTask.isRecurring && fromId === toId) {
              // 周期任务在同区内拖拽 - 正常移动
              const taskIndex = findTaskIndexById(fromList, originalTask.id);
              const moved = fromList.splice(taskIndex,1)[0];
              const insertIndex = convertDomIndexToDataIndex(evt.newIndex, toId, evt.to);
              toList.splice(insertIndex,0,moved);

              // 智能层级管理：更新子任务的 parentId
              adjustTaskLevel(moved, toList, insertIndex, toId);
            } else {
              // 普通任务移动
              if (originalTask.level === 0) {
                // 父任务拖拽：带上所有子任务
                const childTasks = fromList.filter(t => t.parentId === originalTask.id);
                const allTasksToMove = [originalTask, ...childTasks];
                if (fromId === toId) {
                  // 同区拖拽
                  const originalTaskIndex = findTaskIndexById(fromList, originalTask.id);
                  // 先撤销SortableJS的DOM移动，恢复原始状态
                  if (evt.item && evt.from) {
                    evt.item.remove();
                    if (evt.oldIndex < evt.from.children.length) {
                      evt.from.insertBefore(evt.item, evt.from.children[evt.oldIndex]);
                    } else {
                      evt.from.appendChild(evt.item);
                    }
                  }
                  let insertIndex = convertDomIndexToDataIndex(evt.newIndex, fromId, evt.to);
                  const tasksWithIndex = allTasksToMove.map(task => ({
                    task,
                    originalIndex: fromList.indexOf(task)
                  }));
                  tasksWithIndex.sort((a, b) => b.originalIndex - a.originalIndex);
                  tasksWithIndex.forEach(item => {
                    fromList.splice(item.originalIndex, 1);
                  });
                  if (originalTaskIndex < insertIndex) {
                    insertIndex = insertIndex - allTasksToMove.length + 1;
                  }
                  insertIndex = Math.max(0, insertIndex);
                  fromList.splice(insertIndex, 0, ...allTasksToMove);
                  const startIndex = insertIndex + allTasksToMove.length;
                  const tasksToAdopt = [];
                  for (let i = startIndex; i < fromList.length; i++) {
                    const task = fromList[i];
                    if (task.level === 0) break;
                    if (task.level === 1) tasksToAdopt.push(task);
                  }
                  tasksToAdopt.forEach(task => {
                    task.parentId = originalTask.id;
                  });
                } else {
                  // 跨区拖拽
                  const movedIndex = toList.findIndex(t => t.id === originalTask.id);
                  if (movedIndex !== -1) {
                    toList.splice(movedIndex, 1);
                  }
                  const tasksToRemove = [...allTasksToMove];
                  tasksToRemove.reverse().forEach(task => {
                    const index = fromList.indexOf(task);
                    if (index !== -1) {
                      fromList.splice(index, 1);
                    }
                  });
                  const insertIndex = convertDomIndexToDataIndex(evt.newIndex, toId, evt.to);
                  toList.splice(insertIndex, 0, ...allTasksToMove);
                  const startIndex = insertIndex + allTasksToMove.length;
                  const tasksToAdopt = [];
                  for (let i = startIndex; i < toList.length; i++) {
                    const task = toList[i];
                    if (task.level === 0) break;
                    if (task.level === 1) tasksToAdopt.push(task);
                  }
                  tasksToAdopt.forEach(task => {
                    task.parentId = originalTask.id;
                  });
                }
                adjustBadgesAfterMove(fromId, toId, originalTask);
              } else {
                // 子任务拖拽
                const taskIndex = findTaskIndexById(fromList, originalTask.id);
                const moved = fromList.splice(taskIndex,1)[0];
                const insertIndex = convertDomIndexToDataIndex(evt.newIndex, toId, evt.to);
                toList.splice(insertIndex,0,moved);
                adjustTaskLevel(moved, toList, insertIndex, toId);
                adjustBadgesAfterMove(fromId, toId, moved);
              }
            }

            clearDragHover();
            window.__dragFrom = null;
            window.__manualDropTargetId = null;
            render(true);
            return;
          }

          // 落在折叠 header 上
          const headerTarget = window.__manualDropTargetId;
          if (headerTarget && window.__dragFrom){
            const srcList = getTasksById(window.__dragFrom.id);
            // 使用保存的原始任务引用，避免DOM操作后索引错乱
            const originalTask = window.__dragFrom.originalTask || srcList[window.__dragFrom.index];

            // 检查是否为模板任务拖拽到header
            if (originalTask.details && originalTask.details.isTemplate) {
              const fromType = getPartitionType(window.__dragFrom.id);
              const toType = getPartitionType(headerTarget);

              // 场景：待办大分区内拖到header - 移动到末尾（包括子任务）
              if (fromType === 'todo' && toType === 'todo') {
                // 1. 找到所有子任务
                const childTasks = srcList.filter(t => t.parentId === originalTask.id);

                // 2. 移除模板任务和所有子任务
                const allTasksToMove = [originalTask, ...childTasks];
                allTasksToMove.forEach(task => {
                  const idx = srcList.indexOf(task);
                  if (idx !== -1) {
                    srcList.splice(idx, 1);
                  }
                });

                // 3. 添加到末尾
                srcList.push(...allTasksToMove);
              }
            } else if (originalTask.isRecurring && window.__dragFrom.id !== headerTarget) {
              // 检查是否为周期任务跨区拖拽到header

              // 复制周期任务并变为普通任务
              const copiedTask = copyRecurringTask(originalTask, headerTarget);
              const dstList = getTasksById(headerTarget);
              dstList.push(copiedTask); // 放到该分区末尾

              adjustBadgesAfterMove(null, headerTarget, copiedTask);
            } else if (originalTask.isRecurring && window.__dragFrom.id === headerTarget) {
              // 周期任务拖拽到同分区header - 保持原位不动
              // 不进行任何移动操作
            } else {
              // 普通任务移动
              if (originalTask.level === 0) {
                // 父任务拖拽到header：带上所有子任务
                const childTasks = srcList.filter(t => t.parentId === originalTask.id);
                const allTasksToMove = [originalTask, ...childTasks];
                allTasksToMove.forEach(task => {
                  const idx = srcList.indexOf(task);
                  if (idx !== -1) {
                    srcList.splice(idx, 1);
                  }
                });
                const dstList = getTasksById(headerTarget);
                dstList.push(...allTasksToMove);
                adjustBadgesAfterMove(window.__dragFrom.id, headerTarget, originalTask);
              } else {
                // 子任务拖拽到header
                const moved = srcList.splice(window.__dragFrom.index, 1)[0];
                const dstList = getTasksById(headerTarget);
                dstList.push(moved);
                adjustTaskLevel(moved, dstList, dstList.length - 1, headerTarget);
                adjustBadgesAfterMove(window.__dragFrom.id, headerTarget, moved);
              }
            }
          }

          // 清理
          window.__manualDropTargetId = null;
          window.__dragFrom = null;
          clearDragHover();
          render(true);
        }
      });

      // 保存实例引用以便后续操作
      listEl.sortableInstance = sortableInstance;
    }

    // 将 bindSortable 暴露到全局，以便在自动展开时调用
    window.bindSortable = bindSortable;


    /**
     * 处理任务折叠/展开并强制完整DOM重建
     * @param {Object} task - 要折叠/展开的任务
     * @param {boolean} enableDrag - 是否启用拖拽
     */
    function toggleTaskCollapse(task, enableDrag) {
      // 保存当前滚动位置
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

      // 切换折叠状态
      task.collapsed = !task.collapsed;

      // 销毁所有SortableJS实例
      document.querySelectorAll('.task-list').forEach(listEl => {
        if (listEl.sortableInstance) {
          listEl.sortableInstance.destroy();
          listEl.sortableInstance = null;
          listEl.__sortableBound = false;
        }
      });

      // 强制DOM重建 - 待办分区
      const todoList = document.getElementById('todoList');
      if (todoList) {
        todoList.innerHTML = '';
        void todoList.offsetHeight; // 强制浏览器重排
      }

      // 强制DOM重建 - 日程分区
      const scheduleEl = document.getElementById('scheduleEl');
      if (scheduleEl) {
        scheduleEl.innerHTML = '';
        void scheduleEl.offsetHeight; // 强制浏览器重排
      }

      // 完整重新渲染
      render(enableDrag);

      // 恢复滚动位置
      window.scrollTo(0, scrollTop);
    }

    /**
     * 保存所有输入框中的文本内容到数据模型
     * @description 遍历页面上所有的任务输入框，将当前内容同步到二维数组数据中
     */
    function saveAllInputs(){
      document.querySelectorAll('.task-input').forEach(input=>{
        const wrap=input.closest('.task-wrapper');
        if(!wrap || wrap.classList.contains('placeholder-row')) return;

        // **关键修复**: 通过task-id匹配,而不是DOM索引
        const taskId = wrap.dataset.taskId;
        if(!taskId) return;

        // 查找对应的任务对象
        const result = findTaskById(taskId);
        if(result && result.task){
          result.task.text = (input.textContent||'').trim();
        }
      });
    }

    /**
     * ===== 主要渲染函数 =====
     */

    /**
     * 渲染待办事项区域
     * @param {boolean} enableDrag - 是否启用拖拽功能
     * @description 渲染待办事项分区，包括任务列表、折叠状态、拖拽排序等功能
     */
    function renderTodo(enableDrag){
      const todoPartition = getTodoPartition();
      if (!todoPartition) return;

      const todoMeta = (todoPartition.meta = todoPartition.meta || {});
      const collapsed = !!todoMeta.collapsed;

      const todoSection = document.getElementById('todoSection');
      // 设置分区和列表的data-id
      todoSection.dataset.id = todoPartition.id;

      // 设置条纹色以便 drop-hint 颜色一致
      const stripeColor = getStripeColor("📋", "待办");
      todoSection.style.setProperty('--stripe-color', stripeColor);
      todoSection.style.setProperty('--stripe-soft', softColor(stripeColor, 0.12));

      // 总是使用多分区渲染方式，保持样式一致
      todoMeta.multiPartitionReady = true;
      const allTodoPartitions = getTodoPartitions();
      renderMultipleTodoPartitions(enableDrag);
    }

    /**
     * 渲染多个待办分区
     * @param {boolean} enableDrag - 是否启用拖拽功能
     * @description 当检测到多分区模式时，渲染多个待办子分区
     */
    function renderMultipleTodoPartitions(enableDrag) {
      const todoSection = document.getElementById('todoSection');
      const todoPartitions = getTodoPartitions();

      // 清空待办区域，准备渲染多个分区
      const todoList = document.getElementById('todoList');
      todoList.innerHTML = '';

      // 渲染每个待办分区（类似日程分区的方式）
      todoPartitions.forEach((partition, index) => {
        const tasks = partition.tasks || [];
        const icon = partition.meta?.icon || "📋";
        const plainTitle = stripLeadingEmojiByIcon(partition.title, icon);

        // 创建分区容器（与日程分区保持一致的结构）
        const partitionDiv = document.createElement('div');
        partitionDiv.className = 'partition todo-partition';
        partitionDiv.dataset.id = partition.id;

        const bm = ensureBadgeMeta(partition, plainTitle);
        const stripeColor = getStripeColor(partition, bm.titleNoFrac || plainTitle).trim() || '#C7C7CC';
        partitionDiv.style.setProperty('--stripe-color', stripeColor);
        partitionDiv.style.setProperty('--stripe-soft', softColor(stripeColor, 0.12));

        // 创建左侧条纹（与日程分区保持一致的DOM结构，通过CSS隐藏）
        const stripe = document.createElement('div');
        stripe.className = 'partition-stripe';
        stripe.style.background = stripeColor;
        partitionDiv.appendChild(stripe);

        // 创建header
        const header = document.createElement('div');
        header.className = 'partition-header';

        // 待办分区不需要图标
        const iconWrap = null;

        // 标题：所有分区都可编辑
        const titleTextEl = document.createElement('span');
        titleTextEl.className = 'section-title';
        titleTextEl.contentEditable = 'true';

        // 使用实际保存的标题，优先使用partition.title，然后是meta.titleNoFrac，最后是plainTitle
        const currentTitle = partition.title || partition.meta?.titleNoFrac || plainTitle;
        titleTextEl.textContent = currentTitle;

          // 添加编辑事件
          titleTextEl.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              titleTextEl.blur(); // 触发失焦事件
            }
            if (e.key === 'Escape') {
              e.preventDefault();
              // 使用当前保存的标题进行恢复
              const currentTitle = partition.title || partition.meta?.titleNoFrac || plainTitle;
              titleTextEl.textContent = currentTitle;
              titleTextEl.blur();
            }
          });

          // 失焦事件：保存标题但保持可编辑状态
          titleTextEl.addEventListener('blur', () => {
            const newTitle = (titleTextEl.textContent || '').trim();
            if (newTitle) {
              // 保存新标题，同时更新partition.title和meta.titleNoFrac
              partition.title = newTitle;
              if (!partition.meta) partition.meta = {};
              partition.meta.titleNoFrac = newTitle;
            } else {
              // 如果标题为空，恢复当前保存的标题
              const currentTitle = partition.title || partition.meta?.titleNoFrac || plainTitle;
              titleTextEl.textContent = currentTitle;
            }
            // 保持可编辑状态，允许再次编辑
          });
  
        const titleBox = document.createElement('div');
        titleBox.className = 'partition-title';
        titleBox.appendChild(titleTextEl);

        // 徽标
        const badge = document.createElement('span');
        badge.className = 'badge';
        // bm已经在上面声明过了，不需要重复声明
        const numsDone = (bm.baseDone || 0) + (bm.dDone || 0);
        const numsTotal = (bm.baseTotal || 0) + (bm.dTotal || 0);
        badge.textContent = `${numsDone}/${numsTotal}`;

        // 折叠功能
        const list = document.createElement('div');
        list.className = 'task-list';
        list.dataset.id = partition.id;
        const collapsed = !!partition.meta?.collapsed;
        if(collapsed) list.classList.add('collapsed');
        badge.classList.toggle('is-collapsed', collapsed);

        function toggleCollapse() {
          const c = !list.classList.contains('collapsed');
          list.classList.toggle('collapsed', c);
          partition.meta = partition.meta || {};
          partition.meta.collapsed = c;
          badge.classList.toggle('is-collapsed', c);
          render(enableDrag);
        }

        badge.addEventListener('click', toggleCollapse);
        badge.addEventListener('keydown', (e) => {
          if(e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            toggleCollapse();
          }
        });

        const rightBox = document.createElement('div');
        rightBox.className = 'right-box';
        rightBox.appendChild(badge);

        // 组装header（待办分区不添加图标）
        // 添加一个空的div以保持布局
        const emptyDiv = document.createElement('div');
        emptyDiv.style.width = '0';
        header.appendChild(emptyDiv);
        header.appendChild(titleBox);
        header.appendChild(rightBox);

        partitionDiv.appendChild(header);

        // 渲染任务列表
        tasks.forEach(task => {
          // 如果是子任务且父任务折叠了，跳过渲染
          if (task.level > 0) {
            const parentTask = tasks.find(t => t.id === task.parentId);
            if (parentTask && parentTask.collapsed) {
              return; // 跳过折叠的子任务
            }
          }

          const taskItem = createTaskElement(task, partition.id, enableDrag);
          list.appendChild(taskItem);
        });

        // 添加任务输入框（即使折叠也要添加，以便展开后可以立即使用）
        const input = createTaskInput(partition.id);
        list.appendChild(input);

        partitionDiv.appendChild(list);

        // 设置拖拽 - 为所有分区初始化 Sortable（包括折叠的）
        // 这样在自动展开时就已经有 Sortable 实例了
        if (enableDrag && window.Sortable) {
          bindSortable(list, enableDrag);
          // 如果是折叠状态，暂时禁用 Sortable
          if (collapsed && list.sortableInstance) {
            list.sortableInstance.option('disabled', true);
          }
        }

        // 绑定：当该待办子分区折叠时，支持拖拽悬停到 header 上放入/展开
        bindHeaderHoverForCollapsed({
          partitionEl: partitionDiv,
          headerEl: header,
          partitionId: partition.id,
          getMeta: () => (partition.meta = partition.meta || {}),
          onExpand: () => {
            partition.meta.collapsed = false;
            // 不调用 render() 以保持拖拽状态，与日程分区保持一致
          }
        });

        // 第一个分区默认展开，其余折叠
        if (index > 0 && !partition.meta?.hasOwnProperty('collapsed')) {
          partition.meta = partition.meta || {};
          partition.meta.collapsed = true;
          list.classList.add('collapsed');
          badge.classList.add('is-collapsed');
        }

        todoList.appendChild(partitionDiv);

              });

      // 渲染后检查是否需要聚焦到输入框
      if (window.__focusPlaceholderFor) {
        const targetPartitionId = window.__focusPlaceholderFor;
        setTimeout(() => {
          const targetList = document.querySelector(`.task-list[data-id="${targetPartitionId}"]`);
          if (targetList) {
            const phTxt = targetList.querySelector('.task-input.placeholder');
            if (phTxt) {
              phTxt.focus();
              phTxt.scrollIntoView({ block: 'nearest', inline: 'nearest' });
            }
          }
          window.__focusPlaceholderFor = null;
        }, 0);
      }
    }

    /**
     * 在指定分区中，当前任务下方创建新任务并聚焦
     * @param {Object} currentTask - 当前任务对象
     * @param {string} partitionId - 分区ID
     */
    function createNewTaskBelowInPartition(currentTask, partitionId) {
      // 获取分区信息
      const partition = findPartitionById(partitionId);
      if (!partition || !partition.tasks) return;

      // 找到当前任务在分区中的索引
      const currentIndex = partition.tasks.findIndex(t => t.id === currentTask.id);
      if (currentIndex === -1) return;

      // 创建新任务
      const newTask = {
        id: generateTaskId(),
        text: '',
        done: false,
        parentId: currentTask.parentId,  // 继承父任务关系
        level: currentTask.level        // 继承层级
      };

      // 在当前任务下方插入新任务
      const insertIndex = currentIndex + 1;
      partition.tasks.splice(insertIndex, 0, newTask);

      // 更新徽标计数
      if (partition.meta?.badge && newTask.level === 0) {
        partition.meta.badge.dTotal = (partition.meta.badge.dTotal || 0) + 1;
      }

      // 重新渲染
      sortSchedulesByTime();
      renderTodo(true);
      renderSchedules(true);

      // 延迟聚焦到新创建的任务
      setTimeout(() => {
        focusToTaskById(newTask.id);
      }, 100);
    }

    /**
     * 聚焦到指定任务ID的任务
     * @param {string} taskId - 任务ID
     */
    function focusToTaskById(taskId) {
      // 查找新任务的输入框
      const taskElement = document.querySelector(`[data-task-id="${taskId}"] .task-input`);
      if (taskElement) {
        // 清除可能存在的内联样式
        taskElement.style.cssText = '';

        // 使用CSS类进行样式修复，避免内联样式的时序问题
        taskElement.classList.add('expanded', 'expanded-fixed');

        // 关键：添加正常的点击处理逻辑，与原有任务保持一致
        taskElement.onclick = () => {
          taskElement.classList.add('expanded', 'expanded-fixed');
          taskElement.focus();
        };

        // 关键：添加失焦事件处理，与原有逻辑保持一致
        const handleBlur = () => {
          taskElement.classList.remove('expanded', 'expanded-fixed');
          // 保存任务文本内容（如果需要的话）
          const taskResult = findTaskById(taskId);
          if (taskResult && taskResult.task) {
            taskResult.task.text = (taskElement.textContent || '').trim();
          }
        };

        // 使用 { once: true } 确保只执行一次，避免重复绑定
        taskElement.addEventListener('blur', handleBlur, { once: true });

        taskElement.focus();
        taskElement.scrollIntoView({ block: 'nearest', inline: 'nearest' });

        // 选中文本内容（虽然是空的，但为了更好的用户体验）
        const selection = window.getSelection();
        const range = document.createRange();
        range.selectNodeContents(taskElement);
        selection.removeAllRanges();
        selection.addRange(range);
      }
    }

    /**
     * 创建任务元素
     * @param {Object} task - 任务对象
     * @param {string} partitionId - 分区ID
     * @param {boolean} enableDrag - 是否启用拖拽
     * @returns {HTMLElement} 任务元素
     */
    function createTaskElement(task, partitionId, enableDrag) {
      const wrap = document.createElement('div');
      wrap.className = 'task-wrapper';
      wrap.dataset.taskId = task.id;

      const del = document.createElement('div');
      del.className = 'task-delete';
      del.textContent = '删除';

      // 创建层级操作按钮
      const actions = document.createElement('div');
      actions.className = 'task-actions';

      // 获取分区对象
      const partition = findPartitionById(partitionId);
      const tasks = partition?.tasks || [];

      if (task.level === 0) {
        // 主任务：检查是否位于分区顶部且非模板任务
        const taskIndex = tasks.findIndex(t => t.id === task.id);
        const isTemplate = task.details?.isTemplate;
        if (taskIndex > 0 && !isTemplate) {
          // 不在顶部且非模板任务，显示缩进按钮
          const indentBtn = document.createElement('div');
          indentBtn.className = 'task-indent';
          indentBtn.textContent = '缩进';
          indentBtn.onclick = (e) => {
            e.stopPropagation();
            indentTask(task, partitionId);
          };
          actions.appendChild(indentBtn);

          // 调整删除按钮位置
          del.className = 'task-delete with-level';
          actions.className = 'task-actions with-delete';
        }
      } else {
        // 子任务：检查父任务是否为模板任务
        const parentTask = tasks.find(t => t.id === task.parentId);
        const isParentTemplate = parentTask?.details?.isTemplate;
        if (!isParentTemplate) {
          // 父任务非模板任务，显示减少缩进按钮
          const outdentBtn = document.createElement('div');
          outdentBtn.className = 'task-outdent';
          outdentBtn.textContent = '减少缩进';
          outdentBtn.onclick = (e) => {
            e.stopPropagation();
            outdentTask(task, partitionId);
          };
          actions.appendChild(outdentBtn);
        }

        // 调整删除按钮位置
        del.className = 'task-delete with-level';
        actions.className = 'task-actions with-delete';
      }

      const row = document.createElement('div');
      row.className = 'task' + (task.level > 0 ? ` level-${task.level}` : '');
      const box = document.createElement('div');

      // 判断是否为模板任务（主任务或继承父任务模板状态的子任务）
      let isTemplateTask = false;
      if (task.level === 0) {
        // 主任务：直接检查自身的模板状态
        isTemplateTask = task.details && task.details.isTemplate;

        // Done+任务和模板任务可以共存，移除强制保护
      } else {
        // 子任务：检查父任务是否为模板任务
        const parentTask = tasks.find(t => t.id === task.parentId);
        isTemplateTask = parentTask && parentTask.details && parentTask.details.isTemplate;
      }

      // 根据任务类型设置checkbox样式
      let checkboxClass = 'checkbox';
      if (isTemplateTask) {
        checkboxClass += ' template';
      } else if (task.isRecurring) {
        checkboxClass += ' recurring';
        // 如果启用了Done+功能，添加特殊CSS类
        if (task.donePlus && task.donePlus.enabled) {
          checkboxClass += ' has-done-plus';
        }
        if (task.isGeneratedFromRecurring) {
          // 这是由周期任务生成的任务，空心样式（可勾选）
        } else {
          // 这是周期任务模板，实心样式（不可勾选）
          checkboxClass += ' filled';
        }
      } else if (task.done) {
        checkboxClass += ' done';
      }

      box.className = checkboxClass;

      // 添加Done+角标（如果启用）
      if (task.donePlus && task.donePlus.enabled) {
        const badge = document.createElement('div');
        badge.className = 'done-plus-badge';
        badge.textContent = '+';
        box.style.position = 'relative';
        box.appendChild(badge);
      }

      // 模板任务不可被勾选完成
      // 周期任务模板可以点击Done+功能
      if (isTemplateTask) {
        box.onclick = null; // 禁用点击事件
      } else {
        box.onclick = () => {
          // 检查是否启用了Done+功能
          if (task.donePlus && task.donePlus.enabled) {

            // 如果任务已完成且有笔记，显示Done+表单进行编辑
            if (task.done && task.donePlus.note && task.donePlus.note.trim()) {
              showDonePlusForm(task, partitionId);
            }
            // 如果任务未完成，显示Done+表单进行完成
            else if (!task.done) {
              showDonePlusForm(task, partitionId);
            }
            // 已完成但没有笔记或有空笔记，显示表单可以添加笔记
            else if (task.done && (!task.donePlus.note || !task.donePlus.note.trim())) {
              showDonePlusForm(task, partitionId);
            }
            // 其他情况使用标准完成逻辑
            else {
              completeTask(task, partitionId);
            }
          } else {
            // 标准完成任务逻辑
            completeTask(task, partitionId);
          }
        };
      }

      const txt = document.createElement('div');
      txt.className = 'task-input';
      txt.contentEditable = 'true';


      txt.textContent = task.text || '';
      txt.onclick = () => txt.classList.add('expanded');
      txt.onblur = () => {
        txt.classList.remove('expanded');
        if(document.contains(txt) && txt.textContent !== null){
          task.text = txt.textContent || '';
        }
      };
      txt.addEventListener('input', () => {
        task.text = txt.textContent || '';
      });
      // 添加键盘事件处理：按回车创建新任务
      txt.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') {
          e.preventDefault();
          // 保存当前任务
          task.text = txt.textContent || '';
          txt.classList.remove('expanded');

          // 创建新任务并聚焦
          createNewTaskBelowInPartition(task, partitionId);
        } else if (e.key === 'Escape') {
          e.preventDefault();
          txt.textContent = task.text || '';
          txt.classList.remove('expanded');
        }
      });

      const handle = document.createElement('div');
      handle.className = 'task-handle';
      handle.textContent = '≡';
      handle.onclick = (e) => {
        e.stopPropagation();
        // 延迟检查，给模块加载更多时间
        setTimeout(() => {
          if (window.toggleInlineEdit) {
            window.toggleInlineEdit(task, partitionId, handle);
          } else {
            console.error('toggleInlineEdit function not available, retrying...');
            // 再次尝试，如果还是失败就等待更长时间
            setTimeout(() => {
              if (window.toggleInlineEdit) {
                window.toggleInlineEdit(task, partitionId, handle);
              } else {
                console.error('toggleInlineEdit function still not available after delay');
              }
            }, 100);
          }
        }, 10);
      };

      // 添加元素到row
      row.appendChild(box);
      row.appendChild(txt);

      // 检查是否有子任务
      const hasChildren = task.level === 0 && tasks.some(t => t.parentId === task.id);

      // 如果有子任务，在拖拽把手左侧添加折叠图标
      if (hasChildren) {
        const collapseIcon = document.createElement('div');
        collapseIcon.className = 'task-collapse';

        // 创建SVG图标 - 根据折叠状态选择箭头
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('class', 'collapse-icon-svg');
        svg.setAttribute('viewBox', '0 0 24 24');
        svg.setAttribute('fill', 'none');
        svg.setAttribute('stroke', 'currentColor');
        svg.setAttribute('stroke-width', '1.8');
        svg.setAttribute('stroke-linecap', 'round');
        svg.setAttribute('stroke-linejoin', 'round');
        svg.setAttribute('aria-label', task.collapsed ? 'chevron-right' : 'chevron-down');

        if (task.collapsed) {
          // 收缩状态：向右箭头
          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.setAttribute('d', 'M9 6l6 6-6 6');
          svg.appendChild(path);
          collapseIcon.classList.add('collapsed');
        } else {
          // 展开状态：向下箭头
          const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
          path.setAttribute('d', 'M6 9l6 6 6-6');
          svg.appendChild(path);
        }

        collapseIcon.appendChild(svg);

        collapseIcon.onclick = (e) => {
          e.stopPropagation();
          toggleTaskCollapse(task, enableDrag);
        };

        row.appendChild(collapseIcon);
      }

      row.appendChild(handle);
      wrap.appendChild(del);
      wrap.appendChild(actions);
      wrap.appendChild(row);

      // 添加内联编辑容器
      const inlineEditContainer = document.createElement('div');
      inlineEditContainer.className = 'inline-edit-container';
      wrap.appendChild(inlineEditContainer);

      // 添加缩略信息显示
      const taskSummary = createTaskSummaryElement(task);
      if (taskSummary) {
        wrap.appendChild(taskSummary);
      }

      // 绑定滑动手势
      attachSwipeToDelete(row, del);

      return wrap;
    }

    /**
     * 创建任务输入框
     * @param {string} partitionId - 分区ID
     * @returns {HTMLElement} 任务输入框元素
     */
    function createTaskInput(partitionId) {
      const partition = findPartitionById(partitionId);
      const tasks = partition?.tasks || [];

      const phWrap = document.createElement('div');
      phWrap.className = 'task-wrapper placeholder';
      const phRow = document.createElement('div');
      phRow.className = 'task';
      const phBox = document.createElement('div');
      phBox.className = 'checkbox placeholder';
      const phTxt = document.createElement('div');
      phTxt.className = 'task-input placeholder';
      phTxt.contentEditable = 'true';
      phTxt.textContent = '';
      phTxt.setAttribute('data-placeholder', '请输入...');

      // 设置占位符样式
      phTxt.style.pointerEvents = 'auto';
      phBox.style.pointerEvents = 'auto';

      // 点击任何地方都聚焦到文本框
      phBox.onclick = () => phTxt.focus();
      phTxt.onclick = () => phTxt.focus();

      // 占位符不需要拖拽图标，禁用pointer事件避免干扰
      const phHandle = document.createElement('div');
      phHandle.className = 'task-handle';
      phHandle.style.visibility = 'hidden';
      phHandle.style.pointerEvents = 'none';

      let isCommittingTodo = false; // 防重复提交标志

      function commit() {
        const v = (phTxt.textContent || '').trim();
        if (!v || isCommittingTodo) return;

        isCommittingTodo = true;

        const todoPartitions = data[0];
        const targetPartition = todoPartitions.find(p => p.id === partitionId);

        if (targetPartition && targetPartition.tasks) {
          const newTask = {
            id: generateTaskId(),
            text: v,
            done: false,
            parentId: null,
            level: 0
          };
          targetPartition.tasks.push(newTask);
          // 更新徽标计数（仅父任务，使用dTotal统计动态添加的任务）
          if (targetPartition.meta?.badge && newTask.level === 0) {
            targetPartition.meta.badge.dTotal = (targetPartition.meta.badge.dTotal || 0) + 1;
          }
        }

        phTxt.textContent = '';
        window.__focusPlaceholderFor = partitionId;

        // 直接调用渲染函数，跳过saveAllInputs以避免清空新添加的任务
        sortSchedulesByTime();
        renderTodo(true);
        renderSchedules(true);
      }

      phTxt.addEventListener('keydown', e => {
        if (e.key === 'Enter') {
          e.preventDefault();
          commit();
          phTxt.blur(); // 主动失焦，避免blur事件重复触发
        } else if (e.key === 'Escape') {
          e.preventDefault();
          phTxt.textContent = '';
          phTxt.blur();
        }
      });

      phTxt.addEventListener('blur', () => {
        setTimeout(() => {
          if (!isCommittingTodo) commit();
        }, 100);
      });

      phRow.appendChild(phBox);
      phRow.appendChild(phTxt);
      phRow.appendChild(phHandle);
      phWrap.appendChild(phRow);

      return phWrap;
    }

    /**
     * 创建新的待办子分区
     * @param {string} title - 分区标题
     * @returns {Object} 新创建的待办分区
     */
    function createTodoSubPartition(title = '新待办分区') {
      const todoPartitions = getTodoPartitions();
      const newPartition = {
        id: generatePartitionId(),
        title: `📋${title}`,
        meta: {
          time: "",
          icon: "📋",
          collapsed: true,  // 新分区默认折叠
          isTodoPartition: true,
          isFirstTodo: false
        },
        tasks: []
      };

      // 添加到待办分区数组
      data[0].push(newPartition);

      return newPartition;
    }

    /**
     * 启用多待办分区模式
     * @description 将现有单分区转换为多分区模式，并创建额外的分区
     */
    function enableMultipleTodoPartitions() {
      const todoPartitions = getTodoPartitions();

      if (todoPartitions.length === 0) {
        return false;
      }

      // 标记第一个分区为多分区模式
      const firstPartition = todoPartitions[0];
      firstPartition.meta.multiPartitionReady = true;

      // 创建额外的待办分区（如果还没有）
      if (todoPartitions.length === 1) {
        createTodoSubPartition('待办事项列表2');
        createTodoSubPartition('待办事项列表3');
      }


      // 重新渲染
      render(!!window.Sortable);

      return true;
    }

    // 将多分区功能暴露到全局，供用户手动启用
    window.enableMultipleTodoPartitions = enableMultipleTodoPartitions;
    window.createTodoSubPartition = createTodoSubPartition;

    /**
     * 渲染所有日程分区
     * @param {boolean} enableDrag - 是否启用拖拽功能
     * @description 渲染所有日程分区，包括竖条、图标、时间、进度徽标、任务列表等
     */
    function renderSchedules(enableDrag){
      const bucket=document.getElementById('timeInputsBucket'); bucket.innerHTML='';
      const container=document.getElementById('schedule'); container.innerHTML='';

      getSchedulePartitions().forEach((partition) => {

        const tasks = partition.tasks || [];
        const isAllDay = isAllDaySchedule(partition);

        // 全天日程分区的特殊处理
        let icon, plainTitle;
        if (isAllDay) {
          icon = '';  // 无图标
          plainTitle = '全天日程';  // 固定标题
        } else {
          icon = (partition.meta && partition.meta.icon) || firstCodePoint(partition.title) || '🗂️';
          plainTitle = stripLeadingEmojiByIcon(partition.title, icon);
        }

        const partitionDiv = document.createElement('div');
        partitionDiv.className = 'partition';
        if (isAllDay) {
          partitionDiv.classList.add('allday-partition');
        }
        partitionDiv.dataset.id = partition.id;

        const bm = ensureBadgeMeta(partition, plainTitle);
        const stripeColor = isAllDay ? '#34c759' : (getStripeColor(partition, bm.titleNoFrac || plainTitle).trim() || '#C7C7CC');
        partitionDiv.style.setProperty('--stripe-color', stripeColor);
        partitionDiv.style.setProperty('--stripe-soft', softColor(stripeColor, 0.12));

        const stripe=document.createElement('div'); stripe.className='partition-stripe';
        stripe.style.background = stripeColor;
        // 全天日程分区不显示左侧竖线
        if (isAllDay) {
          stripe.style.display = 'none';
        }
        partitionDiv.appendChild(stripe);

        const header=document.createElement('div'); header.className='partition-header';

        // 全天日程分区不显示图标
        let iconWrap = null;
        if (!isAllDay) {
          iconWrap=document.createElement('div'); iconWrap.className='icon-wrap';
          iconWrap.innerHTML=`<div class="icon-emoji">${icon}</div>`;
          iconWrap.onclick = () => {
          // 直接使用badge meta中的titleNoFrac属性
          const titleText = bm.titleNoFrac;
          openPicker(partition.id, titleText);
        };
        }

        const titleTextEl=document.createElement('span'); titleTextEl.className='title-text';

        // 全天日程分区标题不可编辑
        if (isAllDay) {
          titleTextEl.textContent = plainTitle;
          titleTextEl.style.fontWeight = '700';
          titleTextEl.style.color = 'var(--stripe-color)';
        } else {
          titleTextEl.contentEditable='true';
          titleTextEl.textContent = bm.titleNoFrac || plainTitle;
          titleTextEl.addEventListener('keydown',(e)=>{
            if(e.key==='Enter'){e.preventDefault(); titleTextEl.blur();}
            if(e.key==='Escape'){e.preventDefault(); titleTextEl.textContent=bm.titleNoFrac; titleTextEl.blur();}
          });
        }

        // 标题编辑事件（仅非全天日程）
        if (!isAllDay) {
          titleTextEl.addEventListener('blur',()=>{
            const nt=(titleTextEl.textContent||'').trim();
            if(nt) bm.titleNoFrac=nt;
          });
        }

        const timeSpan=document.createElement('span'); timeSpan.className='partition-time';

        // 全天日程分区不显示时间编辑器
        if (isAllDay) {
          timeSpan.textContent = '全天';
          timeSpan.style.color = 'var(--stripe-color)';
          timeSpan.style.fontWeight = '600';
          timeSpan.style.fontSize = '12px';
        } else {
          const rawTime=(partition.meta && partition.meta.time)||'';
          const parsed = parseTimeRange(rawTime);

          if(parsed){
          let {prefix,start,end,suffix}=parsed;
          let tStart = roundToQuarter(start);
          let tEnd   = roundToQuarter(end);

          const sid=`start-${partition.id}`, eid=`end-${partition.id}`;

          const timeContainer = document.createElement('div');
          timeContainer.style.cssText = 'display:flex;align-items:center;gap:4px;';

          const sIn=document.createElement('input');
          sIn.type='time'; sIn.step='60'; sIn.value=tStart;
          sIn.className='time-input-native';
          sIn.style.cssText='padding:2px 6px;border:1px solid #ddd;border-radius:4px;font-size:11px;min-width:65px;background:#fff;';

          const dash=document.createElement('span'); dash.className='time-dash'; dash.textContent='-';

          const eIn=document.createElement('input');
          eIn.type='time'; eIn.step='60'; eIn.value=tEnd;
          eIn.className='time-input-native';
          eIn.style.cssText='padding:2px 6px;border:1px solid #ddd;border-radius:4px;font-size:11px;min-width:65px;background:#fff;';

          timeContainer.appendChild(sIn);
          timeContainer.appendChild(dash);
          timeContainer.appendChild(eIn);

          if(prefix) timeSpan.appendChild(document.createTextNode(prefix+' '));
          timeSpan.appendChild(timeContainer);
          if(suffix) timeSpan.appendChild(document.createTextNode(suffix));

          function commit(){
            partition.meta.time = `${prefix?prefix+' ':''}${tStart} - ${tEnd}${suffix||''}`;
            sortSchedulesByTime(); render(enableDrag);
          }

          // 确保点击iOS时间选择器的"完成"按钮才关闭并更新
          const keepDuration = ((toMin(tEnd) - toMin(tStart) + 1440) % 1440); // 计算原时长

          // 开始时间：使用blur事件确保只在点击"完成"时触发
          sIn.addEventListener('blur', () => {
            const picked = sIn.value || tStart;
            if (picked !== tStart) {
              tStart = picked;
              tEnd = fromMin((toMin(tStart) + keepDuration) % 1440);
              sIn.value = tStart;
              eIn.value = tEnd;
              if (navigator?.vibrate) navigator.vibrate(10);
              commit(); // 自动重新排序
            }
          });

          // 结束时间：使用blur事件确保只在点击"完成"时触发
          eIn.addEventListener('blur', () => {
            const picked = eIn.value || tEnd;
            if (picked !== tEnd) {
              tEnd = picked;
              eIn.value = tEnd;
              if (navigator?.vibrate) navigator.vibrate(10);
              commit(); // 自动重新排序
            }
          });
          }else if(rawTime){ timeSpan.textContent = stripWeekday(rawTime); }
        }

        const badge=document.createElement('span'); badge.className='badge';
        const numsDone=(bm.baseDone||0)+(bm.dDone||0);
        const numsTotal=(bm.baseTotal||0)+(bm.dTotal||0);
        badge.textContent=`${numsDone}/${numsTotal}`;

        // 折叠/展开
        const list=document.createElement('div'); list.className='task-list'; list.dataset.id = partition.id;
        const collapsed = !!partition.meta?.collapsed;
        if(collapsed) list.classList.add('collapsed');
        badge.classList.toggle('is-collapsed', collapsed);
        function toggleCollapse(){
          const c=!list.classList.contains('collapsed');
          list.classList.toggle('collapsed', c);
          partition.meta = partition.meta || {};
          partition.meta.collapsed = c;
          badge.classList.toggle('is-collapsed', c);
          render(enableDrag);
        }
        badge.addEventListener('click', toggleCollapse);
        badge.addEventListener('keydown', (e)=>{ if(e.key==='Enter' || e.key===' '){ e.preventDefault(); toggleCollapse(); } });

        const right=document.createElement('div'); right.className='right-box';
        right.appendChild(timeSpan); right.appendChild(badge);

        const titleBox=document.createElement('div'); titleBox.className='partition-title'; titleBox.appendChild(titleTextEl);

        // 组装header
        if (!isAllDay && iconWrap) {
          header.appendChild(iconWrap);
        }
        header.appendChild(titleBox);
        header.appendChild(right);

        // 为非全天日程分区添加删除功能（仅在折叠状态下可用）
        if (!isAllDay && !partition.meta?.fixed) {
          // 创建包装容器
          const wrapper = document.createElement('div');
          wrapper.className = 'partition-wrapper';

          const deleteBtn = document.createElement('div');
          deleteBtn.className = 'partition-delete';
          deleteBtn.textContent = '删除分区';
          deleteBtn.dataset.partitionId = partition.id;

          wrapper.appendChild(header);
          wrapper.appendChild(deleteBtn);
          header.classList.add('swipeable');


          // 为折叠状态的分区header绑定右滑删除功能
          attachPartitionSwipeToDelete(header, deleteBtn, partition);
          partitionDiv.appendChild(wrapper);
        } else {
          partitionDiv.appendChild(header);
        }

        // 任务
        tasks.forEach((task, taskIndex)=>{
          // 如果是子任务且父任务折叠了，跳过渲染
          if (task.level > 0) {
            const parentTask = tasks.find(t => t.id === task.parentId);
            if (parentTask && parentTask.collapsed) {
              return; // 跳过折叠的子任务
            }
          }
          const wrap=document.createElement('div'); wrap.className='task-wrapper';
          wrap.dataset.taskId = task.id; // 添加任务ID到DOM元素

          const del=document.createElement('div'); del.className='task-delete'; del.textContent='删除';

          // 创建层级操作按钮
          const actions=document.createElement('div'); actions.className='task-actions';

          if (task.level === 0) {
            // 主任务：检查是否位于分区顶部且非模板任务
            const taskIndex = tasks.findIndex(t => t.id === task.id);
            const isTemplate = task.details?.isTemplate;
            if (taskIndex > 0 && !isTemplate) {
              // 不在顶部且非模板任务，显示缩进按钮
              const indentBtn=document.createElement('div');
              indentBtn.className='task-indent';
              indentBtn.textContent='缩进';
              indentBtn.onclick = (e) => {
                e.stopPropagation();
                indentTask(task, partition.id);
              };
              actions.appendChild(indentBtn);

              // 调整删除按钮位置
              del.className='task-delete with-level';
              actions.className='task-actions with-delete';
            }
          } else {
            // 子任务：检查父任务是否为模板任务
            const parentTask = tasks.find(t => t.id === task.parentId);
            const isParentTemplate = parentTask?.details?.isTemplate;
            if (!isParentTemplate) {
              // 父任务非模板任务，显示减少缩进按钮
              const outdentBtn=document.createElement('div');
              outdentBtn.className='task-outdent';
              outdentBtn.textContent='减少缩进';
              outdentBtn.onclick = (e) => {
                e.stopPropagation();
                outdentTask(task, partition.id);
              };
              actions.appendChild(outdentBtn);
            }

            // 调整删除按钮位置
            del.className='task-delete with-level';
            actions.className='task-actions with-delete';
          }

          // 删除事件由全局事件委托处理，不需要单独绑定

          const row=document.createElement('div');
        row.className = 'task' + (task.level > 0 ? ` level-${task.level}` : '');
          const box=document.createElement('div');

          // 判断是否为模板任务（主任务或继承父任务模板状态的子任务）
          let isTemplateTask = false;
          if (task.level === 0) {
            // 主任务：直接检查自身的模板状态
            isTemplateTask = task.details && task.details.isTemplate;
          } else {
            // 子任务：检查父任务是否为模板任务
            const parentTask = partition.tasks.find(t => t.id === task.parentId);
            isTemplateTask = parentTask && parentTask.details && parentTask.details.isTemplate;
          }

          // 根据任务类型设置checkbox样式
          let checkboxClass = 'checkbox';
          if (isTemplateTask) {
            checkboxClass += ' template';
          } else if (task.isRecurring) {
            checkboxClass += ' recurring';
            // 如果是由周期任务生成的可勾选任务，使用空心样式
            // 如果是周期任务模板，使用实心样式
            if (task.isGeneratedFromRecurring) {
              // 这是由周期任务生成的任务，空心样式（可勾选）
              // 不添加 filled 类，保持空心样式
            } else {
              // 这是周期任务模板，实心样式（不可勾选）
              checkboxClass += ' filled';
            }
          } else if (task.done) {
            checkboxClass += ' done';
          }

          box.className = checkboxClass;

          // 添加Done+角标（如果启用）
          if (task.donePlus && task.donePlus.enabled) {
            const badge = document.createElement('div');
            badge.className = 'done-plus-badge';
            badge.textContent = '+';
            box.style.position = 'relative';
            box.appendChild(badge);
          }

          // 模板任务不可被勾选完成
          // 周期任务模板可以点击Done+功能
          if (isTemplateTask) {
            box.onclick = null; // 禁用点击事件
          } else {
            box.onclick = () => {
              // 检查是否启用了Done+功能
              if (task.donePlus && task.donePlus.enabled) {
                // 如果任务已完成且有笔记，显示Done+表单进行编辑
                if (task.done && task.donePlus.note && task.donePlus.note.trim()) {
                  showDonePlusForm(task, partition.id);
                }
                // 如果任务未完成，显示Done+表单进行完成
                else if (!task.done) {
                  showDonePlusForm(task, partition.id);
                }
                // 已完成但没有笔记或有空笔记，显示表单可以添加笔记
                else if (task.done && (!task.donePlus.note || !task.donePlus.note.trim())) {
                  showDonePlusForm(task, partition.id);
                }
                // 其他情况使用标准完成逻辑
                else {
                  completeTask(task, partition.id);
                }
              } else {
                // 标准完成任务逻辑
                completeTask(task, partition.id);
              }
            };
          }

          const txt=document.createElement('div'); txt.className='task-input'; txt.contentEditable='true'; txt.textContent=task.text||'';
          txt.onclick=()=>txt.classList.add('expanded');
          txt.onblur =()=>{
            txt.classList.remove('expanded');
            if(document.contains(txt) && txt.textContent !== null){
              task.text=txt.textContent||'';
            }
          };
          txt.addEventListener('input',()=>{ task.text=txt.textContent||''; });
          // 添加键盘事件处理：按回车创建新任务
          txt.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              // 保存当前任务
              task.text = txt.textContent || '';
              txt.classList.remove('expanded');

              // 创建新任务并聚焦
              createNewTaskBelowInPartition(task, partition.id);
            } else if (e.key === 'Escape') {
              e.preventDefault();
              txt.textContent = task.text || '';
              txt.classList.remove('expanded');
            }
          });

          // 检查是否有子任务
          const hasChildren = task.level === 0 && tasks.some(t => t.parentId === task.id);

          // 创建拖拽把手
          const handle=document.createElement('div'); handle.className='task-handle'; handle.textContent='≡';
          handle.onclick = (e) => {
            e.stopPropagation();
            // 延迟检查，给模块加载更多时间
            setTimeout(() => {
              if (window.toggleInlineEdit) {
                window.toggleInlineEdit(task, partition.id, handle);
              } else {
                console.error('toggleInlineEdit function not available, retrying...');
                setTimeout(() => {
                  if (window.toggleInlineEdit) {
                    window.toggleInlineEdit(task, partition.id, handle);
                  } else {
                    console.error('toggleInlineEdit function still not available after delay');
                  }
                }, 100);
              }
            }, 10);
          };

          // 添加元素到row
          row.appendChild(box);
          row.appendChild(txt);

          // 如果有子任务，在拖拽把手左侧添加折叠图标
          if (hasChildren) {
            const collapseIcon = document.createElement('div');
            collapseIcon.className = 'task-collapse';

            // 创建SVG图标 - 根据折叠状态选择箭头
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.setAttribute('class', 'collapse-icon-svg');
            svg.setAttribute('viewBox', '0 0 24 24');
            svg.setAttribute('fill', 'none');
            svg.setAttribute('stroke', 'currentColor');
            svg.setAttribute('stroke-width', '1.8');
            svg.setAttribute('stroke-linecap', 'round');
            svg.setAttribute('stroke-linejoin', 'round');
            svg.setAttribute('aria-label', task.collapsed ? 'chevron-right' : 'chevron-down');

            if (task.collapsed) {
              // 收缩状态：向右箭头
              const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
              path.setAttribute('d', 'M9 6l6 6-6 6');
              svg.appendChild(path);
              collapseIcon.classList.add('collapsed');
            } else {
              // 展开状态：向下箭头
              const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
              path.setAttribute('d', 'M6 9l6 6 6-6');
              svg.appendChild(path);
            }

            collapseIcon.appendChild(svg);

            collapseIcon.onclick = (e) => {
              e.stopPropagation();
              toggleTaskCollapse(task, enableDrag);
            };

            row.appendChild(collapseIcon);
          }

          row.appendChild(handle);
          wrap.appendChild(del); wrap.appendChild(actions); wrap.appendChild(row);

          // 添加内联编辑容器
          const inlineEditContainer = document.createElement('div');
          inlineEditContainer.className = 'inline-edit-container';
          wrap.appendChild(inlineEditContainer);

          // 添加缩略信息显示
          const taskSummary = createTaskSummaryElement(task);
          if (taskSummary) {
            wrap.appendChild(taskSummary);
          }

          list.appendChild(wrap);

          attachSwipeToDelete(row, del);
        });

        // 占位新增
        (function appendPlaceholderRow(){
          const wrap=document.createElement('div'); wrap.className='task-wrapper placeholder-row';
          // 关键修复：占位符完全不参与拖拽事件，避免干扰最后一项
          wrap.style.pointerEvents='none';
          const del=document.createElement('div'); del.className='task-delete'; del.textContent='删除'; del.style.display='none';
          const row=document.createElement('div');
          row.className = 'task';
          const box=document.createElement('div'); box.className='checkbox placeholder';
          const txt=document.createElement('div'); txt.className='task-input'; txt.contentEditable='true';
          // 设置输入框最小高度，避免高度异常
          txt.style.minHeight = 'var(--rule-gap)';
          txt.style.lineHeight = 'var(--rule-gap)';
          // 占位符不需要拖拽图标，禁用pointer事件避免干扰
          const handle=document.createElement('div'); handle.className='task-handle'; handle.style.visibility='hidden'; handle.style.pointerEvents='none';

          // 为文本框单独启用pointer事件
          txt.style.pointerEvents='auto';
          box.style.pointerEvents='auto';

          wrap.addEventListener('click',(e)=>{ if(e.target!==txt) txt.focus(); });
          box.addEventListener('click',()=>txt.focus());
          let isCommitting = false; // 防重复提交标志
          function commit(){
            const v=(txt.textContent||'').trim();
            if(!v || isCommitting) return;

            isCommitting = true;

            const newTask = {id: generateTaskId(), text:v, done:false, parentId: null, level: 0};
            if (isAllDay) {
                  }
            partition.tasks.push(newTask);
            const bm2 = partition.meta.badge || {};
            bm2.dTotal=(bm2.dTotal||0)+1;
            partition.meta.badge=bm2;

            // 清空输入框
            txt.textContent = '';

            // 提交后把焦点放到新的占位
            window.__focusPlaceholderFor = partition.id;
            render(enableDrag);

            // 延迟重置状态
            setTimeout(() => {
              isCommitting = false;
            }, 100);
          }

          txt.addEventListener('keydown',e=>{
            if(e.key==='Enter'){
              e.preventDefault();
              commit();
              txt.blur(); // 主动失焦，避免blur事件重复触发
            } else if(e.key==='Escape'){
              e.preventDefault();
              txt.textContent = ''; // 清空内容
              txt.blur();
            }
          });

          txt.addEventListener('blur', () => {
            // 延迟执行，避免与Enter事件冲突
            setTimeout(() => {
              if (!isCommitting) {
                commit();
              }
              isCommitting = false; // 重置标志
            }, 50);
          });
          row.appendChild(box); row.appendChild(txt); row.appendChild(handle);
          wrap.appendChild(del); wrap.appendChild(row);

          // 插入占位符
          list.appendChild(wrap);

          // 渲染后聚焦
          if (window.__focusPlaceholderFor === partition.id) {
            setTimeout(()=>{
              txt.focus();
              txt.scrollIntoView({block:'nearest', inline:'nearest'});
              window.__focusPlaceholderFor = null;
            }, 0);
          }
        })();

        /* 关键：把 list 放到 partition 里，这样竖条就能贯穿分区高度 */
        partitionDiv.appendChild(list);
        container.appendChild(partitionDiv);

        // 仅在"折叠状态"下渲染分隔线（展开模式取消横分割线）
        if (collapsed) {
          const sep=document.createElement('div'); sep.className='partition-sep'; container.appendChild(sep);
        }

        // 绑定：当该分区折叠时，支持拖拽悬停到 header 上放入/展开
        bindHeaderHoverForCollapsed({
          partitionEl: partitionDiv,
          headerEl: header,
          partitionId: partition.id,
          getMeta: ()=> (partition.meta = partition.meta || {}),
          onExpand: ()=>{
            partition.meta.collapsed = false;
          }
        });

        bindSortable(list, enableDrag);
      });

      // 检查是否需要聚焦到新创建的日程分区的占位符
      if (window.__focusNewSchedulePartition) {
        const targetPartition = getSchedulePartitions().find(p => p.id === window.__focusNewSchedulePartition);
        if (targetPartition && targetPartition.tasks.length === 0) {
          setTimeout(() => {
            // 查找该分区的占位符输入框
            const placeholderInput = document.querySelector(`.task-list[data-id="${window.__focusNewSchedulePartition}"] .placeholder-row .task-input`);
            if (placeholderInput) {
              placeholderInput.focus();
              // 清除焦点标记
              window.__focusNewSchedulePartition = null;
            }
          }, 100);
        }
      }
    }

    /**
     * ===== 任务编辑表单模块 =====
     */
    (function taskEditModal() {
      const modal = document.getElementById('taskEditModal');
      const overlay = modal.querySelector('.task-edit-overlay');
      const closeBtn = document.getElementById('taskEditClose');
      const confirmBtn = document.getElementById('taskEditConfirm');
      const titleInput = document.getElementById('taskEditTitle');
      const checkbox = document.getElementById('taskEditChk');
      const templateToggle = document.getElementById('templateToggle');
      const templateSection = document.getElementById('templateSection');
      const timeEditSection = document.getElementById('timeEditSection');
      const createScheduleBtn = document.getElementById('createScheduleBtn');

      // 周期编辑器元素
      const repeatEditor = document.getElementById('taskRepeatEditor');
      const repeatModeSelect = document.getElementById('repeatModeSelect');
      const repeatParams = document.getElementById('repeatParams');
      const repeatCancel = document.getElementById('repeatCancel');
      const repeatConfirm = document.getElementById('repeatConfirm');

      let currentTask = null;
      let currentPartitionId = null;
      let currentRecurrenceConfig = null;
      let savedScrollPosition = 0;

      // 显示编辑表单
      function showEditModal(task, partitionId) {
        currentTask = task;
        currentPartitionId = partitionId;

        // 禁用背景滚动
        savedScrollPosition = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0;
        document.body.style.overflow = 'hidden';
        document.documentElement.style.overflow = 'hidden';
        document.body.style.position = 'fixed';
        document.body.style.top = `-${savedScrollPosition}px`;
        document.body.style.width = '100%';

        // 填充表单数据
        titleInput.value = task.text || '';
        checkbox.setAttribute('aria-checked', task.done ? 'true' : 'false');
        templateToggle.checked = (task.details && task.details.isTemplate) || false;

        // 加载周期配置
        currentRecurrenceConfig = task.details?.recurrence || { enabled: false, pattern: 'none', config: {} };

        // 更新checkbox样式
        updateCheckboxStyle();

        // 根据任务类型显示/隐藏相关选项
        updateUIVisibility();

        // 更新周期按钮显示
        updateRepeatButtonDisplay();

        // 加载时间编辑器数据
        loadTimeEditorData();

        // 显示模态框
        modal.style.display = 'flex';
        setTimeout(() => titleInput.focus(), 100);
      }

      // 隐藏编辑表单
      function hideEditModal() {
        // 恢复背景滚动
        document.body.style.overflow = '';
        document.documentElement.style.overflow = '';
        document.body.style.position = '';
        document.body.style.top = '';
        document.body.style.width = '';

        // 恢复滚动位置
        window.scrollTo(0, savedScrollPosition);

        // 清理时间编辑器状态
        clearTimeEditorStates();

        modal.style.display = 'none';
        currentTask = null;
        currentPartitionId = null;
      }

      // 清理编辑器状态
      function clearTimeEditorStates() {
        // 清理时间编辑器状态
        const timeButtons = timeEditBelt.querySelectorAll('.task-edit-ctrl');
        timeButtons.forEach(button => {
          // 移除编辑器
          if (button._timeEditor && button._timeEditor.isConnected) {
            button._timeEditor.remove();
            button._timeEditor = null;
          }

          // 移除汇总显示
          if (button._timeSummary && button._timeSummary.isConnected) {
            button._timeSummary.remove();
            button._timeSummary = null;
          }

          // 移除周期编辑器
          if (button._repeatEditor && button._repeatEditor.isConnected) {
            button._repeatEditor.remove();
            button._repeatEditor = null;
          }

          // 移除周期汇总显示
          if (button._repeatSummary && button._repeatSummary.isConnected) {
            button._repeatSummary.remove();
            button._repeatSummary = null;
          }

          // 清理数据
          button._timeData = null;
          button._repeatState = null;

          // 恢复按钮显示
          button.style.display = 'inline-flex';
        });

        // 清理文本编辑器状态
        clearTextEditorStates();
      }

      // 清理文本编辑器状态
      function clearTextEditorStates() {
        // 移除所有文本编辑标签
        const editorChips = modal.querySelectorAll('.text-editor-chip');
        editorChips.forEach(chip => chip.remove());

        // 移除所有文本汇总标签
        const summaryChips = modal.querySelectorAll('.text-summary-chip');
        summaryChips.forEach(chip => chip.remove());

        // 恢复文本按钮显示
        const textButtons = tagEditBelt.querySelectorAll('.task-edit-ctrl');
        textButtons.forEach(button => {
          button.style.display = 'inline-flex';
        });
      }

      // 更新checkbox样式
      function updateCheckboxStyle() {
        checkbox.className = 'task-edit-checkbox';

        if (currentTask && currentTask.details && currentTask.details.isTemplate) {
          checkbox.classList.add('template');
          checkbox.setAttribute('aria-checked', 'false');
        } else if (currentTask && currentTask.isRecurring) {
          // 周期任务处理
          checkbox.classList.add('recurring');
          checkbox.setAttribute('aria-checked', 'false');
        } else {
          // 普通任务
          checkbox.setAttribute('aria-checked', currentTask?.done ? 'true' : 'false');
        }
      }


      // 标准完成任务逻辑
      function completeTask(task, partitionId) {
        const partition = findPartitionById(partitionId);

        if (!partition) {
          console.error('🐛 [completeTask Error] 找不到分区:', partitionId);
          return;
        }

        const bm3 = partition.meta.badge || {};
        const newState = !task.done;

        // 确保有任务ID，如果没有则生成
        if (!task.id) {
          task.id = generateTaskId();
        }

        // 批量更新徽章计数：先计算所有状态变化，再一次性更新
        let totalChange = 0;

        // 查找子任务：支持parentId和parentIndex两种方式
        let childTasks = [];
        const tasks = partition.tasks || [];

        // 方式1：通过parentId查找（已初始化的情况）
        childTasks = tasks.filter(t => t.parentId === task.id);

        // 方式2：如果没找到，尝试通过parentIndex查找（未初始化的情况）
        if (childTasks.length === 0 && task.level === 0) {
          const taskIndex = tasks.findIndex(t => t === task);
          childTasks = tasks.filter(t => t.parentIndex === taskIndex);
        }

        if (task.done) {
          // 从完成变为未完成：父任务-1，所有已完成的子任务-1
          totalChange = -1;
          childTasks.forEach(childTask => {
            if (childTask.done) {
              totalChange--;
            }
          });
        } else {
          // 从未完成变为完成：父任务+1，所有未完成的子任务+1
          totalChange = 1;
          childTasks.forEach(childTask => {
            if (!childTask.done) {
              totalChange++;
            }
          });
        }

        // 批量更新父任务状态
        task.done = newState;

        // 批量更新所有子任务状态
        childTasks.forEach(childTask => {
          childTask.done = newState;
          // 确保子任务也有ID
          if (!childTask.id) {
            childTask.id = generateTaskId();
          }
        });

        // 一次性更新徽章计数
        bm3.dDone = (bm3.dDone || 0) + totalChange;
        partition.meta.badge = bm3;

        // 检查render调用前的分区状态
        partition.tasks.forEach((task, index) => {
        });

        render(!!window.Sortable);

        // 检查render调用后的分区状态
        setTimeout(() => {
          const updatedPartition = findPartitionById(partitionId);
          if (updatedPartition) {
            updatedPartition.tasks.forEach((task, index) => {
            });
          }
        }, 100);

        // 最终验证：确保页面完全加载后数据仍然正确
        setTimeout(() => {
          const finalPartition = findPartitionById(partitionId);
          if (finalPartition) {
            finalPartition.tasks.forEach((task, index) => {

              // 检查新任务的具体情况
              if (task.text === '111' || task.id === 'T20251019004425001wn8') {

                // 检查是否有子任务指向这个新任务
                const children = finalPartition.tasks.filter(t => t.parentId === task.id);
                if (children.length > 0) {
                  children.forEach(child => {
                  });
                } else {
                }

                // DOM结构检查：检查页面上新任务的DOM元素
                setTimeout(() => {
                  const taskWrapper = document.querySelector(`[data-task-id="${task.id}"]`);
                  if (taskWrapper) {

                    // 检查DOM元素的class和样式
                    const taskElement = taskWrapper.querySelector('.task');
                    if (taskElement) {

                      // 检查是否有视觉上的子元素
                      const allWrappers = document.querySelectorAll('.task-wrapper');
                      const visualChildren = [];
                      allWrappers.forEach(wrapper => {
                        const wrapperTask = finalPartition.tasks.find(t =>
                          t.id === wrapper.dataset.taskId || wrapper.getAttribute('data-taskId')
                        );
                        if (wrapperTask && wrapperTask.parentId === task.id) {
                          visualChildren.push({
                            id: wrapperTask.id,
                            text: wrapperTask.text,
                            level: wrapperTask.level,
                            parentId: wrapperTask.parentId,
                            element: wrapper
                          });
                        }
                      });

                      if (visualChildren.length > 0) {
                        visualChildren.forEach((child, index) => {
                        });
                      } else {
                      }
                    }
                  } else {
                  }
                }, 1000);
              }
            });
          }
        }, 500);
      }

      // 更新任务Done+角标
      function updateTaskDonePlusBadge(taskWrapper, task) {
        const checkbox = taskWrapper.querySelector('.checkbox');
        if (!checkbox) return;

        // 移除现有的Done+角标
        const existingBadge = checkbox.querySelector('.done-plus-badge');
        if (existingBadge) {
          existingBadge.remove();
        }

        // 添加Done+角标（如果启用）
        if (task.donePlus && task.donePlus.enabled) {
          const badge = document.createElement('div');
          badge.className = 'done-plus-badge';
          badge.textContent = '+';
          checkbox.style.position = 'relative';
          checkbox.appendChild(badge);
        }
      }

      // 更新UI可见性
      function updateUIVisibility() {
        if (!currentTask) return;

        const isInTodoPartition = isTodoPartition(currentPartitionId);

        // 根据分区类型显示/隐藏时间相关编辑项
        if (isInTodoPartition) {
          // 在待办分区中，显示所有时间相关项
          templateSection.style.display = 'block';
          timeEditSection.style.display = 'block';

          // 如果是周期任务，隐藏模板开关
          const hasRecurring = currentTask.isRecurring;
          templateSection.style.display = hasRecurring ? 'none' : 'block';
        } else {
          templateSection.style.display = 'none';
          timeEditSection.style.display = 'none';
        }

        // 如果是父任务且有子任务，显示"创建日程"按钮
        const hasChildren = currentTask.level === 0 && hasChildTasks(currentTask.id);
        createScheduleBtn.style.display = hasChildren ? 'block' : 'none';
      }

      // 更新周期按钮显示
      function updateRepeatButtonDisplay() {
        const repeatBtn = document.querySelector('[data-type="repeat"]');
        if (!repeatBtn) return;

        const hasRepeat = currentRecurrenceConfig && currentRecurrenceConfig.enabled;

        if (hasRepeat) {
          const summary = formatRepeatSummary(currentRecurrenceConfig);
          repeatBtn.textContent = `周期: ${summary}`;
          repeatBtn.style.color = 'var(--accent, #0a84ff)';
          repeatBtn.style.fontWeight = '700';
        } else {
          repeatBtn.textContent = '周期';
          repeatBtn.style.color = '';
          repeatBtn.style.fontWeight = '';
        }
      }

      // 检查是否有子任务
      function hasChildTasks(taskId) {
        // 搜索所有分区中的任务
        const allTasks = [];
        const allPartitions = data.flat();
        allPartitions.forEach(partition => {
          if (partition && partition.tasks) {
            allTasks.push(...partition.tasks);
          }
        });

        return allTasks.some(task => task.parentId === taskId);
      }

      // 全局函数：检查是否有子任务（用于createInlineEditUI）
      window.hasChildTasks = hasChildTasks;

      // 保存编辑结果
      function saveTask() {
        if (!currentTask) return;

        // 更新任务数据
        currentTask.text = titleInput.value.trim() || currentTask.text;

        // 更新模板状态
        const wasTemplate = currentTask.details && currentTask.details.isTemplate;
        const wasRecurring = currentTask.isRecurring;

        // 确保 details 存在
        if (!currentTask.details) {
          currentTask.details = {};
        }
        currentTask.details.isTemplate = templateToggle.checked;

        // 互斥逻辑：模板任务和周期任务不能同时存在
        if (currentTask.details.isTemplate && currentTask.isRecurring) {
          currentTask.isRecurring = false;
          if (currentTask.details?.recurrence) {
            currentTask.details.recurrence = { enabled: false, pattern: 'none', config: {} };
          }
        }

        // 保存时间编辑器数据
        saveTimeEditorData();

        // 如果状态改变，需要重新渲染
        if (wasTemplate !== currentTask.details.isTemplate || wasRecurring !== currentTask.isRecurring) {
        }

        // 如果不是模板任务和周期任务，可以更新完成状态
        if (!currentTask.details.isTemplate && !currentTask.isRecurring) {
          const isChecked = checkbox.getAttribute('aria-checked') === 'true';
          currentTask.done = isChecked;
        }

        // 重新渲染页面
        render(!!window.Sortable);

        hideEditModal();
      }

      // 格式化周期配置显示（简化版本）
      function formatRepeatSummary(config) {
        // 适配新格式
        if (!config || !config.enabled) return '不重复';

        const pattern = config.pattern || 'none';
        if (pattern === 'none' || pattern === '') return '不重复';

        // 简化的周期格式 - 只支持中文模式
        if (pattern === '每天') return '每天';
        if (pattern === '每周') {
          const weekdays = config.config?.weekdays || [];
          if (weekdays.length > 0) {
            return `每周(${weekdays.join('')})`;
          }
          return '每周';
        }
        if (pattern === '每月') return '每月';

        return '周期任务';
      }

      // ===== 时间编辑器功能 =====

      // 时间类型映射
      const TIME_TYPE_NAMES = {
        start: '开始',
        duration: '用时',
        due: '截止'
      };

      // 创建日期时间输入字段
      function makeDateField(placeholder, inputType) {
        const wrapper = document.createElement('span');
        wrapper.className = 'time-field';
        wrapper.style.position = 'relative';
        wrapper.style.display = 'inline-block';

        const placeholderSpan = document.createElement('span');
        placeholderSpan.className = 'time-placeholder';
        placeholderSpan.textContent = placeholder;
        placeholderSpan.style.position = 'absolute';
        placeholderSpan.style.left = '4px';
        placeholderSpan.style.color = '#9aa6b2';
        placeholderSpan.style.pointerEvents = 'none';
        placeholderSpan.style.fontSize = '14px';

        const input = document.createElement('input');
        input.type = inputType;
        input.style.border = '1px solid var(--line, #e8ecf2)';
        input.style.borderRadius = '6px';
        input.style.padding = '4px 8px';
        input.style.fontSize = '14px';
        input.style.background = 'transparent';
        input.style.color = 'var(--text, #0b1220)';

        const updatePlaceholder = () => {
          placeholderSpan.style.display = input.value ? 'none' : 'block';
        };

        input.addEventListener('input', updatePlaceholder);
        input.addEventListener('change', updatePlaceholder);

        wrapper.appendChild(placeholderSpan);
        wrapper.appendChild(input);

        // 初始化显示状态
        setTimeout(updatePlaceholder, 0);

        return { wrapper, input, updatePlaceholder };
      }

      // 打开时间编辑器
      function openTimeEditor(ctrl) {
        const type = ctrl.dataset.type;

        // 如果已经有编辑器打开，直接聚焦
        if (ctrl._timeEditor && ctrl._timeEditor.isConnected) {
          const firstInput = ctrl._timeEditor.querySelector('input, select');
          if (firstInput) firstInput.focus();
          return;
        }

        // 移除已有的汇总显示
        if (ctrl._timeSummary && ctrl._timeSummary.isConnected) {
          ctrl._timeSummary.remove();
        }

        // 创建编辑器元素
        const editor = document.createElement('span');
        editor.className = 'time-editor';
        editor.style.display = 'inline-flex';
        editor.style.alignItems = 'center';
        editor.style.gap = '8px';
        editor.style.padding = '6px 12px';
        editor.style.border = '1px solid var(--accent, #0a84ff)';
        editor.style.borderRadius = '10px';
        editor.style.background = 'var(--card, #ffffff)';
        editor.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';

        // 添加标签
        const label = document.createElement('span');
        label.textContent = TIME_TYPE_NAMES[type] + ' ';
        label.style.opacity = '0.7';
        label.style.fontSize = '14px';
        editor.appendChild(label);

        let inputs = [];

        if (type === 'duration') {
          // 用时编辑器：数字输入 + 单位选择
          const numberInput = document.createElement('input');
          numberInput.type = 'number';
          numberInput.min = '1';
          numberInput.placeholder = '时长';
          numberInput.style.width = '60px';
          numberInput.style.border = '1px solid var(--line, #e8ecf2)';
          numberInput.style.borderRadius = '4px';
          numberInput.style.padding = '2px 6px';
          numberInput.style.fontSize = '14px';

          const unitSelect = document.createElement('select');
          unitSelect.innerHTML = `
            <option value="min">分钟</option>
            <option value="h">小时</option>
            <option value="d">天</option>
          `;
          unitSelect.style.border = '1px solid var(--line, #e8ecf2)';
          unitSelect.style.borderRadius = '4px';
          unitSelect.style.padding = '2px 4px';
          unitSelect.style.fontSize = '14px';

          // 加载已保存的数据
          if (ctrl._timeData) {
            if (ctrl._timeData.n) numberInput.value = ctrl._timeData.n;
            if (ctrl._timeData.u) unitSelect.value = ctrl._timeData.u;
          }

          inputs = [numberInput, unitSelect];
          editor.appendChild(numberInput);
          editor.appendChild(unitSelect);
        } else {
          // 开始时间/截止时间编辑器：日期 + 时间
          const dateField = makeDateField('日期', 'date');
          const timeField = makeDateField('时间', 'time');

          // 加载已保存的数据
          if (ctrl._timeData) {
            if (ctrl._timeData.date) {
              dateField.input.value = ctrl._timeData.date;
              dateField.updatePlaceholder();
            }
            if (ctrl._timeData.time) {
              timeField.input.value = ctrl._timeData.time;
              timeField.updatePlaceholder();
            }
          }

          inputs = [dateField.input, timeField.input];
          editor.appendChild(dateField.wrapper);
          editor.appendChild(timeField.wrapper);
        }

        // 添加确认和取消按钮
        const confirmBtn = document.createElement('button');
        confirmBtn.textContent = '✓';
        confirmBtn.title = '确认';
        confirmBtn.style.border = 'none';
        confirmBtn.style.background = 'var(--ok, #34c759)';
        confirmBtn.style.color = 'white';
        confirmBtn.style.borderRadius = '4px';
        confirmBtn.style.padding = '4px 8px';
        confirmBtn.style.cursor = 'pointer';
        confirmBtn.style.fontSize = '12px';
        confirmBtn.style.fontWeight = 'bold';

        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = '×';
        cancelBtn.title = '取消';
        cancelBtn.style.border = 'none';
        cancelBtn.style.background = 'var(--text-muted, #9aa6b2)';
        cancelBtn.style.color = 'white';
        cancelBtn.style.borderRadius = '4px';
        cancelBtn.style.padding = '4px 8px';
        cancelBtn.style.cursor = 'pointer';
        cancelBtn.style.fontSize = '12px';

        editor.appendChild(confirmBtn);
        editor.appendChild(cancelBtn);

        // 保存数据并显示汇总
        const saveAndShowSummary = () => {
          if (type === 'duration') {
            const numberValue = inputs[0].value;
            const unitValue = inputs[1].value || 'min';

            if (!numberValue) {
              // 没有输入值，直接取消
              cancelEdit();
              return;
            }

            ctrl._timeData = { n: numberValue, u: unitValue };
          } else {
            const dateValue = inputs[0].value;
            const timeValue = inputs[1].value;

            if (!dateValue && !timeValue) {
              // 没有输入值，直接取消
              cancelEdit();
              return;
            }

            ctrl._timeData = { date: dateValue, time: timeValue };
          }

          showTimeSummary(ctrl);
        };

        // 取消编辑
        const cancelEdit = () => {
          editor.remove();
          ctrl.style.display = 'inline-flex';
          ctrl._timeEditor = null;
        };

        // 绑定事件
        confirmBtn.addEventListener('click', saveAndShowSummary);
        cancelBtn.addEventListener('click', cancelEdit);

        // 回车键确认
        inputs.forEach(input => {
          input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
              e.preventDefault();
              saveAndShowSummary();
            } else if (e.key === 'Escape') {
              e.preventDefault();
              cancelEdit();
            }
          });
        });

        // 插入编辑器并隐藏原按钮
        ctrl.after(editor);
        ctrl.style.display = 'none';
        ctrl._timeEditor = editor;

        // 聚焦第一个输入框
        setTimeout(() => {
          if (inputs[0]) inputs[0].focus();
        }, 0);
      }

      // 显示时间汇总
      function showTimeSummary(ctrl) {
        const type = ctrl.dataset.type;

        // 移除编辑器
        if (ctrl._timeEditor) {
          ctrl._timeEditor.remove();
          ctrl._timeEditor = null;
        }

        // 创建汇总显示
        const summary = document.createElement('span');
        summary.className = 'time-summary';
        summary.style.display = 'inline-flex';
        summary.style.alignItems = 'center';
        summary.style.gap = '4px';
        summary.style.padding = '6px 12px';
        summary.style.border = '1px solid var(--line, #e8ecf2)';
        summary.style.borderRadius = '10px';
        summary.style.background = 'var(--card, #ffffff)';
        summary.style.cursor = 'pointer';
        summary.style.fontSize = '14px';

        // 添加标签
        const label = document.createElement('span');
        label.textContent = TIME_TYPE_NAMES[type] + ' ';
        label.style.opacity = '0.7';
        summary.appendChild(label);

        // 添加内容
        const content = document.createElement('span');
        content.style.fontWeight = '600';
        content.style.color = 'var(--accent, #0a84ff)';

        if (type === 'duration') {
          content.textContent = formatDuration(ctrl._timeData?.n, ctrl._timeData?.u) || '—';
        } else {
          const dateStr = formatDateStr(ctrl._timeData?.date);
          const timeStr = formatTimeStr(ctrl._timeData?.time);
          content.textContent = [dateStr, timeStr].filter(Boolean).join(' ') || '—';
        }

        summary.appendChild(content);

        // 添加删除按钮
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = '×';
        deleteBtn.title = '删除';
        deleteBtn.style.border = 'none';
        deleteBtn.style.background = 'transparent';
        deleteBtn.style.color = 'var(--text-muted, #9aa6b2)';
        deleteBtn.style.cursor = 'pointer';
        deleteBtn.style.padding = '0 4px';
        deleteBtn.style.borderRadius = '4px';
        deleteBtn.style.fontSize = '14px';

        deleteBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          summary.remove();
          ctrl.style.display = 'inline-flex';
          ctrl._timeSummary = null;
          ctrl._timeData = null;
        });

        summary.appendChild(deleteBtn);

        // 点击汇总重新编辑
        summary.addEventListener('click', (e) => {
          if (e.target === deleteBtn) return;
          summary.remove();
          ctrl.style.display = 'inline-flex';
          openTimeEditor(ctrl);
        });

        // 插入汇总并隐藏原按钮
        ctrl.after(summary);
        ctrl.style.display = 'none';
        ctrl._timeSummary = summary;
      }

      // 格式化函数
      function formatDateStr(dateValue) {
        if (!dateValue) return '';
        try {
          const date = new Date(dateValue + 'T00:00:00');
          if (isNaN(date.getTime())) return '';
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const day = String(date.getDate()).padStart(2, '0');
          return `${year}-${month}-${day}`;
        } catch {
          return '';
        }
      }

      function formatTimeStr(timeValue) {
        return timeValue || '';
      }

      function formatDuration(n, unit) {
        if (!n) return '';
        if (unit === 'min') return `${n} 分钟`;
        if (unit === 'h') return `${n} 小时`;
        if (unit === 'd') return `${n} 天`;
        return `${n}`;
      }

      // ===== 周期编辑器功能 =====

      // 打开周期编辑器
      function openRepeatEditor(ctrl) {
        if (ctrl._repeatEditor && ctrl._repeatEditor.isConnected) {
          ctrl._repeatEditor.querySelector('select,input,button')?.focus();
          return;
        }

        if (ctrl._repeatSummary && ctrl._repeatSummary.isConnected) {
          ctrl._repeatSummary.remove();
        }

        // 创建编辑器容器
        const editor = document.createElement('span');
        editor.className = 'task-edit-time-editor';
        editor.dataset.type = 'repeat';
        editor.style.display = 'inline-flex';
        editor.style.alignItems = 'center';
        editor.style.gap = '8px';
        editor.style.padding = '6px 12px';
        editor.style.border = '1px solid var(--line, #e8ecf2)';
        editor.style.borderRadius = '10px';
        editor.style.background = 'var(--card, #ffffff)';
        editor.style.flexWrap = 'wrap';

        // 标签
        const label = document.createElement('span');
        label.style.opacity = '0.7';
        label.textContent = '周期 ';
        editor.appendChild(label);

        // 模式选择器 (简化版，只支持每天、每周、每月)
        const modeSelect = document.createElement('select');
        modeSelect.innerHTML = `
          <option value="">不重复</option>
          <option value="每天">每天</option>
          <option value="每周">每周</option>
          <option value="每月">每月</option>
        `;
        modeSelect.style.marginRight = '8px';

        // 参数容器
        const paramsContainer = document.createElement('span');
        paramsContainer.className = 'repeat-params';
        paramsContainer.style.display = 'inline-flex';
        paramsContainer.style.alignItems = 'center';
        paramsContainer.style.gap = '4px';
        paramsContainer.style.flexWrap = 'wrap';

        // 按钮
        const confirmBtn = document.createElement('button');
        confirmBtn.textContent = '✓';
        confirmBtn.style.marginLeft = '8px';
        confirmBtn.style.padding = '2px 6px';
        confirmBtn.style.border = 'none';
        confirmBtn.style.background = 'var(--ok, #34c759)';
        confirmBtn.style.color = 'white';
        confirmBtn.style.borderRadius = '4px';
        confirmBtn.style.cursor = 'pointer';

        const cancelBtn = document.createElement('button');
        cancelBtn.textContent = '×';
        cancelBtn.style.padding = '2px 6px';
        cancelBtn.style.border = 'none';
        cancelBtn.style.background = 'var(--text-muted, #9aa6b2)';
        cancelBtn.style.color = 'white';
        cancelBtn.style.borderRadius = '4px';
        cancelBtn.style.cursor = 'pointer';

        editor.appendChild(modeSelect);
        editor.appendChild(paramsContainer);
        editor.appendChild(confirmBtn);
        editor.appendChild(cancelBtn);

        // 状态管理 (使用新格式)
        const state = ctrl._repeatState || { enabled: false, pattern: 'none', config: {} };

        // 设置选择器初始值
        if (state.enabled && state.pattern && state.pattern !== 'none') {
          modeSelect.value = state.pattern;
        } else {
          modeSelect.value = '';
        }

        // 渲染参数界面
        const renderParams = () => {
          paramsContainer.innerHTML = '';
          const pattern = modeSelect.value;

          // 更新状态
          if (pattern === '' || !pattern) {
            state.enabled = false;
            state.pattern = 'none';
          } else {
            state.enabled = true;
            state.pattern = pattern;
          }

          if (!state.config) state.config = {};

          if (!pattern || pattern === '') {
            paramsContainer.textContent = '';
          } else if (pattern === '每天') {
            paramsContainer.textContent = '';  // 每天不需要额外参数
          } else if (pattern === '每周') {
            // 创建星期选择器
            const daysContainer = document.createElement('span');
            daysContainer.style.display = 'inline-flex';
            daysContainer.style.gap = '4px';
            daysContainer.style.margin = '0 4px';

            const dayNames = ['一', '二', '三', '四', '五', '六', '日'];

            // 初始化 weekdays 数组
            if (!state.config.weekdays) {
              state.config.weekdays = [];
            }

            dayNames.forEach(name => {
              const dayBtn = document.createElement('button');
              dayBtn.textContent = name;
              dayBtn.style.minWidth = '24px';
              dayBtn.style.height = '24px';
              dayBtn.style.border = '1px solid var(--line, #e8ecf2)';
              dayBtn.style.borderRadius = '4px';
              dayBtn.style.background = 'white';
              dayBtn.style.cursor = 'pointer';
              dayBtn.style.fontSize = '12px';

              // 检查是否已选中
              if (state.config.weekdays.includes(name)) {
                dayBtn.style.background = 'rgba(10,132,255,0.12)';
              }

              dayBtn.addEventListener('click', (e) => {
                e.preventDefault();
                const index = state.config.weekdays.indexOf(name);
                if (index > -1) {
                  state.config.weekdays.splice(index, 1);
                  dayBtn.style.background = 'white';
                } else {
                  state.config.weekdays.push(name);
                  dayBtn.style.background = 'rgba(10,132,255,0.12)';
                }
              });

              daysContainer.appendChild(dayBtn);
            });

            paramsContainer.appendChild(daysContainer);
          } else if (pattern === '每月') {
            paramsContainer.textContent = '';  // 每月不需要额外参数
          }
        };

        // 保存并显示汇总
        const saveAndShowSummary = () => {
          ctrl._repeatState = { ...state };

          // 更新周期配置
          currentRecurrenceConfig = { ...state };

          // 更新任务状态
          if (currentTask) {
            if (!currentTask.details) currentTask.details = {};
            currentTask.details.recurrence = { ...state };

            // 更新任务类型
            if (state.enabled && state.pattern && state.pattern !== 'none') {
              currentTask.isRecurring = true;
              if (currentTask.details) {
                currentTask.details.isTemplate = false; // 互斥逻辑
              }
            } else {
              currentTask.isRecurring = false;
            }
          }

          showRepeatSummary(ctrl);
          updateCheckboxStyle();
          updateUIVisibility();
        };

        // 取消编辑
        const cancelEdit = () => {
          editor.remove();
          ctrl.style.display = 'inline-flex';
          ctrl._repeatEditor = null;
        };

        // 绑定事件
        modeSelect.addEventListener('change', renderParams);
        confirmBtn.addEventListener('click', saveAndShowSummary);
        cancelBtn.addEventListener('click', cancelEdit);

        // 初始渲染
        renderParams();

        // 插入编辑器并隐藏原按钮
        ctrl.after(editor);
        ctrl.style.display = 'none';
        ctrl._repeatEditor = editor;
      }

      // 显示周期汇总
      function showRepeatSummary(ctrl) {
        const type = ctrl.dataset.type;
        const state = ctrl._repeatState || { enabled: false, pattern: 'none', config: {} };

        // 移除旧的编辑器和汇总
        if (ctrl._repeatEditor && ctrl._repeatEditor.isConnected) {
          ctrl._repeatEditor.remove();
          ctrl._repeatEditor = null;
        }
        if (ctrl._repeatSummary && ctrl._repeatSummary.isConnected) {
          ctrl._repeatSummary.remove();
        }

        // 创建汇总显示
        const summary = document.createElement('span');
        summary.className = 'task-edit-time-summary';
        summary.dataset.type = type;
        summary.style.display = 'inline-flex';
        summary.style.alignItems = 'center';
        summary.style.gap = '8px';
        summary.style.padding = '6px 12px';
        summary.style.border = '1px solid var(--accent, #0a84ff)';
        summary.style.borderRadius = '10px';
        summary.style.background = 'rgba(10,132,255,0.08)';
        summary.style.color = 'var(--accent, #0a84ff)';
        summary.style.cursor = 'pointer';
        summary.style.fontWeight = '600';

        // 标签
        const label = document.createElement('span');
        label.style.opacity = '0.7';
        label.textContent = '周期 ';

        // 内容
        const content = document.createElement('span');
        content.textContent = formatRepeatSummary(state);

        // 删除按钮
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = '×';
        deleteBtn.style.border = 'none';
        deleteBtn.style.background = 'transparent';
        deleteBtn.style.color = 'var(--accent, #0a84ff)';
        deleteBtn.style.cursor = 'pointer';
        deleteBtn.style.padding = '0 4px';
        deleteBtn.style.borderRadius = '4px';
        deleteBtn.style.fontSize = '14px';

        deleteBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          summary.remove();
          ctrl.style.display = 'inline-flex';
          ctrl._repeatSummary = null;
          ctrl._repeatState = { enabled: false, pattern: 'none', config: {} };

          // 更新周期配置
          currentRecurrenceConfig = { enabled: false, pattern: 'none', config: {} };

          // 更新任务状态
          if (currentTask) {
            if (!currentTask.details) currentTask.details = {};
            currentTask.details.recurrence = { enabled: false, pattern: 'none', config: {} };
            currentTask.isRecurring = false;
          }

          updateCheckboxStyle();
          updateUIVisibility();
        });

        summary.appendChild(label);
        summary.appendChild(content);
        summary.appendChild(deleteBtn);

        // 点击汇总重新编辑
        summary.addEventListener('click', (e) => {
          if (e.target === deleteBtn) return;
          summary.remove();
          ctrl.style.display = 'inline-flex';
          openRepeatEditor(ctrl);
        });

        // 插入汇总并隐藏原按钮
        ctrl.after(summary);
        ctrl.style.display = 'none';
        ctrl._repeatSummary = summary;
      }

      // 格式化周期配置显示
      function formatRepeatSummary(state) {
        // 适配新格式
        if (!state || !state.enabled) return '不重复';

        const pattern = state.pattern || 'none';
        if (pattern === 'none' || pattern === '') return '不重复';

        // 简化的周期格式 - 只支持中文模式
        if (pattern === '每天') return '每天';
        if (pattern === '每周') {
          const weekdays = state.config?.weekdays || [];
          if (weekdays.length > 0) {
            return `每周(${weekdays.join('')})`;
          }
          return '每周';
        }
        if (pattern === '每月') return '每月';

        return '周期任务';
      }

      // ===== 数据持久化功能 =====

      // 保存编辑器数据到任务
      function saveTimeEditorData() {
        if (!currentTask) return;

        // 确保details对象存在
        if (!currentTask.details) {
          currentTask.details = {};
        }

        // 保存时间数据
        const timeButtons = timeEditBelt.querySelectorAll('.task-edit-ctrl');

        // 确保time对象存在
        if (!currentTask.details.time) {
          currentTask.details.time = {};
        }

        timeButtons.forEach(button => {
          const type = button.dataset.type;
          if (type === 'start' && button._timeData) {
            // 保存开始时间 (date + time -> yyyy-mm-dd hh:mm:ss)
            const dateStr = button._timeData.date || '';
            const timeStr = button._timeData.time || '00:00';
            if (dateStr) {
              currentTask.details.time.start = `${dateStr} ${timeStr}:00`;
            } else {
              delete currentTask.details.time.start;
            }
          } else if (type === 'due' && button._timeData) {
            // 保存截止时间
            const dateStr = button._timeData.date || '';
            const timeStr = button._timeData.time || '23:59';
            if (dateStr) {
              currentTask.details.time.end = `${dateStr} ${timeStr}:00`;
            } else {
              delete currentTask.details.time.end;
            }
          } else if (type === 'duration' && button._timeData) {
            // 保存用时
            if (button._timeData.n) {
              currentTask.details.time.duration = {
                value: button._timeData.n,
                unit: button._timeData.u
              };
            } else {
              delete currentTask.details.time.duration;
            }
          } else if (type === 'repeat' && button._repeatState) {
            currentTask.details.recurrence = { ...button._repeatState };
          }
        });

        // 保存文本数据
        saveTextEditorData();

      }

      // 更新文本标签按钮状态
      function updateTextButtonStates() {
        const textTypes = ['goal', 'deliverable', 'contact', 'place', 'note'];

        textTypes.forEach(type => {
          const button = document.querySelector(`.text-tag-btn[data-type="${type}"]`);
          if (!button) return;

          // 计算该类型的标签数量
          const container = document.getElementById('taskEditTagsContainer');
          const summaryChips = container ? container.querySelectorAll(`.text-summary-chip[data-type="${type}"]`) : [];
          const editorChips = container ? container.querySelectorAll(`.text-editor-chip[data-type="${type}"]`) : [];
          const count = summaryChips.length + editorChips.length;

          // 更新按钮状态
          if (count > 0) {
            button.classList.add('has-content');

            // 更新或创建角标
            let badge = button.querySelector('.badge');
            if (!badge) {
              badge = document.createElement('span');
              badge.className = 'badge';
              button.appendChild(badge);
            }
            badge.textContent = count;
          } else {
            button.classList.remove('has-content');
            const badge = button.querySelector('.badge');
            if (badge) {
              badge.remove();
            }
          }
        });
      }

      // 保存文本编辑器数据到任务
      function saveTextEditorData() {
        if (!currentTask) return;

        // 确保details对象存在
        if (!currentTask.details) {
          currentTask.details = {};
        }

        // 确保tags对象存在
        if (!currentTask.details.tags) {
          currentTask.details.tags = {};
        }

        // 定义字段映射关系
        const fieldMapping = {
          'goal': 'goals',
          'deliverable': 'outputs',
          'contact': 'contacts',
          'place': 'locations',
          'note': 'notes'
        };

        // 收集所有文本标签数据
        const textTypes = ['goal', 'deliverable', 'contact', 'place', 'note'];

        textTypes.forEach(type => {
          const container = document.getElementById('taskEditTagsContainer');
          const summaryChips = container ? container.querySelectorAll(`.text-summary-chip[data-type="${type}"]`) : [];
          const editorChips = container ? container.querySelectorAll(`.text-editor-chip[data-type="${type}"]`) : [];
          const values = [];

          // 收集汇总标签的值
          summaryChips.forEach(chip => {
            const content = chip.querySelector('span');
            if (content) {
              values.push(content.textContent.trim());
            }
          });

          // 收集编辑中标签的值
          editorChips.forEach(chip => {
            const input = chip.querySelector('input');
            if (input && input.value.trim()) {
              values.push(input.value.trim());
            }
          });

          // 使用新的字段名保存
          const newFieldName = fieldMapping[type];
          if (values.length > 0) {
            currentTask.details.tags[newFieldName] = values;
          } else {
            // 清除空数据
            delete currentTask.details.tags[newFieldName];
          }
        });

        // 如果tags对象为空，删除它
        if (Object.keys(currentTask.details.tags).length === 0) {
          delete currentTask.details.tags;
        }
      }

      // 从任务加载编辑器数据
      function loadTimeEditorData() {
        if (!currentTask || !currentTask.details) return;

        // 加载时间数据
        const timeButtons = timeEditBelt.querySelectorAll('.task-edit-ctrl');
        timeButtons.forEach(button => {
          const type = button.dataset.type;

          if (type === 'start' && currentTask.details.time?.start) {
            // 恢复开始时间数据 (yyyy-mm-dd hh:mm:ss -> date + time)
            const [date, timeFull] = currentTask.details.time.start.split(' ');
            const time = timeFull ? timeFull.substring(0, 5) : '00:00'; // 只取hh:mm
            button._timeData = { date, time };
            // 显示汇总
            showTimeSummary(button);
          } else if (type === 'due' && currentTask.details.time?.end) {
            // 恢复截止时间数据
            const [date, timeFull] = currentTask.details.time.end.split(' ');
            const time = timeFull ? timeFull.substring(0, 5) : '23:59';
            button._timeData = { date, time };
            // 显示汇总
            showTimeSummary(button);
          } else if (type === 'duration' && currentTask.details.time?.duration) {
            // 恢复用时数据
            button._timeData = {
              n: currentTask.details.time.duration.value,
              u: currentTask.details.time.duration.unit
            };
            // 显示汇总
            showTimeSummary(button);
          } else if (type === 'repeat' && currentTask.details.recurrence) {
            // 恢复周期数据
            button._repeatState = { ...currentTask.details.recurrence };

            // 如果有有效的周期配置，显示汇总
            if (button._repeatState.enabled && button._repeatState.pattern && button._repeatState.pattern !== 'none') {
              showRepeatSummary(button);
            }
          }
        });

        // 加载文本数据
        loadTextEditorData();

      }

      // 从任务加载文本编辑器数据
      function loadTextEditorData() {
        if (!currentTask || !currentTask.details || !currentTask.details.tags) return;

        // 定义字段映射关系
        const fieldMapping = {
          'goal': 'goals',
          'deliverable': 'outputs',
          'contact': 'contacts',
          'place': 'locations',
          'note': 'notes'
        };

        const textTypes = ['goal', 'deliverable', 'contact', 'place', 'note'];

        textTypes.forEach(type => {
          // 先清理该类型的所有现有标签
          clearTextTagsByType(type);

          // 从新格式读取数据
          const newFieldName = fieldMapping[type];
          const values = currentTask.details.tags[newFieldName];

          if (Array.isArray(values) && values.length > 0) {
            values.forEach(value => {
              if (value && value.trim()) {
                showTextSummaryChip(type, null, value.trim());
              }
            });
          }
        });
      }

      // 清理指定类型的所有文本标签
      function clearTextTagsByType(type) {
        const container = document.getElementById('taskEditTagsContainer');
        if (!container) return;

        // 移除该类型的所有编辑标签
        const editorChips = container.querySelectorAll(`.text-editor-chip[data-type="${type}"]`);
        editorChips.forEach(chip => chip.remove());

        // 移除该类型的所有汇总标签
        const summaryChips = container.querySelectorAll(`.text-summary-chip[data-type="${type}"]`);
        summaryChips.forEach(chip => chip.remove());
      }

      // ===== 文本标签编辑器功能 =====

      // 文本类型映射
      const TEXT_TYPE_NAMES = {
        goal: '目标',
        deliverable: '产出物',
        contact: '联系人',
        place: '地点',
        note: '备注'
      };

      // 文本类型图标映射
      const TEXT_TYPE_ICONS = {
        goal: '🎯',
        deliverable: '📦',
        contact: '👤',
        place: '📍',
        note: '📝'
      };

      // 创建自动调整宽度的输入框
      function createAutoResizeInput(placeholder, initialValue = '') {
        const container = document.createElement('span');
        container.className = 'text-input-container';
        container.style.position = 'relative';
        container.style.display = 'inline-block';

        // 创建隐藏的测量元素
        const sizer = document.createElement('span');
        Object.assign(sizer.style, {
          position: 'absolute',
          left: '-9999px',
          visibility: 'hidden',
          whiteSpace: 'pre',
          font: 'inherit',
          fontSize: '14px',
          fontFamily: '-apple-system,BlinkMacSystemFont,sans-serif'
        });

        // 创建输入框
        const input = document.createElement('input');
        input.type = 'text';
        input.placeholder = placeholder;
        input.value = initialValue;
        input.style.border = '1px solid var(--line, #e8ecf2)';
        input.style.borderRadius = '6px';
        input.style.padding = '4px 8px';
        input.style.fontSize = '14px';
        input.style.background = 'transparent';
        input.style.color = 'var(--text, #0b1220)';
        input.style.minWidth = '60px';
        input.style.maxWidth = '200px';

        // 自动调整宽度函数
        const autoResize = () => {
          const text = input.value || input.placeholder || '';
          sizer.textContent = text;
          const newWidth = Math.max(60, Math.min(200, sizer.offsetWidth + 20));
          input.style.width = newWidth + 'px';
        };

        container.appendChild(sizer);
        container.appendChild(input);

        // 初始化尺寸
        setTimeout(autoResize, 0);

        // 监听输入变化
        input.addEventListener('input', autoResize);

        return { container, input, sizer, autoResize };
      }

      // 创建文本编辑标签
      function createTextEditorChip(type, afterElement, initialValue = '') {
        const chip = document.createElement('span');
        chip.className = 'text-editor-chip';
        chip.dataset.type = type;
        chip.style.display = 'inline-flex';
        chip.style.alignItems = 'center';
        chip.style.gap = '4px';
        chip.style.padding = '6px 12px';
        chip.style.border = '1px solid var(--accent, #0a84ff)';
        chip.style.borderRadius = '10px';
        chip.style.background = 'var(--card, #ffffff)';
        chip.style.boxShadow = '0 2px 8px rgba(0,0,0,0.1)';

        // 创建输入框
        const inputData = createAutoResizeInput(TEXT_TYPE_NAMES[type] + '…', initialValue);
        chip.appendChild(inputData.container);

        // 创建删除按钮
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = '×';
        deleteBtn.title = '删除';
        deleteBtn.style.border = 'none';
        deleteBtn.style.background = 'transparent';
        deleteBtn.style.color = 'var(--text-muted, #9aa6b2)';
        deleteBtn.style.cursor = 'pointer';
        deleteBtn.style.padding = '0 4px';
        deleteBtn.style.borderRadius = '4px';
        deleteBtn.style.fontSize = '14px';

        chip.appendChild(deleteBtn);

        // 保存并显示汇总
        const saveAndShowSummary = () => {
          const text = inputData.input.value.trim();
          if (!text) {
            // 没有内容，直接删除
            chip.remove();
            updateTextButtonStates();
            return;
          }
          showTextSummaryChip(type, chip, text);
        };

        // 取消编辑
        const cancelEdit = () => {
          if (!inputData.input.value.trim()) {
            chip.remove();
            updateTextButtonStates();
          } else {
            saveAndShowSummary();
          }
        };

        // 事件监听
        deleteBtn.addEventListener('click', () => {
          chip.remove();
          updateTextButtonStates();
        });

        let skipFocusOut = false;  // 标记是否跳过失焦处理

        inputData.input.addEventListener('keydown', (e) => {
          if (e.key === 'Enter') {
            e.preventDefault();
            const text = inputData.input.value.trim();
            if (text) {
              // 标记跳过失焦事件
              skipFocusOut = true;
              // 保存当前内容为汇总
              const summary = showTextSummaryChip(type, chip, text);
              // 在汇总后面创建新的编辑器
              const nextChip = createTextEditorChip(type, summary, '');
              setTimeout(() => {
                const nextInput = nextChip.querySelector('input');
                if (nextInput) {
                  nextInput.focus();
                  nextInput.setSelectionRange(nextInput.value.length, nextInput.value.length);
                }
              }, 0);
            }
          } else if (e.key === 'Escape') {
            e.preventDefault();
            cancelEdit();
          }
        });

        // 失焦时保存
        chip.addEventListener('focusout', (e) => {
          // 如果是回车触发的失焦，跳过保存
          if (skipFocusOut) {
            skipFocusOut = false;
            return;
          }
          // 检查焦点是否还在chip内部
          if (!chip.contains(e.relatedTarget)) {
            setTimeout(saveAndShowSummary, 20);
          }
        });

        // 插入到容器中的指定位置
        const container = document.getElementById('taskEditTagsContainer');
        if (container) {
          // 如果afterElement存在且在容器中，则在其后插入
          if (afterElement && container.contains(afterElement)) {
            afterElement.after(chip);
          } else {
            // 否则添加到容器末尾
            container.appendChild(chip);
          }
        } else if (afterElement) {
          afterElement.after(chip);
        }

        // 聚焦输入框
        setTimeout(() => {
          inputData.input.focus();
          inputData.input.setSelectionRange(inputData.input.value.length, inputData.input.value.length);
        }, 0);

        return chip;
      }

      // 显示文本汇总标签
      function showTextSummaryChip(type, editorChip, text) {
        // 移除编辑器
        if (editorChip) {
          editorChip.remove();
        }

        // 创建汇总显示
        const summary = document.createElement('span');
        summary.className = 'text-summary-chip';
        summary.dataset.type = type;
        summary.title = '点击编辑';  // 添加提示
        summary.style.display = 'inline-flex';
        summary.style.alignItems = 'center';
        summary.style.gap = '4px';
        summary.style.padding = '6px 12px';
        summary.style.border = '1px solid';  // 边框颜色由CSS类控制
        summary.style.borderRadius = '10px';
        // 背景色由CSS类控制，不在这里设置
        summary.style.cursor = 'pointer';
        summary.style.fontSize = '14px';

        // 添加图标
        const icon = document.createElement('span');
        icon.textContent = TEXT_TYPE_ICONS[type] || '';
        icon.style.marginRight = '6px';
        icon.style.fontSize = '14px';
        icon.style.opacity = '0.8';
        summary.appendChild(icon);

        // 添加内容
        const content = document.createElement('span');
        content.textContent = text;
        content.style.fontWeight = '600';
        content.style.color = 'var(--text, #0b1220)';
        summary.appendChild(content);

        // 添加删除按钮
        const deleteBtn = document.createElement('button');
        deleteBtn.textContent = '×';
        deleteBtn.title = '删除';
        deleteBtn.style.border = 'none';
        deleteBtn.style.background = 'transparent';
        deleteBtn.style.color = 'var(--text-muted, #9aa6b2)';
        deleteBtn.style.cursor = 'pointer';
        deleteBtn.style.padding = '0 4px';
        deleteBtn.style.borderRadius = '4px';
        deleteBtn.style.fontSize = '14px';

        deleteBtn.addEventListener('click', (e) => {
          e.stopPropagation();
          summary.remove();
          updateTextButtonStates();
        });

        summary.appendChild(deleteBtn);

        // 点击汇总重新编辑
        summary.addEventListener('click', (e) => {
          if (e.target === deleteBtn) return;
          e.stopPropagation();

          // 获取容器和当前位置
          const container = document.getElementById('taskEditTagsContainer');
          if (!container) return;

          // 获取当前汇总的位置，用于在相同位置插入编辑器
          const nextSibling = summary.nextSibling;

          // 先移除汇总
          summary.remove();

          // 创建编辑器并插入到原位置
          const newChip = createTextEditorChip(type, null, text);
          if (nextSibling && container.contains(nextSibling)) {
            nextSibling.before(newChip);
          } else {
            container.appendChild(newChip);
          }

          // 聚焦到编辑器
          const input = newChip.querySelector('input');
          if (input) {
            setTimeout(() => {
              input.focus();
              input.select();
            }, 10);
          }
        });

        // 找到标签容器并插入
        const container = document.getElementById('taskEditTagsContainer');
        if (container) {
          // 找到该类型最后一个标签的位置
          const existingChips = container.querySelectorAll(
            `.text-editor-chip[data-type="${type}"], .text-summary-chip[data-type="${type}"]`
          );

          if (existingChips.length > 0) {
            // 在最后一个同类型标签后面插入
            existingChips[existingChips.length - 1].after(summary);
          } else {
            // 如果没有同类型标签，按类型顺序插入
            const typeOrder = ['goal', 'deliverable', 'contact', 'place', 'note'];
            const currentTypeIndex = typeOrder.indexOf(type);

            // 查找应该插入的位置
            let insertBefore = null;
            for (let i = currentTypeIndex + 1; i < typeOrder.length; i++) {
              const nextTypeChips = container.querySelectorAll(
                `.text-editor-chip[data-type="${typeOrder[i]}"], .text-summary-chip[data-type="${typeOrder[i]}"]`
              );
              if (nextTypeChips.length > 0) {
                insertBefore = nextTypeChips[0];
                break;
              }
            }

            if (insertBefore) {
              insertBefore.before(summary);
            } else {
              container.appendChild(summary);
            }
          }
        }

        // 更新按钮状态
        updateTextButtonStates();

        return summary;
      }

      // 根据类型获取文本按钮
      function getTextButtonByType(type) {
        const tagsBelt = document.getElementById('taskEditBeltTags');
        return tagsBelt.querySelector(`.task-edit-ctrl[data-type="${type}"]`);
      }

      // ===== 创建日程功能 =====

      // 从父任务创建日程分区
      function createScheduleFromTask() {
        if (!currentTask || !currentPartitionId) {
          return;
        }

        // 检查是否为父任务
        if (currentTask.level > 0) {
          return;
        }

        // 获取所有子任务
        const childTasks = getAllChildTasks(currentTask.id);
        if (childTasks.length === 0) {
          return;
        }

        try {
          // 保存当前编辑数据
          saveTimeEditorData();

          // 创建新日程分区，使用父任务标题
          const scheduleTitle = currentTask.text || '新日程';
          const newPartition = createSchedulePartition(scheduleTitle, {
            icon: "🗓️",
            time: "09:00 - 10:00"
          });

          // 清空新分区的默认任务
          newPartition.tasks = [];

          // 原子任务升级为新分区的父任务
          childTasks.forEach(({ task }) => {
            const processedTask = processTaskForSchedule(task);
            const upgradedTask = {
              ...processedTask,
              id: generateTaskId(),
              parentId: null,
              level: 0
            };
            newPartition.tasks.push(upgradedTask);
          });

          // 重新渲染页面
          sortSchedulesByTime();
          render(!!window.Sortable);

          // 关闭编辑表单
          hideEditModal();

        } catch (error) {
          console.error('创建日程失败:', error);
        }
      }

      /**
       * 处理任务模板属性
       * @param {Object} task - 原任务对象
       * @returns {Object} 处理后的任务对象
       */
      function processTaskForSchedule(task) {
        const processedTask = { ...task };

        // 重置基础状态
        processedTask.done = false;
        processedTask.isRecurring = false;

        // 精确处理模板属性
        if (processedTask.details && processedTask.details.isTemplate === true) {
          processedTask.details = {
            ...processedTask.details,
            isTemplate: false
          };
        }

        // 清理周期配置（如果存在）
        if (processedTask.details && processedTask.details.recurrence) {
          processedTask.details.recurrence = {
            enabled: false,
            pattern: 'none',
            config: {}
          };
        }

        return processedTask;
      }

      // 从内联编辑创建日程分区
      function createScheduleFromInlineEdit(taskId, partitionId) {
        const taskResult = findTaskById(taskId);
        if (!taskResult) {
          return;
        }
        const task = taskResult.task; // 从返回对象中提取任务

        // 检查是否为父任务
        if (task.level > 0) {
          return;
        }

        // 获取所有子任务
        const childTasks = getAllChildTasks(task.id);
        if (childTasks.length === 0) {
          return;
        }

        try {
          // 保存内联编辑数据
          const allInlineContainers = document.querySelectorAll('.inline-edit-container.active');
          allInlineContainers.forEach(container => {
            const taskWrap = container.closest('.task-wrapper');
            if (taskWrap) {
              const handleElement = taskWrap.querySelector('.task-handle');
              if (handleElement) {
                // 模拟点击完成按钮来保存数据
                handleElement.click();
              }
            }
          });

          // 创建新日程分区，使用父任务标题
          const scheduleTitle = task.text || '新日程';
          const newPartition = createSchedulePartition(scheduleTitle, {
            icon: "🗓️",
            time: "09:00 - 10:00"
          });

          // 清空新分区的默认任务
          newPartition.tasks = [];

          // 原子任务升级为新分区的父任务
          childTasks.forEach(({ task: childTask }) => {
            const processedTask = processTaskForSchedule(childTask);
            const upgradedTask = {
              ...processedTask,
              id: generateTaskId(),
              parentId: null,
              level: 0
            };
            newPartition.tasks.push(upgradedTask);
          });

          // 重新渲染页面
          sortSchedulesByTime();
          render(!!window.Sortable);

        } catch (error) {
          console.error('创建日程失败:', error);
        }
      }

      // 全局函数：从内联编辑创建日程分区
      window.createScheduleFromInlineEdit = createScheduleFromInlineEdit;

      // 获取指定父任务的所有子任务
      function getAllChildTasks(parentTaskId) {
        const childTasks = [];

        // 搜索所有分区中的任务
        const allPartitions = data.flat();
        allPartitions.forEach(partition => {
          if (partition && partition.tasks) {
            partition.tasks.forEach(task => {
              if (task.parentId === parentTaskId) {
                childTasks.push({
                  task: task,
                  partitionId: partition.id,
                  partition: partition
                });
              }
            });
          }
        });

        return childTasks;
      }

      // 将子任务转移到新日程分区
      function moveChildTasksToSchedule(parentTaskId, targetPartitionId) {
        const childTasks = getAllChildTasks(parentTaskId);
        const targetPartition = findPartitionById(targetPartitionId);

        if (!targetPartition) {
          return;
        }

        childTasks.forEach(({ task, partition }) => {
          // 从原分区移除任务
          const taskIndex = partition.tasks.indexOf(task);
          if (taskIndex > -1) {
            partition.tasks.splice(taskIndex, 1);
          }

          // 创建任务副本并转移到新分区
          const copiedTask = {
            ...task,
            level: 0,        // 在新日程中重置为主任务
            parentId: null   // 清除父子关系
          };

          targetPartition.tasks.push(copiedTask);

        });

        // 更新分区徽标
        if (childTasks.length > 0) {
          adjustBadgesAfterMove(currentPartitionId, targetPartitionId, null);
        }
      }


      // 事件监听
      checkbox.addEventListener('click', () => {
        // 模板任务和周期任务模板不可切换完成状态
        if (currentTask && ((currentTask.details && currentTask.details.isTemplate) || (currentTask.isRecurring && !currentTask.isGeneratedFromRecurring))) {
          return;
        }

        const isChecked = checkbox.getAttribute('aria-checked') === 'true';
        checkbox.setAttribute('aria-checked', isChecked ? 'false' : 'true');
      });

      templateToggle.addEventListener('change', () => {
        updateCheckboxStyle();
        updateUIVisibility();
      });

      closeBtn.addEventListener('click', hideEditModal);
      overlay.addEventListener('click', hideEditModal);
      confirmBtn.addEventListener('click', saveTask);

      // 创建日程按钮事件监听
      createScheduleBtn.addEventListener('click', createScheduleFromTask);

      // 时间编辑器事件监听
      const timeEditBelt = document.getElementById('taskEditBeltTime');
      if (timeEditBelt) {
        timeEditBelt.addEventListener('click', (e) => {
          const ctrl = e.target.closest('.task-edit-ctrl');
          if (!ctrl) return;

          const type = ctrl.dataset.type;
          if (type === 'repeat') {
            openRepeatEditor(ctrl);
            return;
          }

          if (['start', 'duration', 'due'].includes(type)) {
            openTimeEditor(ctrl);
          }
        });
      }

      // 文本编辑器事件监听
      const tagEditBelt = document.getElementById('taskEditBeltTags');
      if (tagEditBelt) {
        tagEditBelt.addEventListener('click', (e) => {
          const ctrl = e.target.closest('.task-edit-ctrl');
          if (!ctrl) return;

          const type = ctrl.dataset.type;
          if (['goal', 'deliverable', 'contact', 'place', 'note'].includes(type)) {
            // 在容器中查找该类型的最后一个标签作为插入点
            const container = document.getElementById('taskEditTagsContainer');
            if (container) {
              const existingChips = container.querySelectorAll(
                `.text-editor-chip[data-type="${type}"], .text-summary-chip[data-type="${type}"]`
              );
              const afterElement = existingChips.length > 0
                ? existingChips[existingChips.length - 1]
                : null;
              createTextEditorChip(type, afterElement || container, '');
            }
          }
        });
      }

      // ESC键关闭
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && modal.style.display === 'flex') {
          hideEditModal();
        }
      });

      // 全局函数，供外部调用
      window.showTaskEditModal = showEditModal;
      window.updateTaskDonePlusBadge = updateTaskDonePlusBadge;
      window.completeTask = completeTask;
    })();

    /**
     * ===== Done+功能模块 =====
     */
    (function donePlusModule() {
      const donePlusModal = document.getElementById('donePlusModal');

      const donePlusOverlay = donePlusModal.querySelector('.done-plus-overlay');
      const donePlusForm = donePlusModal.querySelector('.done-plus-form');
      const donePlusClose = donePlusModal.querySelector('.done-plus-close');
      const donePlusTextarea = donePlusModal.querySelector('.done-plus-textarea');
      const donePlusTaskInput = donePlusModal.querySelector('.done-plus-task-input');
      const donePlusTaskTextInput = donePlusModal.querySelector('.done-plus-task-text-input');
      const donePlusConfirm = donePlusModal.querySelector('.done-plus-confirm');

      let currentTask = null;
      let currentPartitionId = null;

      // 显示Done+表单
      function showDonePlusForm(task, partitionId) {
        currentTask = task;
        currentPartitionId = partitionId;

        // 清空新任务输入框
        donePlusTaskInput.value = '';

        // 回显任务文本
        donePlusTaskTextInput.value = task.text || '';

        // 回显之前保存的笔记
        if (task.donePlus && task.donePlus.note) {
          donePlusTextarea.value = task.donePlus.note;
        } else {
          donePlusTextarea.value = '';
        }

        // 简化表单标题 - 统一为"Done+ 完成"
        const formTitle = donePlusModal.querySelector('.done-plus-title');
        formTitle.textContent = 'Done+ 完成';

        // 显示表单
        donePlusModal.style.display = 'block';

        requestAnimationFrame(() => {
          donePlusForm.classList.add('show');
          donePlusTaskTextInput.focus();
          // 将光标设置到文本末尾
          donePlusTaskTextInput.setSelectionRange(donePlusTaskTextInput.value.length, donePlusTaskTextInput.value.length);
        });

        // 禁止背景滚动
        document.body.style.overflow = 'hidden';
      }

      // 隐藏Done+表单
      function hideDonePlusForm() {
        donePlusForm.classList.remove('show');
        setTimeout(() => {
          donePlusModal.style.display = 'none';
          document.body.style.overflow = '';
        }, 300);

        currentTask = null;
        currentPartitionId = null;
      }


      // 保存Done+数据
      function saveDonePlusData() {
        if (!currentTask) {
          console.error('🐛 [saveDonePlusData] 错误：currentTask为空');
          return;
        }

        const note = donePlusTextarea.value.trim();
        const newTaskText = donePlusTaskInput.value.trim();
        const updatedTaskText = donePlusTaskTextInput.value.trim();

        // 更新任务文本（如果有修改）
        let textUpdated = false;
        if (updatedTaskText && updatedTaskText !== currentTask.text) {
          const oldText = currentTask.text;
          currentTask.text = updatedTaskText;
          textUpdated = true;

          // **正确的方案：根据ID精确更新data对象中的任务**
          const result = findTaskById(currentTask.id);
          if (result && result.task) {
            result.task.text = updatedTaskText;
          } else {
            console.error('🐛 [Done+ Error] 无法找到data对象中的任务，任务ID:', currentTask.id);
          }

          // 同步更新DOM中的文本显示 - 修复选择器：使用.task-input而不是.task-text
          const taskTextElement = document.querySelector(`[data-task-id="${currentTask.id}"] .task-input`);
          if (taskTextElement) {
            taskTextElement.textContent = currentTask.text;
          } else {
            // 尝试更通用的选择器
            const taskWrapper = document.querySelector(`[data-task-id="${currentTask.id}"]`);
            if (taskWrapper) {
              const inputElement = taskWrapper.querySelector('.task-input');
              if (inputElement) {
                inputElement.textContent = currentTask.text;
              }
            }
          }
        }

        // 确保donePlus对象存在
        if (!currentTask.donePlus) {
          currentTask.donePlus = {
            enabled: false,
            note: "",
            completedAt: null
          };
        }

        // 保存笔记（总是更新，支持编辑）
        currentTask.donePlus.note = note;

        // 如果任务还未完成，则标记为完成并记录完成时间
        if (!currentTask.done) {
          currentTask.donePlus.completedAt = new Date().toISOString();
        }

        // 保存笔记
        currentTask.donePlus.note = note;

        // 如果任务文本已更新，已通过findTaskById直接更新data对象，无需调用saveAllInputs

        // 如果有新任务文本，创建完全独立的父任务（只在任务未完成时创建）
        if (newTaskText && !currentTask.done) {

          // 使用方案一：创建完全独立的任务
          const newTask = createNewDonePlusTask(newTaskText, currentTask, currentPartitionId);

          // 安全地插入新任务
          const inserted = insertIndependentTask(newTask, currentTask, currentPartitionId);

          if (!inserted) {
            console.error('Failed to insert new task');
          }
        }

        // 只有在任务未完成时才标记为完成并触发级联更新
        if (!currentTask.done) {
          // 标记原任务完成
          currentTask.done = true;

          // Done+完成时不影响模板任务状态

          // 关键修复：确保Done+功能保持启用状态
          if (!currentTask.donePlus) {
            currentTask.donePlus = {
              enabled: false,
              note: "",
              completedAt: null
            };
          }
          // 保持Done+功能启用，设置完成时间
          currentTask.donePlus.enabled = true;
          currentTask.donePlus.completedAt = new Date().toISOString();

          // 使用标准完成任务逻辑来处理级联更新
          window.completeTask(currentTask, currentPartitionId);
        } else {
          // 如果任务已经完成，只是更新了文本或笔记，需要手动刷新界面
          if (textUpdated) {
            if (typeof render === 'function') {
              render(!!window.Sortable);
            }
          }
        }

        // 隐藏表单
        hideDonePlusForm();
      }

      // 完全独立创建新Done+任务的函数
      function createNewDonePlusTask(taskText, originalTask, partitionId) {
        // 完全独立创建新任务，不受原任务影响
        const newTask = {
          id: generateTaskId(),
          text: taskText,
          done: false,
          level: 0,                    // 强制设置为顶级任务
          parentId: null,               // 强制设置为无父任务
          parentIndex: null,            // 清除可能的索引继承
          donePlus: {
            enabled: false,
            note: "",
            completedAt: null
          },
          details: {},                  // 空的details对象
          isRecurring: false,           // 明确设置非周期任务
          isGeneratedFromRecurring: false // 明确设置非周期生成任务
        };

        // 深度克隆以确保完全独立
        return JSON.parse(JSON.stringify(newTask));
      }

      // 安全插入独立任务的函数
      function insertIndependentTask(newTask, originalTask, partitionId) {
        const partition = findPartitionById(partitionId);
        if (!partition) {
          return false;
        }

        const tasks = partition.tasks || [];

        // 找到原任务位置并计算正确的插入位置
        const currentIndex = tasks.findIndex(t => t.id === originalTask.id);

        if (currentIndex !== -1) {
          // 计算正确的插入位置：需要跳过原任务的所有子任务
          let insertIndex = currentIndex + 1;

          // 跳过原任务的所有子任务
          while (insertIndex < tasks.length && tasks[insertIndex].parentId === originalTask.id) {
            insertIndex++;
          }

          // 在原任务及其所有子任务后插入新Done+任务
          tasks.splice(insertIndex, 0, newTask);
        } else {
          // 如果找不到原任务，添加到末尾
          tasks.push(newTask);
        }

        return true;
      }

      // 在任务后插入新任务的辅助函数（保留用于其他用途）
      function insertTaskAfter(originalTask, newTask) {
        return insertIndependentTask(newTask, originalTask, currentPartitionId);
      }

      // 事件绑定 - 使用更可靠的方式
      function bindDonePlusEvents() {
        if (donePlusClose) {
          donePlusClose.addEventListener('click', (e) => {
            e.preventDefault();
            hideDonePlusForm();
          });
        }

        if (donePlusOverlay) {
          donePlusOverlay.addEventListener('click', (e) => {
            e.preventDefault();
            hideDonePlusForm();
          });
        }

        // 简化事件绑定 - 只有保存按钮触发保存和创建任务
        if (donePlusConfirm) {
          donePlusConfirm.addEventListener('click', (e) => {
            e.preventDefault();
            saveDonePlusData();
          });
        }
      }

      // 立即绑定事件，并确保DOM已经准备好
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', bindDonePlusEvents);
      } else {
        bindDonePlusEvents();
      }

      // 也要在表单显示时重新绑定，以防DOM结构发生变化
      const originalShowDonePlusForm = showDonePlusForm;
      window.showDonePlusForm = function(task, partitionId) {
        originalShowDonePlusForm(task, partitionId);
        setTimeout(bindDonePlusEvents, 100); // 重新绑定事件
      };

      // ESC键关闭表单
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape' && donePlusModal.style.display === 'block') {
          hideDonePlusForm();
        }
      });

      // 暴露函数到全局作用域
      window.showDonePlusForm = showDonePlusForm;
    })();

    /**
     * ===== 内联编辑功能模块 =====
     */
    (function inlineEditModule() {

      // Done+功能切换函数
      function toggleInlineDonePlusMode(checkbox, taskId, partitionId) {
        const taskResult = findTaskById(taskId);
        if (!taskResult) return;

        const task = taskResult.task;
        // 强制使用反值：如果当前是false就设为true，如果当前是true就设为false
        const currentEnabled = task.donePlus && task.donePlus.enabled;
        const isEnabled = !currentEnabled; // 切换状态

        // 确保donePlus对象存在
        if (!task.donePlus) {
          task.donePlus = {
            enabled: false,
            note: "",
            completedAt: null
          };
        }

        // 更新Done+状态
        task.donePlus.enabled = isEnabled;

        // 更新任务列表中的Done+角标显示
        const taskWrapper = document.querySelector(`[data-task-id="${taskId}"]`);
        if (taskWrapper) {
          window.updateTaskDonePlusBadge(taskWrapper, task);
        }

        // 保存状态
        saveAllInputs();
      }

      // 内联编辑切换函数
      function toggleInlineEdit(task, partitionId, handleElement) {
        // handle是.task的子元素，需要向上查找.task-wrapper
        // DOM结构：.task-wrapper > .task > .task-handle
        let taskWrap = handleElement.closest('.task-wrapper');

        // 如果没找到，可能handle在.task内，需要再向上一级
        if (!taskWrap) {
          const taskElement = handleElement.closest('.task');
          if (taskElement) {
            taskWrap = taskElement.parentElement.closest('.task-wrapper') || taskElement.parentElement;
          }
        }

        if (!taskWrap) {
          return;
        }

        const container = taskWrap.querySelector('.inline-edit-container');
        if (!container) {
          return;
        }

        const summary = taskWrap.querySelector('.inline-summary') ||
                       taskWrap.parentElement.querySelector('.inline-summary') ||
                       taskWrap.nextElementSibling;
        const isActive = container.classList.contains('active');

        if (isActive) {
          // 关闭编辑模式，保存数据
          container.classList.remove('active');

          // **关键修复**:在render()销毁DOM前,手动保存任务文本
          const txtElement = taskWrap.querySelector('.task-input');
          if (txtElement && txtElement.textContent !== null && txtElement.textContent.trim() !== '') {
            task.text = txtElement.textContent.trim();
          }

          // 恢复原始grid布局
          const taskElement = taskWrap.querySelector('.task');
          if (taskElement) {
            taskElement.style.gridTemplateColumns = ''; // 恢复默认值
          }

          handleElement.textContent = '≡';
          handleElement.style.fontSize = '22px';  // 恢复原始样式
          handleElement.style.color = '#999';
          handleElement.style.padding = '0 4px';  // 恢复原始内边距
          handleElement.style.width = '';  // 清除宽度设置
          handleElement.style.flexShrink = '';  // 清除flex-shrink设置
          handleElement.style.fontWeight = '';  // 清除字体粗细设置
          saveInlineEditData(task, container);
          updateInlineSummary(task, taskWrap);

          // 延迟渲染，确保任务文本输入框的blur事件先完成
          requestAnimationFrame(() => {
            render(true);
          });

          // 恢复task-summary显示（如果有的话）
          const taskSummary = taskWrap.querySelector('.task-summary');
          if (taskSummary) {
            taskSummary.style.display = '';
          }
        } else {
          // 打开编辑模式
          container.classList.add('active');

          // 调整grid布局以容纳"完成"按钮
          const taskElement = taskWrap.querySelector('.task');
          if (taskElement) {
            taskElement.style.gridTemplateColumns = '18px 1fr 40px'; // 扩大最后一列宽度
          }

          handleElement.textContent = '完成';  // 改为"完成"文字
          handleElement.style.fontSize = '14px';  // 正常字体大小
          handleElement.style.color = '#007AFF';  // 蓝色高亮
          handleElement.style.padding = '0 4px';  // 适当内边距
          handleElement.style.width = '40px';  // 固定宽度
          handleElement.style.flexShrink = '0';  // 防止被flex压缩
          handleElement.style.fontWeight = '600';  // 加粗让文字更清晰

          // 隐藏所有类型的缩略信息
          if (summary && summary.classList?.contains('inline-summary')) {
            summary.style.display = 'none';
          }
          // 也隐藏task-summary类型的缩略信息
          const taskSummary = taskWrap.querySelector('.task-summary');
          if (taskSummary) {
            taskSummary.style.display = 'none';
          }

          // 初始化编辑器
          if (container.innerHTML.trim() === '') {
            container.innerHTML = createInlineEditUI(task, partitionId);
          }
          // 总是初始化值，无论是否新创建
          initializeInlineEditValues(task, container);
        }
      }

      // 初始化编辑器的值（支持新的分层数据结构）
      function initializeInlineEditValues(task, container) {
        // 清空之前的标签（避免重复）
        container.querySelectorAll('.inline-tag').forEach(tag => tag.remove());

        // 设置Done+开关
        // 查找包含"Done+"文本的开关按钮
        const donePlusSwitchButton = Array.from(container.querySelectorAll('.inline-switch-button'))
          .find(button => button.textContent.includes('Done+'));

        if (donePlusSwitchButton) {
          const donePlusSwitch = donePlusSwitchButton.querySelector('.inline-switch input');
          if (donePlusSwitch) {
            const isDonePlusEnabled = (task.donePlus && task.donePlus.enabled) || false;
            donePlusSwitch.checked = isDonePlusEnabled;
          }
        }

        // 设置模板任务开关
        if (task.details && task.details.isTemplate) {
          // 查找包含"模版任务"文本的开关按钮
          const templateSwitchButton = Array.from(container.querySelectorAll('.inline-switch-button'))
            .find(button => button.textContent.includes('模版任务'));

          if (templateSwitchButton) {
            const templateSwitch = templateSwitchButton.querySelector('.inline-switch input');
            if (templateSwitch) {
              templateSwitch.checked = true;
            }
          }
        }

        // 如果没有details，直接返回
        if (!task.details) return;

        // 设置时间相关字段（根据 visibility 决定是否展开）
        if (task.details.time || task.details.visibility) {
          // 设置开始时间（从 yyyy-mm-dd hh:mm:ss 转换为 datetime-local格式）
          const startInput = container.querySelector('input[data-type="start"]');
          if (startInput && task.details.time?.start) {
            // 转换格式：yyyy-mm-dd hh:mm:ss -> yyyy-mm-ddThh:mm
            const startTime = task.details.time.start.replace(' ', 'T').substring(0, 16);
            startInput.value = startTime;
            // 根据 visibility 决定是否展开，如果没有 visibility 字段则默认展开（兼容旧数据）
            const shouldShow = task.details.visibility ? task.details.visibility.start : true;
            if (shouldShow) {
              startInput.style.display = 'inline-block';
              const btn = startInput.parentElement.querySelector('button');
              if (btn && btn.textContent.includes('+')) {
                btn.textContent = btn.textContent.replace('+', '');
              }
            }
          }

          // 设置截止时间
          const endInput = container.querySelector('input[data-type="end"]');
          if (endInput && task.details.time?.end) {
            const endTime = task.details.time.end.replace(' ', 'T').substring(0, 16);
            endInput.value = endTime;
            // 根据 visibility 决定是否展开
            const shouldShow = task.details.visibility ? task.details.visibility.end : true;
            if (shouldShow) {
              endInput.style.display = 'inline-block';
              const btn = endInput.parentElement.querySelector('button');
              if (btn && btn.textContent.includes('+')) {
                btn.textContent = btn.textContent.replace('+', '');
              }
            }
          }

          // 设置用时
          const durInput = container.querySelector('.duration-input');
          const unitSelect = container.querySelector('.duration-unit');
          if (durInput && unitSelect && task.details.time?.duration) {
            durInput.value = task.details.time.duration.value;
            unitSelect.value = task.details.time.duration.unit;
            // 根据 visibility 决定是否展开
            const shouldShow = task.details.visibility ? task.details.visibility.duration : true;
            if (shouldShow) {
              durInput.style.display = 'inline-block';
              unitSelect.style.display = 'inline-block';
              const btn = durInput.parentElement.querySelector('button');
              if (btn && btn.textContent.includes('+')) {
                btn.textContent = btn.textContent.replace('+', '');
              }
            }
          }
        }

        // 设置周期
        const cycleSelect = container.querySelector('.cycle-select');
        if (cycleSelect && task.details.recurrence?.enabled) {
          // 映射周期值（如果pattern是英文则映射）
          let mappedValue = task.details.recurrence.pattern;
          const patternMapping = {
            'daily': '每天',
            'weekly': '每周',
            'monthly': '每月'
          };
          if (patternMapping[mappedValue]) {
            mappedValue = patternMapping[mappedValue];
          }

          cycleSelect.value = mappedValue;

          // 根据 visibility 决定是否展开
          const shouldShow = task.details.visibility ? task.details.visibility.repeat : true;
          if (shouldShow) {
            cycleSelect.style.display = 'inline-block';
            const btn = cycleSelect.parentElement.querySelector('.inline-button.周期');
            if (btn && btn.textContent.includes('+')) {
              btn.textContent = btn.textContent.replace('+', '');
            }

            // 如果是每周，设置周几
            if (mappedValue === '每周' && task.details.recurrence.config.weekdays) {
              const weekdaysDiv = container.querySelector('.inline-weekdays');
              if (weekdaysDiv) {
                weekdaysDiv.style.display = 'flex';
                task.details.recurrence.config.weekdays.forEach(day => {
                  const checkbox = weekdaysDiv.querySelector(`input[value="${day}"]`);
                  if (checkbox) checkbox.checked = true;
                });
              }
            }
          }
        }

        // 设置文本标签
        if (task.details.tags) {
          const tagMapping = {
            'goals': '目标',
            'outputs': '产出物',
            'contacts': '联系人',
            'locations': '地点',
            'notes': '备注'
          };

          Object.entries(task.details.tags).forEach(([field, values]) => {
            const label = tagMapping[field];
            if (label && values && values.length > 0) {
              const btn = container.querySelector(`.inline-button.${label}`);
              if (btn) {
                values.forEach(value => {
                  if (value && value.trim()) {
                    // 模拟点击按钮添加标签，传入预设值
                    window.addInlineInput(new Event('click'), label, btn, value);
                  }
                });
              }
            }
          });
        }
      }

      function createInlineEditUI(task, partitionId) {
        const isTemplate = (task.details && task.details.isTemplate) || false;
        const isRecurring = task.isRecurring || false;
        const partition = findPartitionById(partitionId);
        const isScheduleTask = partition && !partition.meta?.isTodoPartition;

        // 日程分区隐藏时间相关字段，子任务不显示模板开关
        const templateSwitchHtml = (!isRecurring && !isScheduleTask && (!task.level || task.level === 0)) ?
          `<div class="inline-switch-button">
            模版任务
            <label class="inline-switch">
              <input type="checkbox" ${isTemplate ? 'checked' : ''} onchange="toggleInlineTemplateMode(this)">
              <span class="inline-slider"></span>
            </label>
          </div>` : '';

        const startTimeHtml = !isScheduleTask ?
          `<div class="inline-button-group">
            <button class="inline-button" onclick="toggleInlineTimeInput(this, 'start')">🕒 开始+</button>
            <input type="datetime-local" class="inline-input time-input" data-type="start" style="display:none;" onclick="event.stopPropagation()">
          </div>` : '';

        const durationHtml = !isScheduleTask ?
          `<div class="inline-button-group">
            <button class="inline-button" onclick="toggleInlineDurationInput(this)">⏳ 用时+</button>
            <input type="number" class="inline-input duration-input" style="width:60px;display:none;" min="1" onclick="event.stopPropagation()">
            <select class="inline-input duration-unit" style="display:none;" onclick="event.stopPropagation()">
              <option value="min">分钟</option><option value="h">小时</option><option value="d">天</option>
            </select>
          </div>` : '';

        const endTimeHtml = !isScheduleTask ?
          `<div class="inline-button-group">
            <button class="inline-button" onclick="toggleInlineTimeInput(this, 'end')">‼️ 截止+</button>
            <input type="datetime-local" class="inline-input time-input" data-type="end" style="display:none;" onclick="event.stopPropagation()">
          </div>` : '';

        const cycleButtonHtml = !isScheduleTask ?
          `<div class="inline-button-group">
            <button class="inline-button 周期" onclick="toggleInlineCycleInput(this)">
              <svg class="inline-icon-svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round" aria-label="cycle">
                <path d="M4 12a8 8 0 0 1 13-5.3"/>
                <polyline points="14.5 4 17 6.5 14.5 9"/>
                <path d="M20 12a8 8 0 0 1-13 5.3"/>
                <polyline points="9.5 20 7 17.5 9.5 15"/>
              </svg>
              周期+
            </button>
            <select class="inline-input cycle-select" style="display:none;">
              <option value="">选择周期</option>
              <option value="每天">每天</option>
              <option value="每周">每周</option>
              <option value="每月">每月</option>
            </select>
            <div class="inline-weekdays inline-input" style="display:none;">
              ${['一','二','三','四','五','六','日'].map(d=>`<label><input type="checkbox" value="${d}">${d}</label>`).join('')}
            </div>
          </div>` : '';

        // Done+功能开关
        const isDonePlusEnabled = (task.donePlus && task.donePlus.enabled) || false;
        const donePlusHtml =
          `<div class="inline-switch-button">
            Done+
            <label class="inline-switch">
              <input type="checkbox" ${isDonePlusEnabled ? 'checked' : ''}
                     onchange="toggleInlineDonePlusMode(this, '${task.id}', '${partitionId}')">
              <span class="inline-slider"></span>
            </label>
          </div>`;

        // 检查是否有子任务
        const hasChildren = task.level === 0 && hasChildTasks(task.id);
        const createScheduleHtml = (hasChildren && !isScheduleTask) ?
          `<div class="inline-button-group">
            <button class="inline-button create-schedule" onclick="createScheduleFromInlineEdit('${task.id}', '${partitionId}')">📅 创建日程</button>
          </div>` : '';

        return `
          ${donePlusHtml}
          ${templateSwitchHtml}
          ${startTimeHtml}
          ${durationHtml}
          ${endTimeHtml}
          ${cycleButtonHtml}
          ${['目标','产出物','联系人','地点','备注'].map(l=>`
            <div class="inline-button-group">
              <button class="inline-button ${l}" onclick="addInlineInput(event,'${l}',this)">
                ${getInlineIcon(l)} ${l}<span class="inline-count"></span>
              </button>
            </div>`).join('')}
          ${createScheduleHtml}
        `;
      }

      // 保存内联编辑数据（使用新的分层数据结构）
      function saveInlineEditData(task, container) {
        // 初始化details结构
        if (!task.details) {
          task.details = {
            isTemplate: false,
            time: {},
            recurrence: {
              enabled: false,
              pattern: "none",
              config: {}
            },
            tags: {
              goals: [],
              outputs: [],
              contacts: [],
              locations: [],
              notes: []
            },
            visibility: {
              start: false,
              duration: false,
              end: false,
              repeat: false
            }
          };
        }

        // 保存Done+状态
        // 查找包含"Done+"文本的开关按钮
        const donePlusSwitchButton = Array.from(container.querySelectorAll('.inline-switch-button'))
          .find(button => button.textContent.includes('Done+'));

        if (donePlusSwitchButton) {
          const donePlusSwitch = donePlusSwitchButton.querySelector('.inline-switch input[type="checkbox"]');
          if (donePlusSwitch) {
            // 确保donePlus对象存在
            if (!task.donePlus) {
              task.donePlus = {
                enabled: false,
                note: "",
                completedAt: null
              };
            }
            task.donePlus.enabled = donePlusSwitch.checked;
          }
        }

        // 保存模板任务状态
        // 查找包含"模版任务"文本的开关按钮
        const templateSwitchButton = Array.from(container.querySelectorAll('.inline-switch-button'))
          .find(button => button.textContent.includes('模版任务'));

        if (templateSwitchButton) {
          const templateSwitch = templateSwitchButton.querySelector('.inline-switch input[type="checkbox"]');
          if (templateSwitch) {
            task.details.isTemplate = templateSwitch.checked;
          }
        }

        // 初始化子对象
        if (!task.details.time) task.details.time = {};
        if (!task.details.recurrence) {
          task.details.recurrence = {
            enabled: false,
            pattern: "none",
            config: {}
          };
        }
        if (!task.details.visibility) {
          task.details.visibility = {
            start: false,
            duration: false,
            end: false,
            repeat: false
          };
        }

        // 保存开始时间和可见性（转换为 yyyy-mm-dd hh:mm:ss 格式）
        const startInput = container.querySelector('input[data-type="start"]');
        if (startInput) {
          // 保存可见性状态（根据输入框是否显示）
          task.details.visibility.start = startInput.style.display !== 'none' && startInput.style.display !== '';

          if (startInput.value) {
            // datetime-local的值格式是 yyyy-mm-ddThh:mm，需要转换
            task.details.time.start = startInput.value.replace('T', ' ') + ':00';
          } else {
            delete task.details.time.start;
          }
        }

        // 保存截止时间和可见性
        const endInput = container.querySelector('input[data-type="end"]');
        if (endInput) {
          // 保存可见性状态
          task.details.visibility.end = endInput.style.display !== 'none' && endInput.style.display !== '';

          if (endInput.value) {
            task.details.time.end = endInput.value.replace('T', ' ') + ':00';
          } else {
            delete task.details.time.end;
          }
        }

        // 保存用时和可见性
        const durInput = container.querySelector('.duration-input');
        const unitSelect = container.querySelector('.duration-unit');
        if (durInput) {
          // 保存可见性状态
          task.details.visibility.duration = durInput.style.display !== 'none' && durInput.style.display !== '';

          if (durInput.value && unitSelect) {
            task.details.time.duration = {
              value: parseInt(durInput.value),
              unit: unitSelect.value
            };
          } else {
            delete task.details.time.duration;
          }
        }

        // 保存周期设置和可见性
        const cycleSelect = container.querySelector('.cycle-select');
        if (cycleSelect) {
          // 保存可见性状态
          task.details.visibility.repeat = cycleSelect.style.display !== 'none' && cycleSelect.style.display !== '';

          if (cycleSelect.value && cycleSelect.style.display !== 'none') {
            task.details.recurrence.enabled = true;
            task.details.recurrence.pattern = cycleSelect.value;

            // 如果是每周，保存周几配置
            if (cycleSelect.value === '每周') {
              const checkedDays = [...container.querySelectorAll('.inline-weekdays input:checked')].map(cb => cb.value);
              task.details.recurrence.config.weekdays = checkedDays;
            } else {
              delete task.details.recurrence.config.weekdays;
            }

            task.isRecurring = true;
          } else {
            task.details.recurrence.enabled = false;
            task.details.recurrence.pattern = "none";
            task.details.recurrence.config = {};
            task.isRecurring = false;
          }
        }

        // 初始化tags对象
        if (!task.details.tags) {
          task.details.tags = {
            goals: [],
            outputs: [],
            contacts: [],
            locations: [],
            notes: []
          };
        }

        // 保存文本标签（映射到新的字段名）
        const tagMapping = {
          '目标': 'goals',
          '产出物': 'outputs',
          '联系人': 'contacts',
          '地点': 'locations',
          '备注': 'notes'
        };

        Object.entries(tagMapping).forEach(([label, field]) => {
          const tags = container.querySelectorAll(`.inline-tag.${label} input`);
          const values = Array.from(tags).map(input => input.value).filter(v => v.trim());
          task.details.tags[field] = values;
        });

      }

      // 更新内联缩略信息（支持新的分层数据结构）
      function updateInlineSummary(task, taskWrap) {
        // 基于保存的数据生成缩略信息
        if (!task.details) {
          // 如果没有details，隐藏缩略信息
          const summary = taskWrap.querySelector('.inline-summary');
          if (summary) summary.style.display = 'none';
          return;
        }

        let text = '';

        // 统计文本标签数量（从task.details.tags读取）
        if (task.details.tags) {
          const counts = {};
          const tagMapping = {
            'goals': '目标',
            'outputs': '产出物',
            'contacts': '联系人',
            'locations': '地点',
            'notes': '备注'
          };

          Object.entries(task.details.tags).forEach(([field, values]) => {
            if (values && values.length > 0) {
              const label = tagMapping[field];
              if (label) counts[label] = values.length;
            }
          });

          const icons = {'目标':'🎯','产出物':'📦','联系人':'👤','地点':'📍','备注':'📝'};
          text = Object.entries(counts).map(([k,v]) => `${icons[k]||''}${v}`).join('，');
        }

        // 时间信息（根据 visibility 决定是否显示）
        if (task.details.time) {
          const times = [];
          // 只有当 visibility.start 为 true 或不存在 visibility 时才显示开始时间
          if (task.details.time.start && (!task.details.visibility || task.details.visibility.start)) {
            // 格式化时间显示 yyyy-mm-dd hh:mm:ss -> yyyy-mm-dd hh:mm
            times.push(task.details.time.start.substring(0, 16));
          }
          // 只有当 visibility.end 为 true 或不存在 visibility 时才显示截止时间
          if (task.details.time.end && (!task.details.visibility || task.details.visibility.end)) {
            times.push(task.details.time.end.substring(0, 16));
          }
          if (times.length) {
            text += (text ? '，' : '') + '🕒' + times.join(' ~ ');
          }

          // 用时（根据 visibility 决定是否显示）
          if (task.details.time.duration && (!task.details.visibility || task.details.visibility.duration)) {
            const dur = task.details.time.duration;
            const unitText = dur.unit === 'min' ? '分钟' : dur.unit === 'h' ? '小时' : '天';
            text += (text ? '，' : '') + '⏳' + dur.value + unitText;
          }
        }

        // 周期（根据 visibility 决定是否显示）
        if (task.details.recurrence && task.details.recurrence.enabled &&
            (!task.details.visibility || task.details.visibility.repeat)) {
          let pattern = task.details.recurrence.pattern;
          // 映射英文到中文
          const patternMapping = {
            'daily': '每天',
            'weekly': '每周',
            'monthly': '每月'
          };
          if (patternMapping[pattern]) {
            pattern = patternMapping[pattern];
          }

          let desc = `<svg style="width:12px;height:12px;color:#007aff;vertical-align:middle;margin-right:2px" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"><path d="M4 12a8 8 0 0 1 13-5.3"/><polyline points="14.5 4 17 6.5 14.5 9"/><path d="M20 12a8 8 0 0 1-13 5.3"/><polyline points="9.5 20 7 17.5 9.5 15"/></svg>` + pattern;
          if (pattern === '每周' && task.details.recurrence.config.weekdays) {
            desc += '(' + task.details.recurrence.config.weekdays.join('') + ')';
          }
          text += (text ? '，' : '') + desc;
        }

        // 查找或创建缩略信息元素
        let summary = taskWrap.querySelector('.inline-summary');

        if (text) {
          if (summary) {
            summary.innerHTML = text;
            summary.style.display = 'inline-block';
          } else {
            summary = document.createElement('div');
            summary.className = 'inline-summary';
            summary.innerHTML = text;
            // 插入到task的下方
            const taskElement = taskWrap.querySelector('.task');
            if (taskElement) {
              taskElement.insertAdjacentElement('afterend', summary);
            } else {
              taskWrap.appendChild(summary);
            }
          }
        } else if (summary) {
          summary.style.display = 'none';
        }
      }

      // 全局函数，供外部调用
      window.toggleInlineEdit = toggleInlineEdit;

      // 工具函数
      window.toggleInlineTemplateMode = function(input) {
        // 立即更新模板任务的视觉效果
        const taskWrap = input.closest('.task-wrapper');
        if (taskWrap) {
          taskWrap.classList.toggle('template', input.checked);

          // 立即更新任务勾选框的图标样式
          const checkbox = taskWrap.querySelector('.checkbox');
          if (checkbox) {
            // 保存Done+角标
            const donePlusBadge = checkbox.querySelector('.done-plus-badge');

            if (input.checked) {
              checkbox.classList.add('template');
              checkbox.classList.remove('recurring');
              checkbox.setAttribute('aria-checked', 'false');
            } else {
              checkbox.classList.remove('template');
            }

            // 恢复Done+角标（如果存在）
            if (donePlusBadge) {
              checkbox.appendChild(donePlusBadge);
            }
          }

          // 找到当前任务并更新其模板状态
          const taskId = taskWrap.dataset.taskId;
          if (taskId) {
            const result = findTaskById(taskId);
            if (result && result.task) {
              // 初始化details结构
              if (!result.task.details) {
                result.task.details = {};
              }
              // 立即更新任务的模板状态
              result.task.details.isTemplate = input.checked;

              // 找到并更新所有子任务的视觉效果
              const partition = result.partition;
              if (partition && partition.tasks) {
                const childTasks = partition.tasks.filter(t => t.parentId === taskId);
                const partitionEl = taskWrap.closest('.partition');

                childTasks.forEach(childTask => {
                  // 尝试多种方式查找子任务DOM元素
                  let childWrapper = partitionEl?.querySelector(`.task-wrapper[data-task-id="${childTask.id}"]`);

                  // 如果找不到，尝试不带连字符的属性名
                  if (!childWrapper) {
                    childWrapper = partitionEl?.querySelector(`[data-taskId="${childTask.id}"]`);
                  }

                  // 如果还找不到，遍历所有wrapper查看
                  if (!childWrapper) {
                    const allWrappers = partitionEl?.querySelectorAll('.task-wrapper');
                    allWrappers?.forEach(w => {
                      const taskId = w.dataset.taskId || w.getAttribute('data-taskId');
                      if (taskId === childTask.id) {
                        childWrapper = w;
                      }
                    });
                  }

                  if (childWrapper) {
                    const childCheckbox = childWrapper.querySelector('.checkbox');
                    if (childCheckbox) {
                      // 保存Done+角标
                      const donePlusBadge = childCheckbox.querySelector('.done-plus-badge');

                      if (input.checked) {
                        childWrapper.classList.add('template');
                        childCheckbox.classList.add('template');
                        childCheckbox.classList.remove('recurring');
                        childCheckbox.setAttribute('aria-checked', 'false');
                      } else {
                        childWrapper.classList.remove('template');
                        childCheckbox.classList.remove('template');
                      }

                      // 恢复Done+角标（如果存在）
                      if (donePlusBadge) {
                        childCheckbox.appendChild(donePlusBadge);
                      }
                    }
                  }
                });
              }
            }
          }
        }
      };

      window.toggleInlineTimeInput = function(btn, type) {
        const group = btn.parentElement;
        const input = group.querySelector('input');
        const show = input.style.display === 'none' || input.style.display === '';
        input.style.display = show ? 'inline-block' : 'none';

        // 更新按钮文本
        if (show) {
          // 展开时，移除 + 号
          if (btn.textContent.includes('+')) {
            btn.textContent = btn.textContent.replace('+', '');
          }
          input.focus();
        } else {
          // 收起时，如果没有值则添加 + 号
          if (!input.value && !btn.textContent.includes('+')) {
            btn.textContent = btn.textContent + '+';
          }
        }
      };

      window.toggleInlineDurationInput = function(btn) {
        const group = btn.parentElement;
        const input = group.querySelector('.duration-input');
        const select = group.querySelector('.duration-unit');
        const show = input.style.display === 'none' || input.style.display === '';
        input.style.display = show ? 'inline-block' : 'none';
        select.style.display = show ? 'inline-block' : 'none';

        // 更新按钮文本
        if (show) {
          // 展开时，移除 + 号
          if (btn.textContent.includes('+')) {
            btn.textContent = btn.textContent.replace('+', '');
          }
          input.focus();
        } else {
          // 收起时，如果没有值则添加 + 号
          if (!input.value && !btn.textContent.includes('+')) {
            btn.textContent = btn.textContent + '+';
          }
        }
      };

      window.toggleInlineCycleInput = function(btn) {
        const group = btn.parentElement;
        const select = group.querySelector('.cycle-select');
        const weekdays = group.querySelector('.inline-weekdays');
        const show = select.style.display === 'none' || select.style.display === '';
        select.style.display = show ? 'inline-block' : 'none';

        // 更新按钮文本
        if (show) {
          // 展开时，移除 + 号
          if (btn.textContent.includes('+')) {
            btn.textContent = btn.textContent.replace('+', '');
          }
          select.onchange = () => {
            weekdays.style.display = select.value === '每周' ? 'flex' : 'none';
          };
        } else {
          // 收起时，如果没有值则添加 + 号
          if (!select.value && !btn.textContent.includes('+')) {
            btn.textContent = btn.textContent + '+';
          }
          // 同时隐藏周几选择器
          weekdays.style.display = 'none';
        }
      };

      window.getInlineIcon = function(type) {
        return {目标:'🎯',产出物:'📦',地点:'📍',联系人:'👤',备注:'📝'}[type] || '';
      };

      window.addInlineInput = function(e, type, btn, presetValue) {
        e.stopPropagation();

        // 不再需要处理+号
        // const btnHTML = btn.innerHTML;
        // if (btnHTML.includes('+') && !presetValue) {
        //   btn.innerHTML = btnHTML.replace('+', '');
        // }
        const group = btn.parentElement;
        // 找到主容器 - 标签应该添加到主容器而不是按钮组
        const mainContainer = group.closest('.inline-edit-container');

        const tag = document.createElement('div');
        tag.className = `inline-tag ${type}`;
        // 移除内联样式，让CSS类来控制样式

        const input = document.createElement('input');
        input.placeholder = type;
        input.value = presetValue || '';  // 支持预设值
        // 移除内联样式，让CSS类来控制样式

        input.oninput = () => resizeInlineInput(input);
        input.onkeydown = ev => {
          if (ev.key === 'Enter') {
            ev.preventDefault();
            // 保存当前输入并创建新的
            if (input.value.trim()) {
              window.addInlineInput(e, type, btn);
            }
          } else if (ev.key === 'Escape') {
            ev.preventDefault();
            if (!input.value.trim()) {
              tag.remove();
              updateInlineCount(type, group);
            }
          }
        };

        const closeBtn = document.createElement('button');
        closeBtn.className = 'close';
        closeBtn.textContent = '×';
        // 移除部分内联样式，让CSS类来控制
        closeBtn.onclick = () => {
          tag.remove();
          updateInlineCount(type, group);
        };
        tag.append(input, closeBtn);

        // 标签应该和对应的按钮保持在同一个按钮组内
        group.append(tag);
        resizeInlineInput(input);
        if (!presetValue) {
          input.focus();
        }
        updateInlineCount(type, group);
      };

      function resizeInlineInput(input) {
        const span = document.createElement('span');
        span.style.position = 'absolute';
        span.style.visibility = 'hidden';
        span.style.whiteSpace = 'pre';
        span.style.fontSize = '13px';
        span.textContent = input.value || input.placeholder;
        document.body.appendChild(span);
        input.style.width = Math.min(Math.max(span.offsetWidth + 20, 36), 160) + 'px';
        document.body.removeChild(span);
      }

      function updateInlineCount(type, group) {
        // 恢复原有的简单逻辑，在按钮组内查找对应类型的标签
        const count = group.querySelectorAll('.inline-tag.' + type).length;
        const countEl = group.querySelector('.inline-count');
        if (countEl) {
          countEl.textContent = count > 0 ? count : '';
        }
      }

      // 全局函数：Done+功能切换
      window.toggleInlineDonePlusMode = toggleInlineDonePlusMode;

    })();

    /**
     * 主渲染函数
     * @param {boolean} [enableDrag=!!window.Sortable] - 是否启用拖拽功能，默认根据SortableJS是否加载判断
     * @description 完整重新渲染整个应用界面，包括保存输入、排序、渲染待办和日程分区
     */
    function render(enableDrag = !!window.Sortable){

      // 记录渲染前的数据状态
      const beforeRender = {
        todoPartitions: getTodoPartitions().length,
        schedulePartitions: getSchedulePartitions().length,
        totalTodoTasks: getTodoPartitions().reduce((sum, p) => sum + (p.tasks ? p.tasks.length : 0), 0),
        totalScheduleTasks: getSchedulePartitions().reduce((sum, p) => sum + (p.tasks ? p.tasks.length : 0), 0)
      };

      saveAllInputs();
      sortSchedulesByTime();
      renderTodo(enableDrag);
      renderSchedules(enableDrag);

      // 记录渲染后的数据状态
      const afterRender = {
        todoPartitions: getTodoPartitions().length,
        schedulePartitions: getSchedulePartitions().length,
        totalTodoTasks: getTodoPartitions().reduce((sum, p) => sum + (p.tasks ? p.tasks.length : 0), 0),
        totalScheduleTasks: getSchedulePartitions().reduce((sum, p) => sum + (p.tasks ? p.tasks.length : 0), 0)
      };

      if (beforeRender.totalTodoTasks !== afterRender.totalTodoTasks) {
        // 渲染前后任务数量发生变化
      }

      // 绑定统一添加按钮事件
      const addBtn = document.getElementById('addBtn');
      if (addBtn && !addBtn.__bound) {
        addBtn.addEventListener('click', (event) => {
          event.stopPropagation();
          const dropdown = document.getElementById('addDropdownMenu');

          if (dropdown.classList.contains('show')) {
            hideAddDropdown();
          } else {
            showAddDropdown();
          }
        });
        addBtn.__bound = true;
      }

      // 绑定新建功能选项事件 - 专注模式风格
      const addDropdownItems = document.querySelectorAll('#addDropdownMenu .menu-item');
      addDropdownItems.forEach(item => {
        if (!item.__bound) {
          // 移动端触摸反馈
          item.addEventListener('touchstart', (event) => {
            event.stopPropagation();
            item.style.background = 'rgba(0,0,0,.1)';
            item.style.transform = 'scale(0.98)';
          });

          item.addEventListener('touchend', (event) => {
            event.stopPropagation();
            item.style.background = '';
            item.style.transform = '';
          });

          item.addEventListener('click', (event) => {
            event.stopPropagation();
            const action = item.dataset.action;
            hideAddDropdown();
            callAddFunction(action);
          });
          item.__bound = true;
        }
      });

      // 绑定AI按钮事件
      const aiBtn = document.getElementById('aiBtn');
      console.log('AI按钮元素:', aiBtn); // 调试信息
      if (aiBtn && !aiBtn.__bound) {
        aiBtn.addEventListener('click', (event) => {
          console.log('AI按钮被点击'); // 调试信息
          event.stopPropagation();
          const dropdown = document.getElementById('aiDropdown');

          if (dropdown.classList.contains('show')) {
            console.log('关闭AI下拉菜单'); // 调试信息
            hideAIDropdown();
          } else {
            console.log('显示AI下拉菜单'); // 调试信息
            showAIDropdown();
          }
        });
        aiBtn.__bound = true;
        console.log('AI按钮事件绑定完成'); // 调试信息
      }


      // ===== 完成任务显示控制功能 =====
      let showCompleted = false; // 默认隐藏完成任务

      // 从localStorage读取用户偏好
      function loadCompletedVisibility() {
        const saved = localStorage.getItem('showCompletedTasks');
        showCompleted = saved === 'true';
        updateVisibilityButton();
      }

      // 保存用户偏好到localStorage
      function saveCompletedVisibility() {
        localStorage.setItem('showCompletedTasks', showCompleted);
      }

      // 更新按钮显示状态
      function updateVisibilityButton() {
        const visibilityBtn = document.getElementById('visibilityBtn');
        if (!visibilityBtn) return;

        const svg = visibilityBtn.querySelector('svg');
        if (!svg) return;

        if (showCompleted) {
          // 显示状态 - 普通眼睛图标
          svg.innerHTML = '<path d="M1 12s4-7 11-7 11 7 11 7-4 7-11 7S1 12 1 12z"/><circle cx="12" cy="12" r="3"/>';
          svg.setAttribute('aria-label', 'eye');
          svg.setAttribute('stroke-width', '1.8');
          svg.setAttribute('stroke-linecap', 'round');
          svg.setAttribute('stroke-linejoin', 'round');
          visibilityBtn.classList.add('showing');
          visibilityBtn.title = '隐藏完成任务';
        } else {
          // 隐藏状态 - 带斜线的眼睛图标
          svg.innerHTML = '<path d="M2 12s3.5-7 10-7 10 7 10 7-3.5 7-10 7S2 12 2 12z"/><circle cx="12" cy="12" r="3"/><line x1="2" y1="2" x2="22" y2="22"/>';
          svg.setAttribute('aria-label', 'eye-off');
          svg.setAttribute('stroke-width', '1.8');
          svg.setAttribute('stroke-linecap', 'round');
          svg.setAttribute('stroke-linejoin', 'round');
          visibilityBtn.classList.remove('showing');
          visibilityBtn.title = '显示完成任务';
        }
      }

      // 切换完成任务的显示状态
      function toggleCompletedVisibility() {
        showCompleted = !showCompleted;
        saveCompletedVisibility();
        updateVisibilityButton();
        applyCompletedVisibility();
      }

      // 应用完成任务的显示/隐藏
      function applyCompletedVisibility() {
        document.querySelectorAll('.task-wrapper').forEach(taskWrapper => {
          const task = taskWrapper.querySelector('.task');
          if (!task) return;

          // 通过复选框状态判断任务是否完成
          const checkbox = task.querySelector('.checkbox');
          if (checkbox) {
            const isCompleted = checkbox.classList.contains('done');
            taskWrapper.style.display = (isCompleted && !showCompleted) ? 'none' : '';
          }
        });
      }

      // 绑定眼睛按钮事件
      const visibilityBtn = document.getElementById('visibilityBtn');
      if (visibilityBtn && !visibilityBtn.__bound) {
        visibilityBtn.addEventListener('click', (event) => {
          event.stopPropagation();
          toggleCompletedVisibility();
        });
        visibilityBtn.__bound = true;
      }

      // 初始化完成任务的显示状态
      loadCompletedVisibility();

      // 绑定AI功能选项事件 - 专注模式风格
      const aiDropdownItems = document.querySelectorAll('#aiDropdown .menu-item');
      console.log('找到AI下拉菜单项数量:', aiDropdownItems.length); // 调试信息
      aiDropdownItems.forEach(item => {
        if (!item.__bound) {
          // 移动端触摸反馈
          item.addEventListener('touchstart', (event) => {
            event.stopPropagation();
            item.style.background = 'rgba(0,0,0,.1)';
            item.style.transform = 'scale(0.98)';
          });

          item.addEventListener('touchend', (event) => {
            event.stopPropagation();
            item.style.background = '';
            item.style.transform = '';
          });

          item.addEventListener('click', (event) => {
            event.stopPropagation();
            const action = item.dataset.action;
            console.log('AI下拉菜单项被点击，action:', action); // 调试信息
            callAIFunction(action);
          });
          item.__bound = true;
        }
      });
    }


    /**
     * ===== 数据同步和系统集成 =====
     */

    /**
     * 提交数据到iPhone快捷指令
     * @description 将当前数据序列化并通过shortcuts协议传递给名为"处理网页数据"的快捷指令
     */
    // 防止重复触发的标志
    let syncFired = false;

    function submitForm(){
      if (syncFired) {
        return;
      }
      syncFired = true;

      // 立即禁用按钮，防止重复触发
      const submitBtn = document.getElementById('syncSubmitBtn');
      if (submitBtn) {
        submitBtn.disabled = true;

        // 更新按钮文字为"已同步 + 当前时间"
        const now = new Date();
        const hh = String(now.getHours()).padStart(2,'0');
        const mm = String(now.getMinutes()).padStart(2,'0');
        const ss = String(now.getSeconds()).padStart(2,'0');
        submitBtn.textContent = `已同步 ${hh}:${mm}:${ss}`;
      }

      const json=(JSON.stringify(data));
      // 由用户手势触发的导航 - 这是关键！
      window.location.href=`shortcuts://run-shortcut?name=处理网页数据&input=${json}`;
    }

    /**
     * AI功能调用
     * @description 根据选择的功能调用对应的AI快捷指令
     */
    function callAIFunction(action) {
      console.log('callAIFunction被调用，action:', action); // 调试信息
      try {
        const functionName = action === 'aiReview' ? 'AI复盘' : 'AI安排';
        console.log('快捷指令名称:', functionName); // 调试信息

        // 先关闭下拉菜单
        hideAIDropdown();

        // 复用现有数据传递机制
        const json = JSON.stringify(data);
        const encodedInput = encodeURIComponent(json);

        // 构建快捷指令调用链接
        const shortcutsUrl = `shortcuts://run-shortcut?name=${functionName}&input=${encodedInput}`;

        // 延迟调用快捷指令，确保UI更新完成
        setTimeout(() => {
          try {
            window.location.href = shortcutsUrl;
          } catch (error) {
            console.error('快捷指令调用失败:', error);
          }
        }, 100);

      } catch (error) {
        console.error('AI功能调用出错:', error);
        hideAIDropdown();
      }
    }

    // 显示AI下拉菜单
    function showAIDropdown() {
      const aiBtn = document.getElementById('aiBtn');
      const dropdown = document.getElementById('aiDropdown');

      // 检查并关闭添加下拉菜单（互斥显示）
      const addDropdown = document.getElementById('addDropdownMenu');
      if (addDropdown.classList.contains('show')) {
        hideAddDropdown();
      }

      // 动态定位下拉菜单
      const btnRect = aiBtn.getBoundingClientRect();
      dropdown.style.top = `${btnRect.bottom + 4}px`;
      dropdown.style.right = `${window.innerWidth - btnRect.right}px`;

      dropdown.classList.add('show');

      // 点击外部关闭
      setTimeout(() => {
        document.addEventListener('click', hideAIDropdownOutside);
      }, 100);
    }

    // 隐藏AI下拉菜单
    function hideAIDropdown() {
      const dropdown = document.getElementById('aiDropdown');
      dropdown.classList.remove('show');
      document.removeEventListener('click', hideAIDropdownOutside);
    }

    // 点击外部关闭菜单
    function hideAIDropdownOutside(event) {
      const aiBtn = document.getElementById('aiBtn');
      const dropdown = document.getElementById('aiDropdown');

      if (!aiBtn.contains(event.target) && !dropdown.contains(event.target)) {
        hideAIDropdown();
      }
    }

    /**
     * 新建功能调用
     * @description 根据选择的功能调用对应的创建逻辑
     */
    function callAddFunction(action) {
      if (action === 'addSchedule') {
        // 复用现有日程创建逻辑
        scheduleCounter++;
        const newPartition = createSchedulePartition(`🗓️ 新日程${scheduleCounter}`);

        // 设置焦点标记，用于渲染后聚焦到新日程的占位符
        window.__focusNewSchedulePartition = newPartition.id;

        sortSchedulesByTime();
        render(!!window.Sortable);
      } else if (action === 'addTodo') {
        // 复用现有待办创建逻辑
        todoCounter++;
        const newTodoPartition = {
          id: generatePartitionId(),
          title: `待办事项列表${todoCounter}`,
          meta: {
            time: "",
            icon: "📋",
            collapsed: false,
            isTodoPartition: true,
            multiPartitionReady: true
          },
          tasks: []
        };

        // 直接向data[0]数组添加新的待办分区
        data[0].push(newTodoPartition);

        // 确保所有待办分区都有multiPartitionReady标志
        data[0].forEach(partition => {
          if (partition.meta) {
            partition.meta.multiPartitionReady = true;
          }
        });

                render(!!window.Sortable);
      }

      // 关闭新建下拉菜单 - 新的徽章方式会自动处理
    }

    // 显示新建下拉菜单 - 专注模式风格
    function showAddDropdown() {
      const addBtn = document.getElementById('addBtn');
      const dropdown = document.getElementById('addDropdownMenu');

      // 检查并关闭AI下拉菜单（互斥显示）
      const aiDropdown = document.getElementById('aiDropdown');
      if (aiDropdown.classList.contains('show')) {
        hideAIDropdown();
      }

      // 动态定位
      const btnRect = addBtn.getBoundingClientRect();
      dropdown.style.top = `${btnRect.bottom + 4}px`;
      dropdown.style.right = `${window.innerWidth - btnRect.right}px`;

      dropdown.classList.add('show');

      // 点击外部关闭
      setTimeout(() => {
        document.addEventListener('click', hideAddDropdownOutside);
      }, 100);
    }

    // 隐藏新建下拉菜单
    function hideAddDropdown() {
      const dropdown = document.getElementById('addDropdownMenu');
      dropdown.classList.remove('show');
      document.removeEventListener('click', hideAddDropdownOutside);
    }

    // 点击外部关闭菜单
    function hideAddDropdownOutside(event) {
      const addBtn = document.getElementById('addBtn');
      const dropdown = document.getElementById('addDropdownMenu');

      if (!addBtn.contains(event.target) && !dropdown.contains(event.target)) {
        hideAddDropdown();
      }
    }

    /**
     * ===== 移动端优化和初始化 =====
     */

    /**
     * 强化移动端体验优化
     * @description 禁用iOS/Android的手势缩放和下拉刷新，确保应用的原生体验
     */
    (function hardenNoZoomPullToRefresh(){
      document.addEventListener('gesturestart', e=>e.preventDefault());
      let lastTouchEnd=0;
      document.addEventListener('touchend', e=>{
        const now=Date.now();
        if(now-lastTouchEnd<=300){ e.preventDefault(); }
        lastTouchEnd=now;
      }, {passive:false});
    })();

    /**
     * ===== 应用初始化 =====
     */

    /**
     * ===== ID初始化函数 =====
     */

    /**
     * 为二维数组中的所有对象动态生成唯一ID
     * @description 遍历data数组，为每个分区和任务生成唯一ID
     */
    function initializeIds() {
      // 遍历待办事项数组 - data[0]
      if (data[0] && Array.isArray(data[0])) {
        data[0].forEach((partition, pIndex) => {
          // 为分区生成ID
          if (!partition.id) {
            partition.id = generatePartitionId();
          }

          // 为分区内的任务生成ID
          if (partition.tasks && Array.isArray(partition.tasks)) {
            partition.tasks.forEach((task, tIndex) => {
              if (!task.id) {
                task.id = generateTaskId();
              }
            });
          }
        });
      }

      // 遍历日程分区数组 - data[1]
      if (data[1] && Array.isArray(data[1])) {
        data[1].forEach((partition, pIndex) => {
          // 为分区生成ID
          if (!partition.id) {
            partition.id = generatePartitionId();
          }

          // 为分区内的任务生成ID
          if (partition.tasks && Array.isArray(partition.tasks)) {
            partition.tasks.forEach((task, tIndex) => {
              if (!task.id) {
                task.id = generateTaskId();
              }
            });
          }
        });
      }
    }

    /**
     * 初始化横屏适配布局
     */
    function initLandscapeLayout() {
      // 检测当前屏幕方向并应用相应样式
      function checkOrientation() {
        const isLandscape = window.innerWidth > window.innerHeight;
        const body = document.body;

        if (isLandscape) {
          body.classList.add('landscape-mode');
          body.classList.remove('portrait-mode');

          // 横屏模式下优化触摸行为
          document.documentElement.style.touchAction = 'pan-y';
        } else {
          body.classList.add('portrait-mode');
          body.classList.remove('landscape-mode');

          // 竖屏模式下恢复正常触摸行为
          document.documentElement.style.touchAction = 'pan-y';
        }
      }

      // 初始检测
      checkOrientation();

      // 监听窗口大小变化
      let resizeTimeout;
      window.addEventListener('resize', () => {
        if (resizeTimeout) {
          clearTimeout(resizeTimeout);
        }
        resizeTimeout = setTimeout(() => {
          checkOrientation();
          // 重新渲染以确保布局正确
          render(!!window.Sortable);
        }, 150);
      });

      // 监听屏幕方向变化
      if (window.screen && window.screen.orientation) {
        window.screen.orientation.addEventListener('change', () => {
          setTimeout(() => {
            checkOrientation();
            render(!!window.Sortable);
          }, 100);
        });
      }
    }

    /**
     * 应用初始化流程
     */
    function initializeApp() {

      // 第1步：为所有数据生成唯一ID
      initializeIds();

      // 第2步：确保全天日程分区存在
      ensureAllDayScheduleExists();

      // 第3步：主动统一分区数据结构（直接解决方案）
      standardizePartitionData();

      // 第4步：初始化横屏适配
      initLandscapeLayout();

      // 第4步：设置事件委托
      document.body.addEventListener('click', (event) => {
        if (event.target.classList.contains('task-delete')) {
          event.stopPropagation();
          event.preventDefault();

          const taskWrapper = event.target.closest('.task-wrapper');
          if (taskWrapper && taskWrapper.dataset.taskId) {
            const taskId = taskWrapper.dataset.taskId;
            deleteTaskById(taskId);
          }
        }
      }, true);

      // 第4步：首次完整渲染
      render(false);
    }

    // 应用初始化：确保DOM准备就绪后执行
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeApp);
    } else {
      initializeApp();
    }

    // 在页面渲染完成后应用完成任务的显示状态
    setTimeout(() => {
      if (typeof applyCompletedVisibility === 'function') {
        applyCompletedVisibility();
      }
    }, 100);
  </script>

<script>
/**
 * ===== 底部同步滑块功能模块 =====
 * 实现iPhone风格的滑动同步交互，支持拖拽、点击轨道、到达右端触发同步
 */

/**
 * 初始化同步滑块交互功能
 * @description 滑动到右端显示按钮，用户点击按钮触发submitForm()
 */
(function initSyncSlider(){
  const sliderStage = document.getElementById('syncSliderStage');
  const buttonStage = document.getElementById('syncButtonStage');
  const track = sliderStage;
  const thumb = document.getElementById('syncThumb');
  const submitBtn = document.getElementById('syncSubmitBtn');

  if (!track || !thumb || !sliderStage || !buttonStage || !submitBtn) return;

  const PAD = 2; // 轨道左右内边距，与 CSS 对齐
  let dragging = false;
  let startOffset = 0;
  let userGestureEvent = null;  // 保存用户手势事件 // pointer 起点到 thumb.left 的偏移

  function bounds(){
    const w = track.clientWidth;
    const tw = thumb.offsetWidth;
    return { min: PAD, max: Math.max(PAD, w - tw - PAD) };
  }
  function getLeft(){ return parseFloat(thumb.style.left || PAD) || PAD; }
  function setLeft(px){ thumb.style.left = `${px}px`; }

  function start(e){
    dragging = true;
    userGestureEvent = e;  // 保存原始用户事件
    const left = getLeft();
    startOffset = e.clientX - left;
    if (thumb.setPointerCapture) thumb.setPointerCapture(e.pointerId);
  }
  function move(e){
    if (!dragging) return;
    const { min, max } = bounds();
    let next = e.clientX - startOffset;
    if (next < min) next = min;
    if (next > max) next = max;
    setLeft(next);
    e.preventDefault();
  }
  function end(e){
    if (!dragging) return;

    cleanupEvents();  // 清理事件监听器
    dragging = false;

    const { max } = bounds();
    const cur = getLeft();

    if (cur >= max - 4) {
      // 隐藏滑块，显示按钮
      sliderStage.style.display = 'none';
      buttonStage.classList.add('show');

      // 可选：3秒后自动隐藏按钮并恢复滑块（如果用户没有点击）
      setTimeout(() => {
        if (!submitBtn.disabled && buttonStage.classList.contains('show')) {
          buttonStage.classList.remove('show');
          sliderStage.style.display = 'block';
          setLeft(PAD);
        }
      }, 5000);
    } else {
      setLeft(PAD);
    }

    userGestureEvent = null;  // 清理事件引用
  }


  // 关键修复：将所有事件都绑定在 thumb 元素上，保持用户手势上下文
  thumb.addEventListener('pointerdown', (e)=>{
    e.preventDefault();
    start(e);
    // 在开始拖拽时，将后续事件绑定到 thumb 上
    thumb.addEventListener('pointermove', move, { passive:false });
    thumb.addEventListener('pointerup', end);
    if (thumb.setPointerCapture) thumb.setPointerCapture(e.pointerId);
  });

  // 简化的结束处理
  function cleanupEvents() {
    thumb.removeEventListener('pointermove', move);
    thumb.removeEventListener('pointerup', end);
  }

  track.addEventListener('click', (e)=>{
    if (e.target === thumb) return;
    const { max } = bounds();
    setLeft(max);
    end();
  });

  thumb.setAttribute('role', 'button');
  thumb.setAttribute('tabindex', '0');
  thumb.addEventListener('keydown', (e)=>{
    if (e.key === ' ' || e.key === 'Enter') {
      e.preventDefault();
      const { max } = bounds();
      setLeft(max);
      end();
    } else if (e.key === 'ArrowRight') {
      e.preventDefault();
      const { max } = bounds();
      setLeft(max);
    } else if (e.key === 'ArrowLeft') {
      e.preventDefault();
      setLeft(PAD);
    }
  });

  setLeft(PAD);
})();
</script>

<script>
/**
 * ===== 同步滑块显示控制模块 =====
 * 使用Intersection Observer检测用户滚动到页面底部时显示同步滑块
 */

/**
 * 页面底部滑块显示控制器
 * @description 监听页面滚动，当用户到达最底部时显示同步滑块，带防闪烁优化
 */
(function showSyncAtBottom(){
  const bar = document.querySelector('.sync-bar');
  const sentinel = document.getElementById('bottomSentinel');
  const spacer = document.getElementById('syncSpacer');

  if (!bar || !sentinel || !spacer) {
    return;
  }

  let visible = false;
  let lock = false;
  const LOCK_MS = 250;

  const schedule = document.getElementById('schedule');

  function setVisible(v){
    if (visible === v || lock) return;
    visible = v;
    lock = true;

    if (v){
      bar.classList.add('show');
      spacer.classList.add('show');
      schedule?.classList.add('sync-visible');
      schedule?.classList.remove('sync-approaching');
    } else {
      bar.classList.remove('show');
      spacer.classList.remove('show');
      schedule?.classList.remove('sync-visible');
      schedule?.classList.remove('sync-approaching');
    }

    setTimeout(()=>{ lock = false; }, LOCK_MS);
  }

  // 新增：设置接近状态的函数
  function setApproaching(approaching){
    if (approaching && !visible) {
      schedule?.classList.add('sync-approaching');
    } else {
      schedule?.classList.remove('sync-approaching');
    }
  }

  // 优化的滚动检测 - 支持渐进式状态
  function checkScrollPosition() {
    const windowHeight = window.innerHeight;
    const documentHeight = document.documentElement.scrollHeight;
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

    const remainingDistance = documentHeight - (scrollTop + windowHeight);

    // 接近状态：距离底部300-200px
    const approaching = remainingDistance <= 300 && remainingDistance > 200;

    // 显示状态：距离底部200px内
    const atBottom = remainingDistance <= 200;

    return { approaching, atBottom };
  }

  // 优先使用IntersectionObserver，但调整参数
  if ('IntersectionObserver' in window) {
    const io = new IntersectionObserver((entries)=>{
      const { approaching, atBottom } = checkScrollPosition();
      setApproaching(approaching);
      setVisible(atBottom);
    }, {
      root: null,
      threshold: 0,
      rootMargin: '0px 0px -20px 0px'  // 减少边距，更容易触发
    });

    io.observe(sentinel);
  }

  // 无论是否支持IntersectionObserver，都添加滚动事件作为备用
  const onScroll = ()=>{
    const { approaching, atBottom } = checkScrollPosition();
    setApproaching(approaching);
    setVisible(atBottom);
  };

  window.addEventListener('scroll', onScroll, { passive: true });

  // 立即检查一次
  setTimeout(() => {
    onScroll();
  }, 500);
})();

// 原型v3.html JavaScript（完全照抄）
const ov=document.getElementById('ov'),sheet=document.getElementById('sheet');
const closeNow=()=>{
  ov.classList.remove('active');
  sheet.style.bottom='-100%';

  // 恢复底部滑动条的显示状态（如果之前是临时隐藏的）
  const syncBar = document.querySelector('.sync-bar');
  if (syncBar && syncBar.getAttribute('data-temp-hidden') === 'true') {
    syncBar.classList.add('show');
    syncBar.removeAttribute('data-temp-hidden');
  }
};
document.getElementById('btnClose').onclick=closeNow;
document.getElementById('btnDone').onclick=()=>{
  if (pickerTargetId !== null) {
    const partition = findPartitionById(pickerTargetId);
    if (partition) {
      // 保存表情选择
      const selectedEmoji = document.getElementById('emojiShow').textContent;
      if (selectedEmoji) {
        partition.meta = partition.meta || {};
        partition.meta.icon = selectedEmoji;
      }

      // 在关闭前确保标题已保存
      const titleInput = document.getElementById('title');
      if (partition.title !== titleInput.value.trim()) {
        // 直接触发标题保存
        saveTitleChange();
      }

      // 保存所有数据
      if (typeof saveAllInputs === 'function') {
        saveAllInputs();
      }

      // 重新渲染界面
      if (typeof render === 'function') {
        render(!!window.Sortable);
      }
    }
  }
  closeNow();
};

// 番茄徽标
(()=>{
const badge=document.getElementById('focusBadge');
const text=document.getElementById('focusBadgeText');
const menu=document.getElementById('focusMenu');
badge.onclick=(e)=>{
  e.stopPropagation();
  if (menu.style.display === 'block') {
    menu.style.display = 'none';
    DropdownManager.currentOpen = null;
  } else {
    menu.style.display = 'block';
    DropdownManager.open('focusMenu');
  }
};
menu.querySelectorAll('.menu-item').forEach(it=>{
it.onclick=(e)=>{e.stopPropagation();
text.textContent=it.dataset.value==='无'?'无':it.dataset.value;
menu.querySelectorAll('.menu-item').forEach(x=>x.classList.remove('selected'));
it.classList.add('selected');menu.style.display='none';DropdownManager.currentOpen = null;

// 保存到分区数据
if(pickerTargetId!==null){
  const partition = findPartitionById(pickerTargetId);
  if (partition) {
    ensurePartitionMeta(partition);
    partition.meta.pomodoroBadge.type = it.dataset.value;
    partition.meta.pomodoroBadge.enabled = it.dataset.value !== 'none';

    // 保存标题（如果有更改）
    const titleInput = document.getElementById('title');
    if (titleInput && partition.title !== titleInput.value.trim()) {
      const newTitle = titleInput.value.trim();
      if (newTitle && newTitle !== partition.title) {
        const oldTitle = partition.title;
        partition.title = newTitle;

        // 简单的标题更新逻辑
        if (!partition.meta) partition.meta = {};
        partition.meta.titleNoFrac = newTitle.replace(/\s*\(?\d+\/\d+\)?\s*$/, '').trim();
        if (!partition.meta.icon) {
          partition.meta.icon = newTitle.charCodeAt(0) >= 0x1F000 ? newTitle.charAt(0) : '📋';
        }

        }
    }

    if (typeof saveAllInputs === 'function') {
      saveAllInputs();
    }
  }
}
};
});
window.onclick=()=>menu.style.display='none';
})();

// 日历 & 专注模式
function setup(cardId,selId,labelId,menuId){
const card=document.getElementById(cardId);
const sel=document.getElementById(selId);
const label=document.getElementById(labelId);
const menu=document.getElementById(menuId);
sel.onclick=(e)=>{
  e.stopPropagation();
  if (menu.style.display === 'block') {
    menu.style.display = 'none';
    DropdownManager.currentOpen = null;
  } else {
    menu.style.display = 'block';
    DropdownManager.open(menuId);
  }
};
menu.querySelectorAll('.menu-item').forEach(it=>{
it.onclick=(e)=>{e.stopPropagation();
const val=it.dataset.value||'';
if(cardId==='calCard'){
const color=it.dataset.color||'#999',emoji=it.dataset.emoji||'';
label.innerHTML=`<span class="dot" style="background:${color}"></span><span>${emoji} ${val}</span>`;
document.getElementById('bar').style.background=color;

// 保存日历分类到分区数据
if(pickerTargetId!==null){
  const partition = findPartitionById(pickerTargetId);
  if (partition) {
    partition.meta.calendarCategory.name = val;
    partition.meta.calendarCategory.color = color;
    partition.meta.calendarCategory.emoji = emoji;
    partition.meta.calendarCategory.enabled = true;
    if (typeof saveAllInputs === 'function') {
      saveAllInputs();
    }
  }
}
}else{
label.textContent=val||'专注模式';

// 保存专注模式到分区数据
if(pickerTargetId!==null){
  const partition = findPartitionById(pickerTargetId);
  if (partition) {
    partition.meta.focusMode.type = val;
    partition.meta.focusMode.enabled = val !== '无';
    if (typeof saveAllInputs === 'function') {
      saveAllInputs();
    }
  }
}
}
menu.querySelectorAll('.menu-item').forEach(x=>x.classList.remove('selected'));
it.classList.add('selected');menu.style.display='none';DropdownManager.currentOpen = null;};
});
window.onclick=()=>menu.style.display='none';
}
setup('calCard','calSel','calText','calMenu');
setup('modeCard','modeSel','modeText','modeMenu');

// 提醒事项列表功能
function setupReminderList() {
  const card = document.getElementById('reminderCard');
  const sel = document.getElementById('reminderSel');
  const label = document.getElementById('reminderText');
  const menu = document.getElementById('reminderMenu');

  // 生成待办分区选项
  function generateReminderOptions() {
    const todoPartitions = data[0] || [];
    menu.innerHTML = '';

    todoPartitions.forEach(partition => {
      const title = partition.title || '未命名分区';

      const menuItem = document.createElement('div');
      menuItem.className = 'menu-item';
      menuItem.dataset.value = partition.id;
      menuItem.innerHTML = `
        <div class="left">
          <span>${title}</span>
        </div>
        <div class="check"></div>
      `;

      menuItem.onclick = (e) => {
        e.stopPropagation();
        selectReminderPartition(partition.id, title);

        // 更新选中状态
        menu.querySelectorAll('.menu-item').forEach(x => x.classList.remove('selected'));
        menuItem.classList.add('selected');
        menu.style.display = 'none';
        DropdownManager.currentOpen = null;
      };

      menu.appendChild(menuItem);
    });
  }

  // 选择提醒事项分区
  function selectReminderPartition(partitionId, title) {

    // 更新按钮显示
    label.innerHTML = `<span>${title}</span>`;

    // 保存到当前编辑分区的meta
    if (typeof pickerTargetId !== 'undefined' && pickerTargetId !== null) {
      const currentPartition = findPartitionById(pickerTargetId);
      if (currentPartition) {
        ensurePartitionMeta(currentPartition);
        currentPartition.meta.selectedReminderPartition = {
          id: partitionId,
          title: title,
          emoji: null
        };
        if (typeof saveAllInputs === 'function') {
          saveAllInputs();
          // 保存后立即重新设置label内容，防止被覆盖
          setTimeout(() => {
            label.innerHTML = `<span>${title}</span>`;
          }, 50);
        }
      }
    }
  }

  // 恢复选中状态
  function restoreReminderSelection() {
    // 延迟检查pickerTargetId，确保变量已初始化
    setTimeout(() => {
      if (typeof pickerTargetId !== 'undefined' && pickerTargetId !== null) {
        const partition = findPartitionById(pickerTargetId);
        if (partition?.meta?.selectedReminderPartition) {
          const selected = partition.meta.selectedReminderPartition;

          // 只有当数据有效时才更新显示
          if (selected.id && selected.title) {
            label.innerHTML = `<span>${selected.title}</span>`;
          }

          // 设置菜单选中状态 - 只有当数据有效时才设置
          if (selected.id && selected.title) {
            setTimeout(() => {
              const menuItem = menu.querySelector(`[data-value="${selected.id}"]`);
              if (menuItem) {
                menu.querySelectorAll('.menu-item').forEach(x => x.classList.remove('selected'));
                menuItem.classList.add('selected');
              }
            }, 100);
          }
        }
      }
    }, 0);
  }

  // 绑定点击事件
  sel.onclick = (e) => {
    e.stopPropagation();
    if (menu.style.display === 'block') {
      menu.style.display = 'none';
      DropdownManager.currentOpen = null;
    } else {
      generateReminderOptions(); // 每次打开时重新生成
      restoreReminderSelection(); // 恢复选中状态
      menu.style.display = 'block';
      DropdownManager.open('reminderMenu');
    }
  };

  // 初始化时恢复选中状态
  restoreReminderSelection();
}

// 标题输入框实时保存机制
(()=>{
  const titleInput = document.getElementById('title');
  let saveTimeout = null;

  // 监听标题输入变化
  titleInput.addEventListener('input', (e) => {
    // 清除之前的定时器
    if (saveTimeout) {
      clearTimeout(saveTimeout);
    }

    // 延迟保存，避免频繁保存
    saveTimeout = setTimeout(() => {
      saveTitleChange();
    }, 300);
  });

  // 监听标题失去焦点，立即保存
  titleInput.addEventListener('blur', () => {
    if (saveTimeout) {
      clearTimeout(saveTimeout);
      saveTimeout = null;
    }
    saveTitleChange();
  });

  // 监听回车键，保存标题但不关闭面板
  titleInput.addEventListener('keydown', (e) => {
    if (e.key === 'Enter') {
      e.preventDefault();
      if (saveTimeout) {
        clearTimeout(saveTimeout);
        saveTimeout = null;
      }
      saveTitleChange();
    }
  });

  /**
   * 保存标题变化到分区数据
   */
  function saveTitleChange() {
    if (pickerTargetId !== null) {
      const partition = findPartitionById(pickerTargetId);
      if (partition) {
        const newTitle = titleInput.value.trim();

        // 只有标题确实发生变化时才保存
        if (partition.title !== newTitle) {
          const oldTitle = partition.title;

          // 更新主标题
          partition.title = newTitle;

          // 更新分区标题显示相关的所有字段
          updatePartitionTitleDisplay(partition, newTitle);

          // 保存数据
          if (typeof saveAllInputs === 'function') {
            saveAllInputs();
          }

          // 强制重新渲染界面以更新分区标题显示
          if (typeof render === 'function') {
            render(!!window.Sortable);
          }

            }
      }
    }
  }

  /**
   * 更新分区标题相关的所有显示字段
   * @param {Object} partition - 分区对象
   * @param {string} newTitle - 新标题
   */
  function updatePartitionTitleDisplay(partition, newTitle) {
    // 解析新标题的徽标信息
    const {titleNoFrac, baseDone, baseTotal} = parseTitleFraction(newTitle);

    // 更新titleNoFrac字段（如果存在）
    if (partition.meta) {
      partition.meta.titleNoFrac = titleNoFrac;

      // 更新badge信息（如果存在）
      if (partition.meta.badge) {
        partition.meta.badge.titleNoFrac = titleNoFrac;
        partition.meta.badge.baseDone = baseDone;
        partition.meta.badge.baseTotal = baseTotal;
      }

      // 确保icon字段存在
      if (!partition.meta.icon) {
        partition.meta.icon = firstCodePoint(newTitle) || '📋';
      }
    }
  }

  // 将函数暴露到全局作用域
  window.saveTitleChange = saveTitleChange;

  })();

// Emoji 生成
const list=["🙂","📋","🔖","🔑","🎁","🎂","💳","💵","🏋️","🏃","🍴","🍷","💊","🩺","🪑","🏠","🏢","🏛️","⛺","🖥️","🎵","📱","🎮","🎧","📚","🧹","🧼","🕒","📝","📸","💻","🧠","🍎","🥛","🍵"];
const eg=document.getElementById('eg'),emojiShow=document.getElementById('emojiShow');
list.forEach(e=>{
const b=document.createElement('button');
b.className='emoji-btn';b.textContent=e;
b.onclick=()=>{
  // 只更新选中状态，不自动关闭面板
  document.querySelectorAll('.emoji-btn').forEach(x=>x.classList.remove('active'));
  b.classList.add('active');
  emojiShow.textContent=e;
};
eg.appendChild(b);
});

// 重新定义必要的变量和函数
let pickerTargetId = null;

// 下拉菜单管理器
const DropdownManager = {
  currentOpen: null,

  // 打开指定的下拉菜单
  open(menuId) {
    // 如果有其他菜单打开，先关闭
    if (this.currentOpen && this.currentOpen !== menuId) {
      this.close(this.currentOpen);
    }
    this.currentOpen = menuId;
  },

  // 关闭指定的下拉菜单
  close(menuId) {
    const menu = document.getElementById(menuId);
    if (menu) {
      menu.style.display = 'none';
    }
    if (this.currentOpen === menuId) {
      this.currentOpen = null;
    }
  },

  // 关闭所有下拉菜单
  closeAll() {
    if (this.currentOpen) {
      this.close(this.currentOpen);
    }
  }
};

// 确保分区meta对象存在
function ensurePartitionMeta(partition) {
  if (!partition.meta) {
    partition.meta = {};
  }
  if (!partition.meta.pomodoroBadge) {
    partition.meta.pomodoroBadge = {
      type: "none",
      enabled: false
    };
  }
}

// 初始化提醒事项列表（在pickerTargetId声明之后）
setupReminderList();

function openPicker(targetId, displayTitle){
  pickerTargetId = targetId;

  // 获取分区数据
  const partition = findPartitionById(targetId);
  if (!partition) return;

  // 填充标题 - 直接使用titleNoFrac属性
  const titleText = partition.meta?.titleNoFrac || displayTitle || '';
  document.getElementById('title').value = titleText;

  // 填充emoji
  if (partition.meta.icon) {
    document.getElementById('emojiShow').textContent = partition.meta.icon;
    // 更新emoji选中状态
    document.querySelectorAll('.emoji-btn').forEach(btn => {
      btn.classList.remove('active');
      if (btn.textContent === partition.meta.icon) {
        btn.classList.add('active');
      }
    });
  }

  // 填充番茄徽标
  if (partition.meta.pomodoroBadge) {
    const focusText = document.getElementById('focusBadgeText');
    if (partition.meta.pomodoroBadge.enabled && partition.meta.pomodoroBadge.type !== 'none') {
      focusText.textContent = partition.meta.pomodoroBadge.type;
    } else {
      focusText.textContent = '无';
    }

    // 更新选中状态
    document.querySelectorAll('#focusMenu .menu-item').forEach(item => {
      item.classList.remove('selected');
      if (item.dataset.value === partition.meta.pomodoroBadge.type) {
        item.classList.add('selected');
      }
    });
  }

  // 填充日历分类
  if (partition.meta.calendarCategory) {
    const calText = document.getElementById('calText');
    if (partition.meta.calendarCategory.enabled) {
      calText.innerHTML = `<span class="dot" style="background:${partition.meta.calendarCategory.color}"></span><span>${partition.meta.calendarCategory.emoji} ${partition.meta.calendarCategory.name}</span>`;
      document.getElementById('bar').style.background = partition.meta.calendarCategory.color;
    } else {
      calText.innerHTML = '<span class="dot" id="calDot" style="background:#999"></span><span>分类</span>';
    }

    // 更新选中状态
    document.querySelectorAll('#calMenu .menu-item').forEach(item => {
      item.classList.remove('selected');
      if (item.dataset.value === partition.meta.calendarCategory.name) {
        item.classList.add('selected');
      }
    });
  }

  // 填充分专注模式
  if (partition.meta.focusMode) {
    const modeText = document.getElementById('modeText');
    if (partition.meta.focusMode.enabled && partition.meta.focusMode.type !== '无') {
      modeText.textContent = partition.meta.focusMode.type;
    } else {
      modeText.textContent = '专注模式';
    }

    // 更新选中状态
    document.querySelectorAll('#modeMenu .menu-item').forEach(item => {
      item.classList.remove('selected');
      if (item.dataset.value === partition.meta.focusMode.type) {
        item.classList.add('selected');
      }
    });
  }

  // 填充提醒事项列表
  if (partition.meta.selectedReminderPartition) {
    const selected = partition.meta.selectedReminderPartition;
    const reminderText = document.getElementById('reminderText');

    // 只有当selectedReminderPartition有有效数据时才更新显示
    if (selected.id && selected.title) {
      reminderText.innerHTML = `<span>${selected.title}</span>`;

      // 更新选中状态
      const menuItem = document.querySelector(`#reminderMenu .menu-item[data-value="${selected.id}"]`);
      if (menuItem) {
        document.querySelectorAll('#reminderMenu .menu-item').forEach(item => {
          item.classList.remove('selected');
        });
        menuItem.classList.add('selected');
      }
    }
  }

  document.getElementById('ov').classList.add('active');
  document.getElementById('sheet').style.bottom='0';

  // 隐藏底部滑动条，避免遮挡表情选择器
  const syncBar = document.querySelector('.sync-bar');
  if (syncBar && syncBar.classList.contains('show')) {
    syncBar.classList.remove('show');
    syncBar.setAttribute('data-temp-hidden', 'true');
  }
// 关闭所有下拉菜单
  DropdownManager.closeAll();
}
function closePicker() {
  DropdownManager.closeAll();
  closeNow();
}


/**
 * 主动统一分区数据结构 - 直接解决方案
 * 在应用启动时强制为所有分区添加完整的新字段
 */
function standardizePartitionData() {
  let standardizedCount = 0;

  data.forEach(partitionGroup => {
    partitionGroup.forEach(partition => {
      // 确保meta对象存在
      if (!partition.meta) {
        partition.meta = {};
      }

      // 直接添加完整的新字段，不检查是否存在
      partition.meta.pomodoroBadge = {
        type: "none",
        enabled: false
      };

      partition.meta.calendarCategory = {
        name: "工作",
        color: "#bf5af2",
        emoji: "💻",
        enabled: false
      };

      partition.meta.focusMode = {
        type: "无",
        enabled: false
      };

      // 只有当selectedReminderPartition不存在时才初始化
      if (!partition.meta.selectedReminderPartition) {
        partition.meta.selectedReminderPartition = {
          id: null,
          title: null,
          emoji: null
        };
      }

      standardizedCount++;
    });
  });

  // 保存统一后的数据
  if (typeof saveAllInputs === 'function') {
    saveAllInputs();
    }

  return standardizedCount;
}

/**
 * 验证分区数据完整性 - 基于原型v3.html整合方案
 * @param {Object} partition - 分区对象
 * @returns {Array} 错误列表
 */
function validatePartitionData(partition) {
  const errors = [];

  // 验证必需字段
  if (!partition.meta) errors.push("meta对象缺失");
  if (!partition.meta.icon) errors.push("icon字段缺失");

  // 验证番茄徽标
  if (partition.meta.pomodoroBadge) {
    const validTypes = ["none", "番茄时间", "时间盒"];
    if (!validTypes.includes(partition.meta.pomodoroBadge.type)) {
      errors.push(`无效的番茄徽标类型: ${partition.meta.pomodoroBadge.type}`);
    }
  }

  // 验证日历分类
  if (partition.meta.calendarCategory && partition.meta.calendarCategory.enabled) {
    const validCategories = ["工作", "休闲", "家庭", "学习", "机动", "习惯"];
    const validCategory = validCategories.includes(partition.meta.calendarCategory.name);
    if (!validCategory) {
      errors.push(`无效的日历分类名称: ${partition.meta.calendarCategory.name}`);
    }
  }

  // 验证专注模式
  if (partition.meta.focusMode) {
    const validModes = ["无", "💻工作", "🛝娱乐", "🧑‍🏫课堂", "🎙️会议"];
    if (!validModes.includes(partition.meta.focusMode.type)) {
      errors.push(`无效的专注模式类型: ${partition.meta.focusMode.type}`);
    }
  }

  return errors;
}

</script>


</body>
</html>
